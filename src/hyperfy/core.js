var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));

// node_modules/@jspm/core/nodelibs/browser/process.js
var process_exports = {};
__export(process_exports, {
  _debugEnd: () => _debugEnd,
  _debugProcess: () => _debugProcess,
  _events: () => _events,
  _eventsCount: () => _eventsCount,
  _exiting: () => _exiting,
  _fatalExceptions: () => _fatalExceptions,
  _getActiveHandles: () => _getActiveHandles,
  _getActiveRequests: () => _getActiveRequests,
  _kill: () => _kill,
  _linkedBinding: () => _linkedBinding,
  _maxListeners: () => _maxListeners,
  _preload_modules: () => _preload_modules,
  _rawDebug: () => _rawDebug,
  _startProfilerIdleNotifier: () => _startProfilerIdleNotifier,
  _stopProfilerIdleNotifier: () => _stopProfilerIdleNotifier,
  _tickCallback: () => _tickCallback,
  abort: () => abort,
  addListener: () => addListener,
  allowedNodeEnvironmentFlags: () => allowedNodeEnvironmentFlags,
  arch: () => arch,
  argv: () => argv,
  argv0: () => argv0,
  assert: () => assert,
  binding: () => binding,
  browser: () => browser,
  chdir: () => chdir,
  config: () => config,
  cpuUsage: () => cpuUsage,
  cwd: () => cwd,
  debugPort: () => debugPort,
  default: () => process,
  dlopen: () => dlopen,
  domain: () => domain,
  emit: () => emit,
  emitWarning: () => emitWarning,
  env: () => env2,
  execArgv: () => execArgv,
  execPath: () => execPath,
  exit: () => exit,
  features: () => features,
  hasUncaughtExceptionCaptureCallback: () => hasUncaughtExceptionCaptureCallback,
  hrtime: () => hrtime,
  kill: () => kill,
  listeners: () => listeners,
  memoryUsage: () => memoryUsage,
  moduleLoadList: () => moduleLoadList,
  nextTick: () => nextTick,
  off: () => off,
  on: () => on,
  once: () => once,
  openStdin: () => openStdin,
  pid: () => pid,
  platform: () => platform,
  ppid: () => ppid,
  prependListener: () => prependListener,
  prependOnceListener: () => prependOnceListener,
  reallyExit: () => reallyExit,
  release: () => release,
  removeAllListeners: () => removeAllListeners,
  removeListener: () => removeListener,
  resourceUsage: () => resourceUsage,
  setSourceMapsEnabled: () => setSourceMapsEnabled,
  setUncaughtExceptionCaptureCallback: () => setUncaughtExceptionCaptureCallback,
  stderr: () => stderr,
  stdin: () => stdin,
  stdout: () => stdout,
  title: () => title,
  umask: () => umask,
  uptime: () => uptime,
  version: () => version,
  versions: () => versions
});
function unimplemented(name2) {
  throw new Error("Node.js process " + name2 + " is not supported by JSPM core outside of Node.js");
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue)
    return;
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length)
    drainQueue();
}
function drainQueue() {
  if (draining)
    return;
  var timeout = setTimeout(cleanUpNextTick, 0);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue)
        currentQueue[queueIndex].run();
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  clearTimeout(timeout);
}
function nextTick(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i5 = 1; i5 < arguments.length; i5++)
      args[i5 - 1] = arguments[i5];
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining)
    setTimeout(drainQueue, 0);
}
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
var title = "browser";
var arch = "x64";
var platform = "browser";
var env2 = {
  PATH: "/usr/bin",
  LANG: typeof navigator !== "undefined" ? navigator.language + ".UTF-8" : void 0,
  PWD: "/",
  HOME: "/home",
  TMP: "/tmp"
};
var argv = ["/usr/bin/node"];
var execArgv = [];
var version = "v16.8.0";
var versions = {};
var emitWarning = function(message, type) {
  console.warn((type ? type + ": " : "") + message);
};
var binding = function(name2) {
  unimplemented("binding");
};
var umask = function(mask) {
  return 0;
};
var cwd = function() {
  return "/";
};
var chdir = function(dir) {
};
var release = {
  name: "node",
  sourceUrl: "",
  headersUrl: "",
  libUrl: ""
};
function noop() {
}
var browser = true;
var _rawDebug = noop;
var moduleLoadList = [];
function _linkedBinding(name2) {
  unimplemented("_linkedBinding");
}
var domain = {};
var _exiting = false;
var config = {};
function dlopen(name2) {
  unimplemented("dlopen");
}
function _getActiveRequests() {
  return [];
}
function _getActiveHandles() {
  return [];
}
var reallyExit = noop;
var _kill = noop;
var cpuUsage = function() {
  return {};
};
var resourceUsage = cpuUsage;
var memoryUsage = cpuUsage;
var kill = noop;
var exit = noop;
var openStdin = noop;
var allowedNodeEnvironmentFlags = {};
function assert(condition, message) {
  if (!condition) throw new Error(message || "assertion error");
}
var features = {
  inspector: false,
  debug: false,
  uv: false,
  ipv6: false,
  tls_alpn: false,
  tls_sni: false,
  tls_ocsp: false,
  tls: false,
  cached_builtins: true
};
var _fatalExceptions = noop;
var setUncaughtExceptionCaptureCallback = noop;
function hasUncaughtExceptionCaptureCallback() {
  return false;
}
var _tickCallback = noop;
var _debugProcess = noop;
var _debugEnd = noop;
var _startProfilerIdleNotifier = noop;
var _stopProfilerIdleNotifier = noop;
var stdout = void 0;
var stderr = void 0;
var stdin = void 0;
var abort = noop;
var pid = 2;
var ppid = 1;
var execPath = "/bin/usr/node";
var debugPort = 9229;
var argv0 = "node";
var _preload_modules = [];
var setSourceMapsEnabled = noop;
var _performance = {
  now: typeof performance !== "undefined" ? performance.now.bind(performance) : void 0,
  timing: typeof performance !== "undefined" ? performance.timing : void 0
};
if (_performance.now === void 0) {
  nowOffset = Date.now();
  if (_performance.timing && _performance.timing.navigationStart) {
    nowOffset = _performance.timing.navigationStart;
  }
  _performance.now = () => Date.now() - nowOffset;
}
var nowOffset;
function uptime() {
  return _performance.now() / 1e3;
}
var nanoPerSec = 1e9;
function hrtime(previousTimestamp) {
  var baseNow = Math.floor((Date.now() - _performance.now()) * 1e-3);
  var clocktime = _performance.now() * 1e-3;
  var seconds = Math.floor(clocktime) + baseNow;
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += nanoPerSec;
    }
  }
  return [seconds, nanoseconds];
}
hrtime.bigint = function(time) {
  var diff = hrtime(time);
  if (typeof BigInt === "undefined") {
    return diff[0] * nanoPerSec + diff[1];
  }
  return BigInt(diff[0] * nanoPerSec) + BigInt(diff[1]);
};
var _maxListeners = 10;
var _events = {};
var _eventsCount = 0;
function on() {
  return process;
}
var addListener = on;
var once = on;
var off = on;
var removeListener = on;
var removeAllListeners = on;
var emit = noop;
var prependListener = on;
var prependOnceListener = on;
function listeners(name2) {
  return [];
}
var process = {
  version,
  versions,
  arch,
  platform,
  browser,
  release,
  _rawDebug,
  moduleLoadList,
  binding,
  _linkedBinding,
  _events,
  _eventsCount,
  _maxListeners,
  on,
  addListener,
  once,
  off,
  removeListener,
  removeAllListeners,
  emit,
  prependListener,
  prependOnceListener,
  listeners,
  domain,
  _exiting,
  config,
  dlopen,
  uptime,
  _getActiveRequests,
  _getActiveHandles,
  reallyExit,
  _kill,
  cpuUsage,
  resourceUsage,
  memoryUsage,
  kill,
  exit,
  openStdin,
  allowedNodeEnvironmentFlags,
  assert,
  features,
  _fatalExceptions,
  setUncaughtExceptionCaptureCallback,
  hasUncaughtExceptionCaptureCallback,
  emitWarning,
  nextTick,
  _tickCallback,
  _debugProcess,
  _debugEnd,
  _startProfilerIdleNotifier,
  _stopProfilerIdleNotifier,
  stdout,
  stdin,
  stderr,
  abort,
  umask,
  chdir,
  cwd,
  env: env2,
  title,
  argv,
  execArgv,
  pid,
  ppid,
  execPath,
  debugPort,
  hrtime,
  argv0,
  _preload_modules,
  setSourceMapsEnabled
};

// node_modules/@jspm/core/nodelibs/browser/chunk-DtuTasat.js
var exports$2 = {};
var _dewExec$2 = false;
function dew$2() {
  if (_dewExec$2) return exports$2;
  _dewExec$2 = true;
  exports$2.byteLength = byteLength;
  exports$2.toByteArray = toByteArray;
  exports$2.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i5 = 0, len = code.length; i5 < len; ++i5) {
    lookup[i5] = code[i5];
    revLookup[code.charCodeAt(i5)] = i5;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i6;
    for (i6 = 0; i6 < len2; i6 += 4) {
      tmp = revLookup[b64.charCodeAt(i6)] << 18 | revLookup[b64.charCodeAt(i6 + 1)] << 12 | revLookup[b64.charCodeAt(i6 + 2)] << 6 | revLookup[b64.charCodeAt(i6 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i6)] << 2 | revLookup[b64.charCodeAt(i6 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i6)] << 10 | revLookup[b64.charCodeAt(i6 + 1)] << 4 | revLookup[b64.charCodeAt(i6 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num2) {
    return lookup[num2 >> 18 & 63] + lookup[num2 >> 12 & 63] + lookup[num2 >> 6 & 63] + lookup[num2 & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i6 = start; i6 < end; i6 += 3) {
      tmp = (uint8[i6] << 16 & 16711680) + (uint8[i6 + 1] << 8 & 65280) + (uint8[i6 + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i6 = 0, len22 = len2 - extraBytes; i6 < len22; i6 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i6, i6 + maxChunkLength > len22 ? len22 : i6 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
    }
    return parts.join("");
  }
  return exports$2;
}
var exports$1 = {};
var _dewExec$1 = false;
function dew$1() {
  if (_dewExec$1) return exports$1;
  _dewExec$1 = true;
  exports$1.read = function(buffer2, offset, isLE, mLen, nBytes) {
    var e7, m7;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i5 = isLE ? nBytes - 1 : 0;
    var d5 = isLE ? -1 : 1;
    var s5 = buffer2[offset + i5];
    i5 += d5;
    e7 = s5 & (1 << -nBits) - 1;
    s5 >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e7 = e7 * 256 + buffer2[offset + i5], i5 += d5, nBits -= 8) {
    }
    m7 = e7 & (1 << -nBits) - 1;
    e7 >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m7 = m7 * 256 + buffer2[offset + i5], i5 += d5, nBits -= 8) {
    }
    if (e7 === 0) {
      e7 = 1 - eBias;
    } else if (e7 === eMax) {
      return m7 ? NaN : (s5 ? -1 : 1) * Infinity;
    } else {
      m7 = m7 + Math.pow(2, mLen);
      e7 = e7 - eBias;
    }
    return (s5 ? -1 : 1) * m7 * Math.pow(2, e7 - mLen);
  };
  exports$1.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
    var e7, m7, c5;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i5 = isLE ? 0 : nBytes - 1;
    var d5 = isLE ? 1 : -1;
    var s5 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m7 = isNaN(value) ? 1 : 0;
      e7 = eMax;
    } else {
      e7 = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c5 = Math.pow(2, -e7)) < 1) {
        e7--;
        c5 *= 2;
      }
      if (e7 + eBias >= 1) {
        value += rt / c5;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c5 >= 2) {
        e7++;
        c5 /= 2;
      }
      if (e7 + eBias >= eMax) {
        m7 = 0;
        e7 = eMax;
      } else if (e7 + eBias >= 1) {
        m7 = (value * c5 - 1) * Math.pow(2, mLen);
        e7 = e7 + eBias;
      } else {
        m7 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e7 = 0;
      }
    }
    for (; mLen >= 8; buffer2[offset + i5] = m7 & 255, i5 += d5, m7 /= 256, mLen -= 8) {
    }
    e7 = e7 << mLen | m7;
    eLen += mLen;
    for (; eLen > 0; buffer2[offset + i5] = e7 & 255, i5 += d5, e7 /= 256, eLen -= 8) {
    }
    buffer2[offset + i5 - d5] |= s5 * 128;
  };
  return exports$1;
}
var exports = {};
var _dewExec = false;
function dew() {
  if (_dewExec) return exports;
  _dewExec = true;
  const base64 = dew$2();
  const ieee754 = dew$1();
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports.Buffer = Buffer3;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports.kMaxLength = K_MAX_LENGTH;
  Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1);
      const proto = {
        foo: function() {
          return 42;
        }
      };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e7) {
      return false;
    }
  }
  Object.defineProperty(Buffer3.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer3.isBuffer(this)) return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer3.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer3.isBuffer(this)) return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer3.prototype);
    return buf;
  }
  function Buffer3(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError('The "string" argument must be of type string. Received type number');
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer3.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer3.from(valueOf, encodingOrOffset, length);
    }
    const b6 = fromObject(value);
    if (b6) return b6;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
  }
  Buffer3.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer3, Uint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer3.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer3.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer3.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer3.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for (let i5 = 0; i5 < length; i5 += 1) {
      buf[i5] = array[i5] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array);
    } else if (length === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer3.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer3.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer3.alloc(+length);
  }
  Buffer3.isBuffer = function isBuffer(b6) {
    return b6 != null && b6._isBuffer === true && b6 !== Buffer3.prototype;
  };
  Buffer3.compare = function compare(a5, b6) {
    if (isInstance(a5, Uint8Array)) a5 = Buffer3.from(a5, a5.offset, a5.byteLength);
    if (isInstance(b6, Uint8Array)) b6 = Buffer3.from(b6, b6.offset, b6.byteLength);
    if (!Buffer3.isBuffer(a5) || !Buffer3.isBuffer(b6)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a5 === b6) return 0;
    let x5 = a5.length;
    let y7 = b6.length;
    for (let i5 = 0, len = Math.min(x5, y7); i5 < len; ++i5) {
      if (a5[i5] !== b6[i5]) {
        x5 = a5[i5];
        y7 = b6[i5];
        break;
      }
    }
    if (x5 < y7) return -1;
    if (y7 < x5) return 1;
    return 0;
  };
  Buffer3.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer3.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer3.alloc(0);
    }
    let i5;
    if (length === void 0) {
      length = 0;
      for (i5 = 0; i5 < list.length; ++i5) {
        length += list[i5].length;
      }
    }
    const buffer2 = Buffer3.allocUnsafe(length);
    let pos = 0;
    for (i5 = 0; i5 < list.length; ++i5) {
      let buf = list[i5];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer3.isBuffer(buf)) buf = Buffer3.from(buf);
          buf.copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(buffer2, buf, pos);
        }
      } else if (!Buffer3.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength(string, encoding) {
    if (Buffer3.isBuffer(string)) {
      return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer3.byteLength = byteLength;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding) encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer3.prototype._isBuffer = true;
  function swap(b6, n6, m7) {
    const i5 = b6[n6];
    b6[n6] = b6[m7];
    b6[m7] = i5;
  }
  Buffer3.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i5 = 0; i5 < len; i5 += 2) {
      swap(this, i5, i5 + 1);
    }
    return this;
  };
  Buffer3.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i5 = 0; i5 < len; i5 += 4) {
      swap(this, i5, i5 + 3);
      swap(this, i5 + 1, i5 + 2);
    }
    return this;
  };
  Buffer3.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i5 = 0; i5 < len; i5 += 8) {
      swap(this, i5, i5 + 7);
      swap(this, i5 + 1, i5 + 6);
      swap(this, i5 + 2, i5 + 5);
      swap(this, i5 + 3, i5 + 4);
    }
    return this;
  };
  Buffer3.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
  Buffer3.prototype.equals = function equals(b6) {
    if (!Buffer3.isBuffer(b6)) throw new TypeError("Argument must be a Buffer");
    if (this === b6) return true;
    return Buffer3.compare(this, b6) === 0;
  };
  Buffer3.prototype.inspect = function inspect() {
    let str = "";
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
  }
  Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer3.from(target, target.offset, target.byteLength);
    }
    if (!Buffer3.isBuffer(target)) {
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x5 = thisEnd - thisStart;
    let y7 = end - start;
    const len = Math.min(x5, y7);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i5 = 0; i5 < len; ++i5) {
      if (thisCopy[i5] !== targetCopy[i5]) {
        x5 = thisCopy[i5];
        y7 = targetCopy[i5];
        break;
      }
    }
    if (x5 < y7) return -1;
    if (y7 < x5) return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0) return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir) return -1;
      else byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1;
    }
    if (typeof val === "string") {
      val = Buffer3.from(val, encoding);
    }
    if (Buffer3.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf, i6) {
      if (indexSize === 1) {
        return buf[i6];
      } else {
        return buf.readUInt16BE(i6 * indexSize);
      }
    }
    let i5;
    if (dir) {
      let foundIndex = -1;
      for (i5 = byteOffset; i5 < arrLength; i5++) {
        if (read2(arr, i5) === read2(val, foundIndex === -1 ? 0 : i5 - foundIndex)) {
          if (foundIndex === -1) foundIndex = i5;
          if (i5 - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1) i5 -= i5 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i5 = byteOffset; i5 >= 0; i5--) {
        let found = true;
        for (let j4 = 0; j4 < valLength; j4++) {
          if (read2(arr, i5 + j4) !== read2(val, j4)) {
            found = false;
            break;
          }
        }
        if (found) return i5;
      }
    }
    return -1;
  }
  Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i5;
    for (i5 = 0; i5 < length; ++i5) {
      const parsed = parseInt(string.substr(i5 * 2, 2), 16);
      if (numberIsNaN(parsed)) return i5;
      buf[offset + i5] = parsed;
    }
    return i5;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer3.prototype.write = function write2(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0) encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    }
    const remaining = this.length - offset;
    if (length === void 0 || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding) encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer3.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i5 = start;
    while (i5 < end) {
      const firstByte = buf[i5];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i5 + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i5 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i5 + 1];
            thirdByte = buf[i5 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i5 + 1];
            thirdByte = buf[i5 + 2];
            fourthByte = buf[i5 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i5 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i5 = 0;
    while (i5 < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i5, i5 += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i5 = start; i5 < end; ++i5) {
      ret += String.fromCharCode(buf[i5] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i5 = start; i5 < end; ++i5) {
      ret += String.fromCharCode(buf[i5]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = "";
    for (let i5 = start; i5 < end; ++i5) {
      out += hexSliceLookupTable[buf[i5]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    for (let i5 = 0; i5 < bytes.length - 1; i5 += 2) {
      res += String.fromCharCode(bytes[i5] + bytes[i5 + 1] * 256);
    }
    return res;
  }
  Buffer3.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer3.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength2, this.length);
    let val = this[offset];
    let mul = 1;
    let i5 = 0;
    while (++i5 < byteLength2 && (mul *= 256)) {
      val += this[offset + i5] * mul;
    }
    return val;
  };
  Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength2, this.length);
    }
    let val = this[offset + --byteLength2];
    let mul = 1;
    while (byteLength2 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength2] * mul;
    }
    return val;
  };
  Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength2, this.length);
    let val = this[offset];
    let mul = 1;
    let i5 = 0;
    while (++i5 < byteLength2 && (mul *= 256)) {
      val += this[offset + i5] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength2, this.length);
    let i5 = byteLength2;
    let mul = 1;
    let val = this[offset + --i5];
    while (i5 > 0 && (mul *= 256)) {
      val += this[offset + --i5] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128)) return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
  });
  Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
  };
  Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
  };
  Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
  };
  Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer3.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
  }
  Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    let mul = 1;
    let i5 = 0;
    this[offset] = value & 255;
    while (++i5 < byteLength2 && (mul *= 256)) {
      this[offset + i5] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    let i5 = byteLength2 - 1;
    let mul = 1;
    this[offset + i5] = value & 255;
    while (--i5 >= 0 && (mul *= 256)) {
      this[offset + i5] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
  }
  Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    let i5 = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i5 < byteLength2 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i5 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i5] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    let i5 = byteLength2 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i5] = value & 255;
    while (--i5 >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i5 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i5] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
    if (value < 0) value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0) value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer3.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    }
    return len;
  };
  Buffer3.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code = val.charCodeAt(0);
        if (encoding === "utf8" && code < 128 || encoding === "latin1") {
          val = code;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) val = 0;
    let i5;
    if (typeof val === "number") {
      for (i5 = start; i5 < end; ++i5) {
        this[i5] = val;
      }
    } else {
      const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
      const len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i5 = 0; i5 < end - start; ++i5) {
        this[i5 + start] = bytes[i5 % len];
      }
    }
    return this;
  };
  const errors = {};
  function E4(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E4("ERR_BUFFER_OUT_OF_BOUNDS", function(name2) {
    if (name2) {
      return `${name2} is outside of buffer bounds`;
    }
    return "Attempt to access memory outside buffer bounds";
  }, RangeError);
  E4("ERR_INVALID_ARG_TYPE", function(name2, actual) {
    return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
  }, TypeError);
  E4("ERR_OUT_OF_RANGE", function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input));
    } else if (typeof input === "bigint") {
      received = String(input);
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received);
      }
      received += "n";
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg;
  }, RangeError);
  function addNumericalSeparator(val) {
    let res = "";
    let i5 = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i5 >= start + 4; i5 -= 3) {
      res = `_${val.slice(i5 - 3, i5)}${res}`;
    }
    return `${val.slice(0, i5)}${res}`;
  }
  function checkBounds(buf, offset, byteLength2) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
      boundsError(offset, buf.length - (byteLength2 + 1));
    }
  }
  function checkIntBI(value, min, max, buf, offset, byteLength2) {
    if (value > max || value < min) {
      const n6 = typeof min === "bigint" ? "n" : "";
      let range;
      {
        if (min === 0 || min === BigInt(0)) {
          range = `>= 0${n6} and < 2${n6} ** ${(byteLength2 + 1) * 8}${n6}`;
        } else {
          range = `>= -(2${n6} ** ${(byteLength2 + 1) * 8 - 1}${n6}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n6}`;
        }
      }
      throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength2);
  }
  function validateNumber(value, name2) {
    if (typeof value !== "number") {
      throw new errors.ERR_INVALID_ARG_TYPE(name2, "number", value);
    }
  }
  function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type);
      throw new errors.ERR_OUT_OF_RANGE("offset", "an integer", value);
    }
    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE("offset", `>= ${0} and <= ${length}`, value);
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2) return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i5 = 0; i5 < length; ++i5) {
      codePoint = string.charCodeAt(i5);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          } else if (i5 + 1 === length) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1) bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0) break;
        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0) break;
        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0) break;
        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i5 = 0; i5 < str.length; ++i5) {
      byteArray.push(str.charCodeAt(i5) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c5, hi, lo;
    const byteArray = [];
    for (let i5 = 0; i5 < str.length; ++i5) {
      if ((units -= 2) < 0) break;
      c5 = str.charCodeAt(i5);
      hi = c5 >> 8;
      lo = c5 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    let i5;
    for (i5 = 0; i5 < length; ++i5) {
      if (i5 + offset >= dst.length || i5 >= src.length) break;
      dst[i5 + offset] = src[i5];
    }
    return i5;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for (let i5 = 0; i5 < 16; ++i5) {
      const i16 = i5 * 16;
      for (let j4 = 0; j4 < 16; ++j4) {
        table[i16 + j4] = alphabet[i5] + alphabet[j4];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
  return exports;
}

// node_modules/@jspm/core/nodelibs/browser/buffer.js
var exports2 = dew();
exports2["Buffer"];
exports2["SlowBuffer"];
exports2["INSPECT_MAX_BYTES"];
exports2["kMaxLength"];
var Buffer2 = exports2.Buffer;
var INSPECT_MAX_BYTES = exports2.INSPECT_MAX_BYTES;
var kMaxLength = exports2.kMaxLength;

// src/core/extras/three.js
var three_exports = {};
__export(three_exports, {
  Vector3: () => Vector3Enhanced
});
__reExport(three_exports, three_star);
import { computeBoundsTree, disposeBoundsTree, acceleratedRaycast } from "three-mesh-bvh";
import * as THREE2 from "three";
import * as three_star from "three";

// src/core/extras/Vector3Enhanced.js
import { Quaternion, MathUtils } from "three";
var Vector3Enhanced = class _Vector3Enhanced {
  constructor(x5 = 0, y7 = 0, z4 = 0) {
    _Vector3Enhanced.prototype.isVector3 = true;
    _Vector3Enhanced.prototype.isVector3Enhanced = true;
    this._x = x5;
    this._y = y7;
    this._z = z4;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  set(x5, y7, z4) {
    if (z4 === void 0) z4 = this._z;
    this._x = x5;
    this._y = y7;
    this._z = z4;
    this._onChangeCallback();
    return this;
  }
  setScalar(scalar) {
    this._x = scalar;
    this._y = scalar;
    this._z = scalar;
    this._onChangeCallback();
    return this;
  }
  setX(x5) {
    this._x = x5;
    this._onChangeCallback();
    return this;
  }
  setY(y7) {
    this._y = y7;
    this._onChangeCallback();
    return this;
  }
  setZ(z4) {
    this._z = z4;
    this._onChangeCallback();
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this._x = value;
        break;
      case 1:
        this._y = value;
        break;
      case 2:
        this._z = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    this._onChangeCallback();
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this._x;
      case 1:
        return this._y;
      case 2:
        return this._z;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z);
  }
  copy(v11) {
    this._x = v11.x;
    this._y = v11.y;
    this._z = v11.z;
    this._onChangeCallback();
    return this;
  }
  add(v11) {
    this._x += v11.x;
    this._y += v11.y;
    this._z += v11.z;
    this._onChangeCallback();
    return this;
  }
  addScalar(s5) {
    this._x += s5;
    this._y += s5;
    this._z += s5;
    this._onChangeCallback();
    return this;
  }
  addVectors(a5, b6) {
    this._x = a5.x + b6.x;
    this._y = a5.y + b6.y;
    this._z = a5.z + b6.z;
    this._onChangeCallback();
    return this;
  }
  addScaledVector(v11, s5) {
    this._x += v11.x * s5;
    this._y += v11.y * s5;
    this._z += v11.z * s5;
    this._onChangeCallback();
    return this;
  }
  sub(v11) {
    this._x -= v11.x;
    this._y -= v11.y;
    this._z -= v11.z;
    this._onChangeCallback();
    return this;
  }
  subScalar(s5) {
    this._x -= s5;
    this._y -= s5;
    this._z -= s5;
    this._onChangeCallback();
    return this;
  }
  subVectors(a5, b6) {
    this._x = a5.x - b6.x;
    this._y = a5.y - b6.y;
    this._z = a5.z - b6.z;
    this._onChangeCallback();
    return this;
  }
  multiply(v11) {
    this._x *= v11.x;
    this._y *= v11.y;
    this._z *= v11.z;
    this._onChangeCallback();
    return this;
  }
  multiplyScalar(scalar) {
    this._x *= scalar;
    this._y *= scalar;
    this._z *= scalar;
    this._onChangeCallback();
    return this;
  }
  multiplyVectors(a5, b6) {
    this._x = a5.x * b6.x;
    this._y = a5.y * b6.y;
    this._z = a5.z * b6.z;
    this._onChangeCallback();
    return this;
  }
  applyEuler(euler) {
    return this.applyQuaternion(_quaternion.setFromEuler(euler));
  }
  applyAxisAngle(axis, angle) {
    return this.applyQuaternion(_quaternion.setFromAxisAngle(axis, angle));
  }
  applyMatrix3(m7) {
    const x5 = this._x, y7 = this._y, z4 = this._z;
    const e7 = m7.elements;
    this._x = e7[0] * x5 + e7[3] * y7 + e7[6] * z4;
    this._y = e7[1] * x5 + e7[4] * y7 + e7[7] * z4;
    this._z = e7[2] * x5 + e7[5] * y7 + e7[8] * z4;
    this._onChangeCallback();
    return this;
  }
  applyNormalMatrix(m7) {
    return this.applyMatrix3(m7).normalize();
  }
  applyMatrix4(m7) {
    const x5 = this._x, y7 = this._y, z4 = this._z;
    const e7 = m7.elements;
    const w5 = 1 / (e7[3] * x5 + e7[7] * y7 + e7[11] * z4 + e7[15]);
    this._x = (e7[0] * x5 + e7[4] * y7 + e7[8] * z4 + e7[12]) * w5;
    this._y = (e7[1] * x5 + e7[5] * y7 + e7[9] * z4 + e7[13]) * w5;
    this._z = (e7[2] * x5 + e7[6] * y7 + e7[10] * z4 + e7[14]) * w5;
    this._onChangeCallback();
    return this;
  }
  applyQuaternion(q6) {
    const vx = this._x, vy = this._y, vz = this._z;
    const qx = q6.x, qy = q6.y, qz = q6.z, qw = q6.w;
    const tx = 2 * (qy * vz - qz * vy);
    const ty = 2 * (qz * vx - qx * vz);
    const tz = 2 * (qx * vy - qy * vx);
    this._x = vx + qw * tx + qy * tz - qz * ty;
    this._y = vy + qw * ty + qz * tx - qx * tz;
    this._z = vz + qw * tz + qx * ty - qy * tx;
    this._onChangeCallback();
    return this;
  }
  project(camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  }
  unproject(camera) {
    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
  }
  transformDirection(m7) {
    const x5 = this._x, y7 = this._y, z4 = this._z;
    const e7 = m7.elements;
    this._x = e7[0] * x5 + e7[4] * y7 + e7[8] * z4;
    this._y = e7[1] * x5 + e7[5] * y7 + e7[9] * z4;
    this._z = e7[2] * x5 + e7[6] * y7 + e7[10] * z4;
    return this.normalize();
  }
  divide(v11) {
    this._x /= v11.x;
    this._y /= v11.y;
    this._z /= v11.z;
    this._onChangeCallback();
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  min(v11) {
    this._x = Math.min(this._x, v11.x);
    this._y = Math.min(this._y, v11.y);
    this._z = Math.min(this._z, v11.z);
    this._onChangeCallback();
    return this;
  }
  max(v11) {
    this._x = Math.max(this._x, v11.x);
    this._y = Math.max(this._y, v11.y);
    this._z = Math.max(this._z, v11.z);
    this._onChangeCallback();
    return this;
  }
  clamp(min, max) {
    this._x = Math.max(min.x, Math.min(max.x, this._x));
    this._y = Math.max(min.y, Math.min(max.y, this._y));
    this._z = Math.max(min.z, Math.min(max.z, this._z));
    this._onChangeCallback();
    return this;
  }
  clampScalar(minVal, maxVal) {
    this._x = Math.max(minVal, Math.min(maxVal, this._x));
    this._y = Math.max(minVal, Math.min(maxVal, this._y));
    this._z = Math.max(minVal, Math.min(maxVal, this._z));
    this._onChangeCallback();
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this._x = Math.floor(this._x);
    this._y = Math.floor(this._y);
    this._z = Math.floor(this._z);
    this._onChangeCallback();
    return this;
  }
  ceil() {
    this._x = Math.ceil(this._x);
    this._y = Math.ceil(this._y);
    this._z = Math.ceil(this._z);
    this._onChangeCallback();
    return this;
  }
  round() {
    this._x = Math.round(this._x);
    this._y = Math.round(this._y);
    this._z = Math.round(this._z);
    this._onChangeCallback();
    return this;
  }
  roundToZero() {
    this._x = Math.trunc(this._x);
    this._y = Math.trunc(this._y);
    this._z = Math.trunc(this._z);
    this._onChangeCallback();
    return this;
  }
  negate() {
    this._x = -this._x;
    this._y = -this._y;
    this._z = -this._z;
    this._onChangeCallback();
    return this;
  }
  dot(v11) {
    return this._x * v11.x + this._y * v11.y + this._z * v11.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z);
  }
  manhattanLength() {
    return Math.abs(this._x) + Math.abs(this._y) + Math.abs(this._z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v11, alpha) {
    this._x += (v11.x - this._x) * alpha;
    this._y += (v11.y - this._y) * alpha;
    this._z += (v11.z - this._z) * alpha;
    this._onChangeCallback();
    return this;
  }
  lerpVectors(v115, v28, alpha) {
    this._x = v115.x + (v28.x - v115.x) * alpha;
    this._y = v115.y + (v28.y - v115.y) * alpha;
    this._z = v115.z + (v28.z - v115.z) * alpha;
    this._onChangeCallback();
    return this;
  }
  cross(v11) {
    return this.crossVectors(this, v11);
  }
  crossVectors(a5, b6) {
    const ax = a5.x, ay = a5.y, az = a5.z;
    const bx = b6.x, by = b6.y, bz = b6.z;
    this._x = ay * bz - az * by;
    this._y = az * bx - ax * bz;
    this._z = ax * by - ay * bx;
    this._onChangeCallback();
    return this;
  }
  projectOnVector(v11) {
    const denominator = v11.lengthSq();
    if (denominator === 0) return this.set(0, 0, 0);
    const scalar = v11.dot(this) / denominator;
    return this.copy(v11).multiplyScalar(scalar);
  }
  projectOnPlane(planeNormal) {
    _vector.copy(this).projectOnVector(planeNormal);
    return this.sub(_vector);
  }
  reflect(normal) {
    return this.sub(_vector.copy(normal).multiplyScalar(2 * this.dot(normal)));
  }
  angleTo(v11) {
    const denominator = Math.sqrt(this.lengthSq() * v11.lengthSq());
    if (denominator === 0) return Math.PI / 2;
    const theta = this.dot(v11) / denominator;
    return Math.acos(MathUtils.clamp(theta, -1, 1));
  }
  distanceTo(v11) {
    return Math.sqrt(this.distanceToSquared(v11));
  }
  distanceToSquared(v11) {
    const dx = this._x - v11.x, dy = this._y - v11.y, dz = this._z - v11.z;
    return dx * dx + dy * dy + dz * dz;
  }
  manhattanDistanceTo(v11) {
    return Math.abs(this._x - v11.x) + Math.abs(this._y - v11.y) + Math.abs(this._z - v11.z);
  }
  setFromSpherical(s5) {
    return this.setFromSphericalCoords(s5.radius, s5.phi, s5.theta);
  }
  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this._x = sinPhiRadius * Math.sin(theta);
    this._y = Math.cos(phi) * radius;
    this._z = sinPhiRadius * Math.cos(theta);
    this._onChangeCallback();
    return this;
  }
  setFromCylindrical(c5) {
    return this.setFromCylindricalCoords(c5.radius, c5.theta, c5.y);
  }
  setFromCylindricalCoords(radius, theta, y7) {
    this._x = radius * Math.sin(theta);
    this._y = y7;
    this._z = radius * Math.cos(theta);
    this._onChangeCallback();
    return this;
  }
  setFromMatrixPosition(m7) {
    const e7 = m7.elements;
    this._x = e7[12];
    this._y = e7[13];
    this._z = e7[14];
    this._onChangeCallback();
    return this;
  }
  setFromMatrixScale(m7) {
    const sx = this.setFromMatrixColumn(m7, 0).length();
    const sy = this.setFromMatrixColumn(m7, 1).length();
    const sz = this.setFromMatrixColumn(m7, 2).length();
    this._x = sx;
    this._y = sy;
    this._z = sz;
    this._onChangeCallback();
    return this;
  }
  setFromMatrixColumn(m7, index) {
    return this.fromArray(m7.elements, index * 4);
  }
  setFromMatrix3Column(m7, index) {
    return this.fromArray(m7.elements, index * 3);
  }
  setFromEuler(e7) {
    this._x = e7._x;
    this._y = e7._y;
    this._z = e7._z;
    this._onChangeCallback();
    return this;
  }
  setFromColor(c5) {
    this._x = c5.r;
    this._y = c5.g;
    this._z = c5.b;
    this._onChangeCallback();
    return this;
  }
  equals(v11) {
    return v11.x === this._x && v11.y === this._y && v11.z === this._z;
  }
  fromArray(array, offset = 0) {
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this._x = attribute.getX(index);
    this._y = attribute.getY(index);
    this._z = attribute.getZ(index);
    this._onChangeCallback();
    return this;
  }
  random() {
    this._x = Math.random();
    this._y = Math.random();
    this._z = Math.random();
    this._onChangeCallback();
    return this;
  }
  randomDirection() {
    const theta = Math.random() * Math.PI * 2;
    const u5 = Math.random() * 2 - 1;
    const c5 = Math.sqrt(1 - u5 * u5);
    this._x = c5 * Math.cos(theta);
    this._y = u5;
    this._z = c5 * Math.sin(theta);
    this._onChangeCallback();
    return this;
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
  }
};
var _vector = /* @__PURE__ */ new Vector3Enhanced();
var _quaternion = /* @__PURE__ */ new Quaternion();

// src/core/extras/three.js
THREE2.BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;
THREE2.BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;
THREE2.Mesh.prototype.raycast = acceleratedRaycast;
THREE2.InstancedMesh.prototype.resize = function(size) {
  const prevSize = this.instanceMatrix.array.length / 16;
  if (size <= prevSize) return;
  const array = new Float32Array(size * 16);
  array.set(this.instanceMatrix.array);
  this.instanceMatrix = new THREE2.InstancedBufferAttribute(array, 16);
  this.instanceMatrix.needsUpdate = true;
};

// src/core/World.js
import EventEmitter2 from "eventemitter3";

// src/core/systems/System.js
import EventEmitter from "eventemitter3";
var System = class extends EventEmitter {
  constructor(world2) {
    super();
    this.world = world2;
  }
  async init() {
  }
  start() {
  }
  preTick() {
  }
  preFixedUpdate(willFixedStep) {
  }
  fixedUpdate(delta) {
  }
  postFixedUpdate() {
  }
  preUpdate(alpha) {
  }
  update(delta) {
  }
  postUpdate() {
  }
  lateUpdate(delta) {
  }
  postLateUpdate() {
  }
  commit() {
  }
  postTick() {
  }
  destroy() {
  }
};

// src/core/systems/Settings.js
var Settings = class extends System {
  constructor(world2) {
    super(world2);
    this.title = null;
    this.desc = null;
    this.model = null;
    this.avatar = null;
    this.public = null;
    this.playerLimit = null;
    this.changes = null;
  }
  deserialize(data) {
    this.title = data.title;
    this.desc = data.desc;
    this.model = data.model;
    this.avatar = data.avatar;
    this.public = data.public;
    this.playerLimit = data.playerLimit;
    this.emit("change", {
      title: { value: this.title },
      desc: { value: this.desc },
      model: { value: this.model },
      avatar: { value: this.avatar },
      public: { value: this.public },
      playerLimit: { value: this.playerLimit }
    });
  }
  serialize() {
    return {
      desc: this.desc,
      title: this.title,
      model: this.model,
      avatar: this.avatar,
      public: this.public,
      playerLimit: this.playerLimit
    };
  }
  preFixedUpdate() {
    if (!this.changes) return;
    this.emit("change", this.changes);
    this.changes = null;
  }
  modify(key, value) {
    if (this[key] === value) return;
    const prev = this[key];
    this[key] = value;
    if (!this.changes) this.changes = {};
    if (!this.changes[key]) this.changes[key] = { prev, value: null };
    this.changes[key].value = value;
  }
  set(key, value, broadcast) {
    this.modify(key, value);
    if (broadcast) {
      this.world.network.send("settingsModified", { key, value });
    }
  }
};

// src/core/systems/Collections.js
var Collections = class extends System {
  constructor(world2) {
    super(world2);
    this.collections = [];
  }
  get(id) {
    return this.collections.find((coll) => coll.id === id);
  }
  deserialize(data) {
    this.collections = data;
  }
  serialize() {
    return this.collections;
  }
};

// src/core/systems/Apps.js
import moment from "moment";
import { isArray, isEqual, isFunction, isNumber } from "lodash-es";

// src/core/nodes/Node.js
import { isBoolean } from "lodash-es";
var _v1 = new Vector3Enhanced();
var _v2 = new Vector3Enhanced();
var _v3 = new Vector3Enhanced();
var _q1 = new three_exports.Quaternion();
var _m1 = new three_exports.Matrix4();
var _m2 = new three_exports.Matrix4();
var _m3 = new three_exports.Matrix4();
var _box3 = new three_exports.Box3();
var _sphere = new three_exports.Sphere();
var defaults = {
  active: true,
  position: [0, 0, 0],
  quaternion: [0, 0, 0, 1],
  scale: [1, 1, 1]
};
var nodeIds = -1;
var EPSILON = 1e-9;
var secure = { allowRef: false };
function getRef(pNode) {
  if (!pNode || !pNode._isRef) return pNode;
  secure.allowRef = true;
  const node = pNode._ref;
  secure.allowRef = false;
  return node;
}
function secureRef(obj = {}, getRef2) {
  const tpl = {
    get _ref() {
      if (!secure.allowRef) return null;
      return getRef2();
    }
  };
  obj._isRef = true;
  Object.defineProperty(obj, "_ref", Object.getOwnPropertyDescriptor(tpl, "_ref"));
  return obj;
}
var Node = class {
  constructor(data = {}) {
    this.id = data.id || `${++nodeIds}`;
    this.name = "node";
    this.parent = null;
    this.children = [];
    this.ctx = null;
    this.position = new Vector3Enhanced();
    this.position.fromArray(data.position || defaults.position);
    this.quaternion = new three_exports.Quaternion();
    this.quaternion.fromArray(data.quaternion || defaults.quaternion);
    this.rotation = new three_exports.Euler().setFromQuaternion(this.quaternion);
    this.rotation.reorder("YXZ");
    this.scale = new Vector3Enhanced();
    this.scale.fromArray(data.scale || defaults.scale);
    this.matrix = new three_exports.Matrix4();
    this.matrixWorld = new three_exports.Matrix4();
    this.position._onChange(() => {
      this.setTransformed();
    });
    this.rotation._onChange(() => {
      this.quaternion.setFromEuler(this.rotation, false);
      this.setTransformed();
    });
    this.quaternion._onChange(() => {
      this.rotation.setFromQuaternion(this.quaternion, void 0, false);
      this.setTransformed();
    });
    this.scale._onChange(() => {
      if (this.scale.x === 0 || this.scale.y === 0 || this.scale.z === 0) {
        return this.scale.set(this.scale.x || EPSILON, this.scale.y || EPSILON, this.scale.z || EPSILON);
      }
      this.setTransformed();
    });
    this._onPointerEnter = data.onPointerEnter;
    this._onPointerLeave = data.onPointerLeave;
    this._onPointerDown = data.onPointerDown;
    this._onPointerUp = data.onPointerUp;
    this._cursor = data.cursor;
    this._active = isBoolean(data.active) ? data.active : defaults.active;
    this.isDirty = false;
    this.isTransformed = true;
    this.mounted = false;
  }
  activate(ctx) {
    if (ctx) this.ctx = ctx;
    if (!this._active) return;
    if (this.mounted) return;
    this.updateTransform();
    this.mounted = true;
    this.mount();
    const children = this.children;
    for (let i5 = 0, l5 = children.length; i5 < l5; i5++) {
      children[i5].activate(ctx);
    }
  }
  deactivate() {
    if (!this.mounted) return;
    const children = this.children;
    for (let i5 = 0, l5 = children.length; i5 < l5; i5++) {
      children[i5].deactivate();
    }
    this.unmount();
    this.isDirty = false;
    this.isTransformed = true;
    this.mounted = false;
  }
  add(node) {
    if (!node) return console.error("no node to add");
    if (node.parent) {
      node.parent.remove(node);
    }
    node.parent = this;
    this.children.push(node);
    if (this.mounted) {
      node.activate(this.ctx);
    }
    return this;
  }
  remove(node) {
    const idx = this.children.indexOf(node);
    if (idx === -1) return;
    node.deactivate();
    node.parent = null;
    this.children.splice(idx, 1);
    return this;
  }
  // detach(node) {
  //   if (node) {
  //     const idx = this.children.indexOf(node)
  //     if (idx === -1) return
  //     this.project()
  //     node.parent = null
  //     this.children.splice(idx, 1)
  //     node.matrix.copy(node.matrixWorld)
  //     node.matrix.decompose(node.position, node.quaternion, node.scale)
  //     node.project()
  //     node.update()
  //   } else {
  //     this.parent?.detach(this)
  //   }
  // }
  setTransformed() {
    if (this.isTransformed) return;
    this.traverse((node) => {
      if (node === this) {
        node.isTransformed = true;
        node.setDirty();
      } else if (node.isDirty) {
        this.ctx.world.stage.dirtyNodes.delete(node);
      } else {
        node.isDirty = true;
      }
    });
  }
  setDirty() {
    if (!this.mounted) return;
    if (this.isDirty) return;
    this.isDirty = true;
    this.ctx.world.stage.dirtyNodes.add(this);
  }
  get active() {
    return this._active;
  }
  set active(value) {
    if (this._active === value) return;
    this._active = value;
    if (!this._active && this.mounted) {
      this.deactivate();
    } else if (this._active && this.parent?.mounted) {
      this.activate(this.parent.ctx);
    } else if (this._active && !this.parent) {
      this.activate(this.ctx);
    }
  }
  clean() {
    if (!this.isDirty) return;
    let didTransform;
    this.traverse((node) => {
      if (node.isTransformed) {
        didTransform = true;
      }
      if (didTransform) {
        node.updateTransform();
      }
      if (node.mounted) {
        node.commit(didTransform);
      }
      node.isDirty = false;
    });
  }
  mount() {
  }
  commit(didTransform) {
  }
  unmount() {
  }
  updateTransform() {
    if (this.isTransformed) {
      this.matrix.compose(this.position, this.quaternion, this.scale);
      this.isTransformed = false;
    }
    if (this.parent) {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    } else {
      this.matrixWorld.copy(this.matrix);
    }
  }
  traverse(callback) {
    callback(this);
    const children = this.children;
    for (let i5 = 0, l5 = children.length; i5 < l5; i5++) {
      children[i5].traverse(callback);
    }
  }
  clone(recursive) {
    return new this.constructor().copy(this, recursive);
  }
  copy(source, recursive) {
    this.id = source.id;
    this.position.copy(source.position);
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this._onPointerEnter = source._onPointerEnter;
    this._onPointerLeave = source._onPointerLeave;
    this._onPointerDown = source._onPointerDown;
    this._onPointerUp = source._onPointerUp;
    this._cursor = source._cursor;
    this._active = source._active;
    if (recursive) {
      for (let i5 = 0; i5 < source.children.length; i5++) {
        const child = source.children[i5];
        this.add(child.clone(recursive));
      }
    }
    return this;
  }
  get(id) {
    if (this.id === id) return this;
    for (let i5 = 0, l5 = this.children.length; i5 < l5; i5++) {
      const found = this.children[i5].get(id);
      if (found) {
        return found;
      }
    }
    return null;
  }
  // todo: getWorldQuaternion etc
  getWorldPosition(vec3 = _v1) {
    this.matrixWorld.decompose(vec3, _q1, _v2);
    return vec3;
  }
  getWorldMatrix(mat = _m1) {
    return mat.copy(this.matrixWorld);
  }
  getStats(recursive, stats) {
    if (!stats) {
      stats = {
        geometries: /* @__PURE__ */ new Set(),
        materials: /* @__PURE__ */ new Set(),
        triangles: 0,
        textureBytes: 0
      };
    }
    this.applyStats(stats);
    if (recursive) {
      for (const child of this.children) {
        child.getStats(recursive, stats);
      }
    }
    return stats;
  }
  applyStats(stats) {
  }
  get onPointerEnter() {
    return this._onPointerEnter;
  }
  set onPointerEnter(value) {
    this._onPointerEnter = value;
  }
  get onPointerLeave() {
    return this._onPointerLeave;
  }
  set onPointerLeave(value) {
    this._onPointerLeave = value;
  }
  get onPointerDown() {
    return this._onPointerDown;
  }
  set onPointerDown(value) {
    this._onPointerDown = value;
  }
  get onPointerUp() {
    return this._onPointerUp;
  }
  set onPointerUp(value) {
    this._onPointerUp = value;
  }
  get cursor() {
    return this._cursor;
  }
  set cursor(value) {
    this._cursor = value;
  }
  getProxy() {
    if (!this.proxy) {
      const self2 = this;
      const proxy = {
        get id() {
          return self2.id;
        },
        set id(value) {
          throw new Error("Setting ID not currently supported");
        },
        get name() {
          return self2.name;
        },
        get position() {
          return self2.position;
        },
        set position(value) {
          throw new Error("Cannot replace node position");
        },
        get quaternion() {
          return self2.quaternion;
        },
        set quaternion(value) {
          throw new Error("Cannot replace node quaternion");
        },
        get rotation() {
          return self2.rotation;
        },
        set rotation(value) {
          throw new Error("Cannot replace node position");
        },
        get scale() {
          return self2.scale;
        },
        set scale(value) {
          throw new Error("Cannot replace node scale");
        },
        get matrixWorld() {
          return self2.matrixWorld;
        },
        get active() {
          return self2.active;
        },
        set active(value) {
          self2.active = value;
        },
        get parent() {
          return self2.parent?.getProxy();
        },
        set parent(value) {
          throw new Error("Cannot set parent directly");
        },
        get children() {
          return self2.children.map((child) => {
            return child.getProxy();
          });
        },
        get(id) {
          const node = self2.get(id);
          return node?.getProxy() || null;
        },
        getWorldMatrix(mat) {
          return self2.getWorldMatrix(mat);
        },
        add(pNode) {
          const node = getRef(pNode);
          self2.add(node);
          return this;
        },
        remove(pNode) {
          const node = getRef(pNode);
          self2.remove(node);
          return this;
        },
        traverse(callback) {
          self2.traverse((node) => {
            callback(node.getProxy());
          });
        },
        // detach(node) {
        //   self.detach(node)
        // },
        clone(recursive) {
          const node = self2.clone(recursive);
          return node.getProxy();
        },
        clean() {
          self2.clean();
        },
        get _ref() {
          if (!secure.allowRef) return null;
          return self2;
        },
        get _isRef() {
          return true;
        },
        get onPointerEnter() {
          return self2.onPointerEnter;
        },
        set onPointerEnter(value) {
          self2.onPointerEnter = value;
        },
        get onPointerLeave() {
          return self2.onPointerLeave;
        },
        set onPointerLeave(value) {
          self2.onPointerLeave = value;
        },
        get onPointerDown() {
          return self2.onPointerDown;
        },
        set onPointerDown(value) {
          self2.onPointerDown = value;
        },
        get onPointerUp() {
          return self2.onPointerUp;
        },
        set onPointerUp(value) {
          self2.onPointerUp = value;
        },
        get cursor() {
          return self2.cursor;
        },
        set cursor(value) {
          self2.cursor = value;
        }
      };
      this.proxy = proxy;
    }
    return this.proxy;
  }
};

// src/core/extras/Layers.js
var n = 0;
var Groups = {};
var Masks = {};
var Layers = {};
function ensure(group) {
  if (Groups[group] === void 0) {
    Groups[group] = 1 << n;
    Masks[group] = 0;
    n++;
  }
}
function add(group, hits) {
  ensure(group);
  for (const otherGroup of hits) {
    if (!otherGroup) continue;
    ensure(otherGroup);
    Masks[group] |= Groups[otherGroup];
  }
}
var playerCollision = (process_exports?.env.PUBLIC_PLAYER_COLLISION || typeof env === "object" && env.PUBLIC_PLAYER_COLLISION) === "true";
add("camera", ["environment"]);
add("player", ["environment", "prop", playerCollision ? "player" : null]);
add("environment", ["camera", "player", "environment", "prop", "tool"]);
add("prop", ["environment", "prop"]);
add("tool", ["environment", "prop"]);
for (const key in Groups) {
  Layers[key] = {
    group: Groups[key],
    mask: Masks[key]
  };
}

// src/core/extras/ControlPriorities.js
var ControlPriorities = {
  PLAYER: 0,
  ENTITY: 1,
  APP: 2,
  BUILDER: 3,
  ACTION: 4,
  CORE_UI: 5,
  POINTER: 6
};

// src/core/extras/warn.js
var warned = /* @__PURE__ */ new Set();
function warn(str) {
  if (warned.has(str)) return;
  console.warn(str);
  warned.add(str);
}

// src/core/systems/Apps.js
var internalEvents = [
  "fixedUpdate",
  "updated",
  "lateUpdate",
  "destroy",
  "enter",
  "leave",
  "chat",
  "command",
  "health"
];
var Apps = class extends System {
  constructor(world2) {
    super(world2);
    this.initWorldHooks();
    this.initAppHooks();
  }
  initWorldHooks() {
    const self2 = this;
    const world2 = this.world;
    const allowLoaders = ["avatar", "model"];
    this.worldGetters = {
      networkId(entity) {
        return world2.network.id;
      },
      isServer(entity) {
        return world2.network.isServer;
      },
      isClient(entity) {
        return world2.network.isClient;
      }
    };
    this.worldSetters = {
      // ...
    };
    this.worldMethods = {
      add(entity, pNode) {
        const node = getRef(pNode);
        if (!node) return;
        if (node.parent) {
          node.parent.remove(node);
        }
        entity.worldNodes.add(node);
        node.activate({ world: world2, entity });
      },
      remove(entity, pNode) {
        const node = getRef(pNode);
        if (!node) return;
        if (node.parent) return;
        if (!entity.worldNodes.has(node)) return;
        entity.worldNodes.delete(node);
        node.deactivate();
      },
      attach(entity, pNode) {
        const node = getRef(pNode);
        if (!node) return;
        const parent = node.parent;
        if (!parent) return;
        const finalMatrix = new three_exports.Matrix4();
        finalMatrix.copy(node.matrix);
        let currentParent = node.parent;
        while (currentParent) {
          finalMatrix.premultiply(currentParent.matrix);
          currentParent = currentParent.parent;
        }
        parent.remove(node);
        finalMatrix.decompose(node.position, node.quaternion, node.scale);
        node.activate({ world: world2, entity });
        entity.worldNodes.add(node);
      },
      on(entity, name2, callback) {
        entity.onWorldEvent(name2, callback);
      },
      off(entity, name2, callback) {
        entity.offWorldEvent(name2, callback);
      },
      emit(entity, name2, data) {
        if (internalEvents.includes(name2)) {
          return console.error(`apps cannot emit internal events (${name2})`);
        }
        warn("world.emit() is deprecated, use app.emit() instead");
        world2.events.emit(name2, data);
      },
      getTime(entity) {
        return world2.network.getTime();
      },
      getTimestamp(entity, format3) {
        if (!format3) return moment().toISOString();
        return moment().format(format3);
      },
      chat(entity, msg, broadcast) {
        if (!msg) return;
        world2.chat.add(msg, broadcast);
      },
      getPlayer(entity, playerId) {
        return entity.getPlayerProxy(playerId);
      },
      getPlayers(entity) {
        const players = [];
        world2.entities.players.forEach((player) => {
          players.push(entity.getPlayerProxy(player.data.id));
        });
        return players;
      },
      createLayerMask(entity, ...groups3) {
        let mask = 0;
        for (const group of groups3) {
          if (!Layers[group]) throw new Error(`[createLayerMask] invalid group: ${group}`);
          mask |= Layers[group].group;
        }
        return mask;
      },
      raycast(entity, origin, direction, maxDistance, layerMask) {
        if (!origin?.isVector3) throw new Error("[raycast] origin must be Vector3");
        if (!direction?.isVector3) throw new Error("[raycast] direction must be Vector3");
        if (maxDistance !== void 0 && maxDistance !== null && !isNumber(maxDistance)) {
          throw new Error("[raycast] maxDistance must be number");
        }
        if (layerMask !== void 0 && layerMask !== null && !isNumber(layerMask)) {
          throw new Error("[raycast] layerMask must be number");
        }
        const hit = world2.physics.raycast(origin, direction, maxDistance, layerMask);
        if (!hit) return null;
        if (!self2.raycastHit) {
          self2.raycastHit = {
            point: new Vector3Enhanced(),
            normal: new Vector3Enhanced(),
            distance: 0,
            tag: null,
            playerId: null
          };
        }
        self2.raycastHit.point.copy(hit.point);
        self2.raycastHit.normal.copy(hit.normal);
        self2.raycastHit.distance = hit.distance;
        self2.raycastHit.tag = hit.handle?.tag;
        self2.raycastHit.playerId = hit.handle?.playerId;
        return self2.raycastHit;
      },
      overlapSphere(entity, radius, origin, layerMask) {
        const hits = world2.physics.overlapSphere(radius, origin, layerMask);
        return hits.map((hit) => {
          return hit.proxy;
        });
      },
      get(entity, key) {
        return world2.storage?.get(key);
      },
      set(entity, key, value) {
        world2.storage?.set(key, value);
      },
      open(entity, url, newWindow = false) {
        if (!url) {
          console.error("[world.open] URL is required");
          return;
        }
        if (world2.network.isClient) {
          try {
            const resolvedUrl = world2.resolveURL(url);
            setTimeout(() => {
              if (newWindow) {
                window.open(resolvedUrl, "_blank");
              } else {
                window.location.href = resolvedUrl;
              }
            }, 0);
            console.log(`[world.open] Redirecting to: ${resolvedUrl} ${newWindow ? "(new window)" : ""}`);
          } catch (e7) {
            console.error("[world.open] Failed to open URL:", e7);
          }
        } else {
          console.warn("[world.open] URL redirection only works on client side");
        }
      },
      load(entity, type, url) {
        return new Promise(async (resolve3, reject) => {
          const hook = entity.getDeadHook();
          try {
            if (!allowLoaders.includes(type)) {
              return reject(new Error(`cannot load type: ${type}`));
            }
            let glb = world2.loader.get(type, url);
            if (!glb) glb = await world2.loader.load(type, url);
            if (hook.dead) return;
            const root = glb.toNodes();
            resolve3(type === "avatar" ? root.children[0] : root);
          } catch (err) {
            if (hook.dead) return;
            reject(err);
          }
        });
      }
    };
  }
  initAppHooks() {
    const world2 = this.world;
    this.appGetters = {
      instanceId(entity) {
        return entity.data.id;
      },
      version(entity) {
        return entity.blueprint.version;
      },
      modelUrl(entity) {
        return entity.blueprint.model;
      },
      state(entity) {
        return entity.data.state;
      },
      props(entity) {
        return entity.blueprint.props;
      },
      config(entity) {
        return entity.blueprint.props;
      },
      keepActive(entity) {
        return entity.keepActive;
      }
    };
    this.appSetters = {
      state(entity, value) {
        entity.data.state = value;
      },
      keepActive(entity, value) {
        entity.keepActive = value;
      }
    };
    this.appMethods = {
      on(entity, name2, callback) {
        entity.on(name2, callback);
      },
      off(entity, name2, callback) {
        entity.off(name2, callback);
      },
      send(entity, name2, data, ignoreSocketId) {
        if (internalEvents.includes(name2)) {
          return console.error(`apps cannot send internal events (${name2})`);
        }
        const event = [entity.data.id, entity.blueprint.version, name2, data];
        world2.network.send("entityEvent", event, ignoreSocketId);
      },
      sendTo(entity, playerId, name2, data) {
        if (internalEvents.includes(name2)) {
          return console.error(`apps cannot send internal events (${name2})`);
        }
        if (!world2.network.isServer) {
          throw new Error("sendTo can only be called on the server");
        }
        const player = world2.entities.get(playerId);
        if (!player) return;
        const event = [entity.data.id, entity.blueprint.version, name2, data];
        world2.network.sendTo(playerId, "entityEvent", event);
      },
      emit(entity, name2, data) {
        if (internalEvents.includes(name2)) {
          return console.error(`apps cannot emit internal events (${name2})`);
        }
        world2.events.emit(name2, data);
      },
      create(entity, name2, data) {
        const node = entity.createNode(name2, data);
        return node.getProxy();
      },
      control(entity, options) {
        entity.control?.release();
        entity.control = world2.controls.bind({
          ...options,
          priority: ControlPriorities.APP,
          object: entity
        });
        return entity.control;
      },
      configure(entity, fnOrArray) {
        if (isArray(fnOrArray)) {
          entity.fields = fnOrArray;
        } else if (isFunction(fnOrArray)) {
          entity.fields = fnOrArray();
        }
        if (!isArray(entity.fields)) {
          entity.fields = [];
        }
        const props = entity.blueprint.props;
        for (const field of entity.fields) {
          if (field.initial !== void 0 && props[field.key] === void 0) {
            props[field.key] = field.initial;
          }
        }
        entity.onFields?.(entity.fields);
      }
    };
  }
  inject({ world: world2, app }) {
    if (world2) {
      for (const key in world2) {
        const value = world2[key];
        const isFunction7 = typeof value === "function";
        if (isFunction7) {
          this.worldMethods[key] = value;
          continue;
        }
        if (value.get) {
          this.worldGetters[key] = value.get;
        }
        if (value.set) {
          this.worldSetters[key] = value.set;
        }
      }
    }
    if (app) {
      for (const key in app) {
        const value = app[key];
        const isFunction7 = typeof value === "function";
        if (isFunction7) {
          this.appMethods[key] = value;
          continue;
        }
        if (value.get) {
          this.appGetters[key] = value.get;
        }
        if (value.set) {
          this.appSetters[key] = value.set;
        }
      }
    }
  }
};

// src/core/systems/Anchors.js
var Anchors = class extends System {
  constructor(world2) {
    super(world2);
    this.matrices = /* @__PURE__ */ new Map();
  }
  get(id) {
    return this.matrices.get(id);
  }
  add(id, matrix) {
    this.matrices.set(id, matrix);
  }
  remove(id) {
    this.matrices.delete(id);
  }
};

// src/core/systems/Events.js
import { isEqual as isEqual2, merge } from "lodash-es";
var Events = class extends System {
  constructor(world2) {
    super(world2);
    this.listeners = {};
  }
  on(name2, callback) {
    if (!this.listeners[name2]) {
      this.listeners[name2] = /* @__PURE__ */ new Set();
    }
    this.listeners[name2].add(callback);
  }
  off(name2, callback) {
    if (!this.listeners[name2]) return;
    this.listeners[name2].delete(callback);
  }
  emit(name2, a1, a22) {
    if (!this.listeners[name2]) return;
    for (const callback of this.listeners[name2]) {
      try {
        callback(a1, a22);
      } catch (err) {
        console.error(err);
      }
    }
  }
};

// src/core/systems/Chat.js
var CHAT_MAX_MESSAGES = 50;
var Chat = class extends System {
  constructor(world2) {
    super(world2);
    this.msgs = [];
    this.listeners = /* @__PURE__ */ new Set();
  }
  add(msg, broadcast) {
    this.msgs = [...this.msgs, msg];
    if (this.msgs.length > CHAT_MAX_MESSAGES) {
      this.msgs.shift();
    }
    for (const callback of this.listeners) {
      callback(this.msgs);
    }
    if (msg.fromId) {
      const player = this.world.entities.getPlayer(msg.fromId);
      player?.chat(msg.body);
    }
    const readOnly = Object.freeze({ ...msg });
    this.world.events.emit("chat", readOnly);
    if (broadcast) {
      this.world.network.send("chatAdded", msg);
    }
  }
  command(text) {
    if (this.world.network.isServer) return;
    const playerId = this.world.network.id;
    const args = text.slice(1).split(" ").map((str) => str.trim()).filter((str) => !!str);
    const isAdminCommand = args[0] === "admin";
    if (args[0] === "stats") {
      this.world.prefs.setStats(!this.world.prefs.stats);
    }
    if (!isAdminCommand) {
      this.world.events.emit("command", { playerId, args });
    }
    this.world.network.send("command", args);
  }
  clear(broadcast) {
    this.msgs = [];
    for (const callback of this.listeners) {
      callback(this.msgs);
    }
    if (broadcast) {
      this.world.network.send("chatCleared");
    }
  }
  serialize() {
    return this.msgs;
  }
  deserialize(msgs) {
    this.msgs = msgs;
    for (const callback of this.listeners) {
      callback(msgs);
    }
  }
  subscribe(callback) {
    this.listeners.add(callback);
    callback(this.msgs);
    return () => {
      this.listeners.delete(callback);
    };
  }
};

// src/core/systems/Blueprints.js
import { isEqual as isEqual3, merge as merge2 } from "lodash-es";
var Blueprints = class extends System {
  constructor(world2) {
    super(world2);
    this.items = /* @__PURE__ */ new Map();
  }
  get(id) {
    return this.items.get(id);
  }
  add(data, local) {
    this.items.set(data.id, data);
    if (local) {
      this.world.network.send("blueprintAdded", data);
    }
  }
  modify(data) {
    const blueprint = this.items.get(data.id);
    const modified = {
      ...blueprint,
      ...data
    };
    const changed = !isEqual3(blueprint, modified);
    if (!changed) return;
    this.items.set(blueprint.id, modified);
    for (const [_4, entity] of this.world.entities.items) {
      if (entity.data.blueprint === blueprint.id) {
        entity.data.state = {};
        entity.build();
      }
    }
    this.emit("modify", modified);
  }
  serialize() {
    const datas = [];
    this.items.forEach((data) => {
      datas.push(data);
    });
    return datas;
  }
  deserialize(datas) {
    for (const data of datas) {
      this.add(data);
    }
  }
};

// src/core/entities/App.js
import { isArray as isArray7, isFunction as isFunction6, isNumber as isNumber18, isString as isString15 } from "lodash-es";
import moment2 from "moment";

// src/core/entities/Entity.js
var Entity = class {
  constructor(world2, data, local) {
    this.world = world2;
    this.data = data;
    if (local) {
      this.world.network.send("entityAdded", data);
    }
  }
  modify(data) {
  }
  onEvent(version4, name2, data, networkId) {
  }
  serialize() {
    return this.data;
  }
  destroy(local) {
  }
};

// src/core/nodes/index.js
var nodes_exports = {};
__export(nodes_exports, {
  action: () => Action,
  anchor: () => Anchor,
  audio: () => Audio,
  avatar: () => Avatar,
  collider: () => Collider,
  controller: () => Controller,
  group: () => Group,
  image: () => Image2,
  joint: () => Joint,
  lod: () => LOD,
  mesh: () => Mesh2,
  nametag: () => Nametag,
  particles: () => Particles,
  rigidbody: () => RigidBody,
  skinnedmesh: () => SkinnedMesh,
  sky: () => Sky,
  snap: () => Snap,
  ui: () => UI,
  uiimage: () => UIImage,
  uitext: () => UIText,
  uiview: () => UIView,
  video: () => Video
});

// src/core/nodes/Group.js
var Group = class extends Node {
  constructor(data = {}) {
    super(data);
    this.name = "group";
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    return this;
  }
  getProxy() {
    if (!this.proxy) {
      let proxy = {
        // ...
      };
      proxy = Object.defineProperties(proxy, Object.getOwnPropertyDescriptors(super.getProxy()));
      this.proxy = proxy;
    }
    return this.proxy;
  }
};

// src/core/nodes/Mesh.js
import { isBoolean as isBoolean2, isNumber as isNumber2 } from "lodash-es";

// src/core/extras/getTrianglesFromGeometry.js
function getTrianglesFromGeometry(geometry) {
  if (!geometry) return 0;
  return geometry.index !== null ? geometry.index.count / 3 : geometry.attributes.position.count / 3;
}

// src/core/extras/getTextureBytesFromMaterial.js
var slots = [
  "alphaMap",
  "aoMap",
  "bumpMap",
  "displacementMap",
  "emissiveMap",
  "envMap",
  "lightMap",
  "map",
  "metalnessMap",
  "normalMap",
  "roughnessMap"
];
function getTextureBytesFromMaterial(material2) {
  let bytes = 0;
  if (material2) {
    const checked = /* @__PURE__ */ new Set();
    for (const slot of slots) {
      const texture = material2[slot];
      if (texture && texture.image && !checked.has(texture.uuid)) {
        checked.add(texture.uuid);
        bytes += texture.image.width * texture.image.height * 4;
      }
    }
  }
  return bytes;
}

// src/core/nodes/Mesh.js
var _v12 = new Vector3Enhanced();
var _v22 = new Vector3Enhanced();
var defaults2 = {
  type: "box",
  width: 1,
  height: 1,
  depth: 1,
  radius: 0.5,
  geometry: null,
  material: null,
  linked: true,
  castShadow: true,
  receiveShadow: true,
  visible: true
  // DEPRECATED: use Node.active
};
var types = ["box", "sphere", "geometry"];
var boxes = {};
var getBox = (width, height, depth) => {
  const key = `${width},${height},${depth}`;
  if (!boxes[key]) {
    boxes[key] = new three_exports.BoxGeometry(width, height, depth);
  }
  return boxes[key];
};
var spheres = {};
var getSphere = (radius) => {
  const key = radius;
  if (!spheres[key]) {
    spheres[key] = new three_exports.SphereGeometry(radius, 16, 12);
  }
  return spheres[key];
};
var Mesh2 = class extends Node {
  constructor(data = {}) {
    super(data);
    this.name = "mesh";
    this.type = data.type;
    this.width = data.width;
    this.height = data.height;
    this.depth = data.depth;
    this.radius = data.radius;
    this.geometry = data.geometry;
    this.material = data.material;
    this.linked = data.linked;
    this.castShadow = data.castShadow;
    this.receiveShadow = data.receiveShadow;
    this.visible = data.visible;
  }
  mount() {
    this.needsRebuild = false;
    if (!this._geometry) return;
    if (!this._visible) return;
    let geometry;
    if (this._type === "box") {
      geometry = getBox(this._width, this._height, this._depth);
    } else if (this._type === "sphere") {
      geometry = getSphere(this._radius);
    } else if (this._type === "geometry") {
      geometry = this._geometry;
    }
    this.handle = this.ctx.world.stage.insert({
      geometry,
      material: this._material,
      linked: this._linked,
      castShadow: this._castShadow,
      receiveShadow: this._receiveShadow,
      matrix: this.matrixWorld,
      node: this
    });
  }
  commit(didMove) {
    if (this.needsRebuild) {
      this.unmount();
      this.mount();
      return;
    }
    if (didMove) {
      this.handle?.move(this.matrixWorld);
    }
  }
  unmount() {
    this.handle?.destroy();
    this.handle = null;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this._type = source._type;
    this._width = source._width;
    this._height = source._height;
    this._depth = source._depth;
    this._radius = source._radius;
    this._geometry = source._geometry;
    this._material = source._material;
    this._linked = source._linked;
    this._castShadow = source._castShadow;
    this._receiveShadow = source._receiveShadow;
    this._visible = source._visible;
    return this;
  }
  applyStats(stats) {
    if (this._geometry && !stats.geometries.has(this._geometry.uuid)) {
      stats.geometries.add(this._geometry.uuid);
      stats.triangles += getTrianglesFromGeometry(this._geometry);
    }
    if (this._material && !stats.materials.has(this._material.uuid)) {
      stats.materials.add(this._material.uuid);
      stats.textureBytes += getTextureBytesFromMaterial(this._material);
    }
  }
  get type() {
    return this._type;
  }
  set type(value = defaults2.type) {
    if (!isType(value)) {
      throw new Error("[mesh] type invalid");
    }
    if (this._type === value) return;
    this._type = value;
    if (this.handle) {
      this.needsRebuild = true;
      this.setDirty();
    }
  }
  get width() {
    return this._width;
  }
  set width(value = defaults2.width) {
    if (!isNumber2(value)) {
      throw new Error("[mesh] width not a number");
    }
    if (this._width === value) return;
    this._width = value;
    if (this.handle && this._type === "box") {
      this.needsRebuild = true;
      this.setDirty();
    }
  }
  get height() {
    return this._height;
  }
  set height(value = defaults2.height) {
    if (!isNumber2(value)) {
      throw new Error("[mesh] height not a number");
    }
    if (this._height === value) return;
    this._height = value;
    if (this.handle && this._type === "box") {
      this.needsRebuild = true;
      this.setDirty();
    }
  }
  get depth() {
    return this._depth;
  }
  set depth(value = defaults2.depth) {
    if (!isNumber2(value)) {
      throw new Error("[mesh] depth not a number");
    }
    if (this._depth === value) return;
    this._depth = value;
    if (this.handle && this._type === "box") {
      this.needsRebuild = true;
      this.setDirty();
    }
  }
  setSize(width, height, depth) {
    this.width = width;
    this.height = height;
    this.depth = depth;
  }
  get radius() {
    return this._radius;
  }
  set radius(value = defaults2.radius) {
    if (!isNumber2(value)) {
      throw new Error("[mesh] radius not a number");
    }
    if (this._radius === value) return;
    this._radius = value;
    if (this.handle && this._type === "sphere") {
      this.needsRebuild = true;
      this.setDirty();
    }
  }
  get geometry() {
    return secureRef({}, () => this._geometry);
  }
  set geometry(value = defaults2.geometry) {
    if (value && !value.isBufferGeometry) {
      throw new Error("[mesh] geometry invalid");
    }
    if (this._geometry === value) return;
    this._geometry = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get material() {
    return this.handle?.material;
  }
  set material(value = defaults2.material) {
    if (value && !value.isMaterial) {
      throw new Error("[mesh] material invalid");
    }
    if (this._material === value) return;
    this._material = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get linked() {
    return this._linked;
  }
  set linked(value = defaults2.linked) {
    if (!isBoolean2(value)) {
      throw new Error("[mesh] linked not a boolean");
    }
    if (this._linked === value) return;
    this._linked = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get castShadow() {
    return this._castShadow;
  }
  set castShadow(value = defaults2.castShadow) {
    if (!isBoolean2(value)) {
      throw new Error("[mesh] castShadow not a boolean");
    }
    if (this._castShadow === value) return;
    this._castShadow = value;
    if (this.handle) {
      this.needsRebuild = true;
      this.setDirty();
    }
  }
  get receiveShadow() {
    return this._receiveShadow;
  }
  set receiveShadow(value = defaults2.receiveShadow) {
    if (!isBoolean2(value)) {
      throw new Error("[mesh] receiveShadow not a boolean");
    }
    if (this._receiveShadow === value) return;
    this._receiveShadow = value;
    if (this.handle) {
      this.needsRebuild = true;
      this.setDirty();
    }
  }
  get visible() {
    return this._visible;
  }
  set visible(value = defaults2.visible) {
    if (!isBoolean2(value)) {
      throw new Error("[mesh] visible not a boolean");
    }
    if (this._visible === value) return;
    this._visible = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  getProxy() {
    if (!this.proxy) {
      const self2 = this;
      let proxy = {
        get type() {
          return self2.type;
        },
        set type(value) {
          self2.type = value;
        },
        get width() {
          return self2.width;
        },
        set width(value) {
          self2.width = value;
        },
        get height() {
          return self2.height;
        },
        set height(value) {
          self2.height = value;
        },
        get depth() {
          return self2.depth;
        },
        set depth(value) {
          self2.depth = value;
        },
        setSize(width, height, depth) {
          self2.setSize(width, height, depth);
        },
        get radius() {
          return self2.radius;
        },
        set radius(value) {
          self2.radius = value;
        },
        get geometry() {
          return self2.geometry;
        },
        set geometry(value) {
          self2.geometry = value;
        },
        get material() {
          return self2.material;
        },
        set material(value) {
          throw new Error("[mesh] set material not supported");
        },
        get linked() {
          return self2.linked;
        },
        set linked(value) {
          self2.linked = value;
        },
        get castShadow() {
          return self2.castShadow;
        },
        set castShadow(value) {
          self2.castShadow = value;
        },
        get receiveShadow() {
          return self2.receiveShadow;
        },
        set receiveShadow(value) {
          self2.receiveShadow = value;
        },
        get visible() {
          return self2.visible;
        },
        set visible(value) {
          self2.visible = value;
        }
      };
      proxy = Object.defineProperties(proxy, Object.getOwnPropertyDescriptors(super.getProxy()));
      this.proxy = proxy;
    }
    return this.proxy;
  }
};
function isType(value) {
  return types.includes(value);
}

// src/core/nodes/SkinnedMesh.js
import * as SkeletonUtils from "three/examples/jsm/utils/SkeletonUtils.js";
import { isBoolean as isBoolean3 } from "lodash-es";
var defaults3 = {
  object3d: null,
  animations: [],
  castShadow: true,
  receiveShadow: true
};
var m1 = new three_exports.Matrix4();
var defaultStopOpts = { fade: 0.15 };
var SkinnedMesh = class extends Node {
  constructor(data = {}) {
    super(data);
    this.name = "skinnedmesh";
    this._object3d = data.object3d;
    this._animations = data.animations;
    this.castShadow = data.castShadow;
    this.receiveShadow = data.receiveShadow;
    this.clips = {};
    this.actions = {};
    this.bones = null;
    this.animNames = [];
  }
  mount() {
    this.obj = SkeletonUtils.clone(this._object3d);
    this.obj.matrixWorld.copy(this.matrixWorld);
    this.obj.matrixAutoUpdate = false;
    this.obj.matrixWorldAutoUpdate = false;
    this.obj.traverse((n6) => {
      if (n6.isMesh) {
        n6.castShadow = this._castShadow;
        n6.receiveShadow = this._receiveShadow;
      }
    });
    this.ctx.world.stage.scene.add(this.obj);
    for (const clip of this._animations) {
      this.clips[clip.name] = clip;
      this.animNames.push(clip.name);
    }
    this.needsRebuild = false;
  }
  commit(didMove) {
    if (this.needsRebuild) {
      this.unmount();
      this.mount();
    }
    if (didMove) {
      if (this.obj) {
        this.obj.matrixWorld.copy(this.matrixWorld);
      }
    }
  }
  unmount() {
    if (this.obj) {
      if (this.mixer) {
        this.mixer.stopAllAction();
        this.mixer.uncacheRoot(this.obj);
        this.mixer = null;
        this.ctx.world.setHot(this, false);
        this.clips = {};
        this.actions = {};
      }
      this.ctx.world.stage.scene.remove(this.obj);
      this.obj = null;
      this.bones = null;
      this.animNames = [];
    }
  }
  update(delta) {
    this.mixer?.update(delta);
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this._object3d = source._object3d;
    this._animations = source._animations;
    this._castShadow = source._castShadow;
    this._receiveShadow = source._receiveShadow;
    return this;
  }
  get anims() {
    return this.animNames.slice();
  }
  get castShadow() {
    return this._castShadow;
  }
  set castShadow(value = defaults3.castShadow) {
    if (!isBoolean3(value)) {
      throw new Error("[skinnedmesh] castShadow not a boolean");
    }
    if (this._castShadow === value) return;
    this._castShadow = value;
    if (this.handle) {
      this.needsRebuild = true;
      this.setDirty();
    }
  }
  get receiveShadow() {
    return this._receiveShadow;
  }
  set receiveShadow(value = defaults3.receiveShadow) {
    if (!isBoolean3(value)) {
      throw new Error("[skinnedmesh] receiveShadow not a boolean");
    }
    if (this._receiveShadow === value) return;
    this._receiveShadow = value;
    if (this.handle) {
      this.needsRebuild = true;
      this.setDirty();
    }
  }
  play({ name: name2, fade = 0.15, speed, loop = true }) {
    if (!this.mixer) {
      this.mixer = new three_exports.AnimationMixer(this.obj);
      this.ctx.world.setHot(this, true);
    }
    if (this.action?._clip.name === name2) {
      return;
    }
    if (this.action) {
      this.action.fadeOut(fade);
    }
    this.action = this.actions[name2];
    if (!this.action) {
      const clip = this.clips[name2];
      if (!clip) return console.warn(`[skinnedmesh] animation not found: ${name2}`);
      this.action = this.mixer.clipAction(clip);
      this.actions[name2] = this.action;
    }
    if (speed !== void 0) this.action.timeScale = speed;
    this.action.clampWhenFinished = !loop;
    this.action.setLoop(loop ? three_exports.LoopRepeat : three_exports.LoopOnce);
    this.action.reset().fadeIn(fade).play();
  }
  stop(opts = defaultStopOpts) {
    if (!this.action) return;
    this.action.fadeOut(opts.fade);
    this.action = null;
  }
  getBoneTransform(name2) {
    if (!this.obj) return null;
    if (!this.bones) {
      this.bones = {};
      this.obj.traverse((child) => {
        if (child.isBone) this.bones[child.name] = child;
      });
    }
    const bone = this.bones[name2];
    if (!bone) {
      console.warn(`[skinnedmesh] bone not found: ${name2}`);
      return null;
    }
    bone.updateMatrixWorld(true);
    return m1.copy(bone.matrixWorld);
  }
  getProxy() {
    var self2 = this;
    if (!this.proxy) {
      let proxy = {
        get anims() {
          return self2.anims;
        },
        get castShadow() {
          return self2.castShadow;
        },
        set castShadow(value) {
          self2.castShadow = value;
        },
        get receiveShadow() {
          return self2.receiveShadow;
        },
        set receiveShadow(value) {
          self2.receiveShadow = value;
        },
        play(opts) {
          self2.play(opts);
        },
        stop(opts) {
          self2.stop(opts);
        },
        getBoneTransform(name2) {
          return self2.getBoneTransform(name2);
        }
      };
      proxy = Object.defineProperties(proxy, Object.getOwnPropertyDescriptors(super.getProxy()));
      this.proxy = proxy;
    }
    return this.proxy;
  }
};

// src/core/nodes/LOD.js
var v0 = new Vector3Enhanced();
var v1 = new Vector3Enhanced();
var LOD = class extends Node {
  constructor(data = {}) {
    super(data);
    this.name = "lod";
    this.lods = [];
  }
  insert(node, maxDistance) {
    this.lods.push({ node, maxDistance });
    this.lods.sort((a5, b6) => a5.maxDistance - b6.maxDistance);
    node.active = false;
    this.add(node);
  }
  mount() {
    this.ctx.world.lods?.register(this);
    this.check();
  }
  check() {
    if (this.prevLod) {
      this.prevLod.node.active = false;
      this.prevLod = null;
    }
    const cameraPos = v0.setFromMatrixPosition(this.ctx.world.camera.matrixWorld);
    const itemPos = v1.setFromMatrixPosition(this.matrixWorld);
    const distance = cameraPos.distanceTo(itemPos);
    const lod = this.lods.find((lod2) => distance <= lod2.maxDistance);
    if (this.lod === lod) return;
    if (lod) {
      lod.node.active = true;
    }
    if (this.lod) {
      this.prevLod = this.lod;
    }
    this.lod = lod;
  }
  unmount() {
    this.ctx.world.lods?.unregister(this);
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.lods = source.lods.map((lod) => {
      const node = this.children.find((node2) => node2.id === lod.node.id);
      node.active = false;
      const maxDistance = lod.maxDistance;
      return {
        node,
        maxDistance
      };
    });
    return this;
  }
  getProxy() {
    if (!this.proxy) {
      const self2 = this;
      let proxy = {
        insert(pNode, maxDistance) {
          const node = getRef(pNode);
          self2.insert(node, maxDistance);
          return this;
        }
      };
      proxy = Object.defineProperties(proxy, Object.getOwnPropertyDescriptors(super.getProxy()));
      this.proxy = proxy;
    }
    return this.proxy;
  }
};

// src/core/nodes/Audio.js
import { every, isBoolean as isBoolean4, isNumber as isNumber3, isString } from "lodash-es";
var v12 = new Vector3Enhanced();
var v2 = new Vector3Enhanced();
var q1 = new three_exports.Quaternion();
var groups = ["music", "sfx"];
var distanceModels = ["linear", "inverse", "exponential"];
var defaults4 = {
  src: null,
  volume: 1,
  loop: false,
  group: "music",
  // see: https://medium.com/@kfarr/understanding-web-audio-api-positional-audio-distance-models-for-webxr-e77998afcdff
  spatial: true,
  distanceModel: "inverse",
  refDistance: 1,
  maxDistance: 40,
  rolloffFactor: 3,
  coneInnerAngle: 360,
  coneOuterAngle: 360,
  coneOuterGain: 0
};
var Audio = class extends Node {
  constructor(data = {}) {
    super(data);
    this.name = "audio";
    this.src = data.src;
    this.volume = data.volume;
    this.loop = data.loop;
    this.group = data.group;
    this.spatial = data.spatial;
    this.distanceModel = data.distanceModel;
    this.refDistance = data.refDistance;
    this.maxDistance = data.maxDistance;
    this.rolloffFactor = data.rolloffFactor;
    this.coneInnerAngle = data.coneInnerAngle;
    this.coneOuterAngle = data.coneOuterAngle;
    this.coneOuterGain = data.coneOuterGain;
    this.n = 0;
    this.source = null;
    this.gainNode = null;
    this.pannerNode = null;
    this.offset = 0;
    this.shouldPlay = false;
    this.startTime = null;
  }
  async mount() {
  }
  commit(didMove) {
    if (this.needsRebuild) {
      this.needsRebuild = false;
      if (this.source) {
        this.pause();
        this.play();
      }
      return;
    }
    if (didMove) {
      this.updatePannerPosition();
    }
  }
  unmount() {
    this.stop();
  }
  updatePannerPosition() {
    if (!this.pannerNode) return;
    const audio = this.ctx.world.audio;
    const pos = v12.setFromMatrixPosition(this.matrixWorld);
    const qua = q1.setFromRotationMatrix(this.matrixWorld);
    const dir = v2.set(0, 0, -1).applyQuaternion(qua);
    if (this.pannerNode.positionX) {
      const endTime = audio.ctx.currentTime + audio.lastDelta;
      this.pannerNode.positionX.linearRampToValueAtTime(pos.x, endTime);
      this.pannerNode.positionY.linearRampToValueAtTime(pos.y, endTime);
      this.pannerNode.positionZ.linearRampToValueAtTime(pos.z, endTime);
      this.pannerNode.orientationX.linearRampToValueAtTime(dir.x, endTime);
      this.pannerNode.orientationY.linearRampToValueAtTime(dir.y, endTime);
      this.pannerNode.orientationZ.linearRampToValueAtTime(dir.z, endTime);
    } else {
      this.pannerNode.setPosition(pos.x, pos.y, pos.z);
      this.pannerNode.setOrientation(dir.x, dir.y, dir.z);
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this._src = source._src;
    this._volume = source._volume;
    this._loop = source._loop;
    this._group = source._group;
    this._spatial = source._spatial;
    this._distanceModel = source._distanceModel;
    this._refDistance = source._refDistance;
    this._maxDistance = source._maxDistance;
    this._rolloffFactor = source._rolloffFactor;
    this._coneInnerAngle = source._coneInnerAngle;
    this._coneOuterAngle = source._coneOuterAngle;
    this._coneOuterGain = source._coneOuterGain;
    return this;
  }
  get src() {
    return this._src;
  }
  set src(value = defaults4.src) {
    if (!isString(value) && value !== null) {
      throw new Error("[audio] src not a string");
    }
    this._src = value || null;
    this.needsRebuild = true;
    this.setDirty();
  }
  get volume() {
    return this._volume;
  }
  set volume(value = defaults4.volume) {
    if (!isNumber3(value)) {
      throw new Error("[audio] volume not a number");
    }
    this._volume = value;
    if (this.gainNode) {
      this.gainNode.gain.value = this._volume;
    }
  }
  get loop() {
    return this._loop;
  }
  set loop(value = defaults4.loop) {
    if (!isBoolean4(value)) {
      throw new Error("[audio] loop not a boolean");
    }
    this._loop = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get group() {
    return this._group;
  }
  set group(value = defaults4.group) {
    if (!isGroup(value)) {
      throw new Error("[audio] group not valid");
    }
    this._group = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get spatial() {
    return this._spatial;
  }
  set spatial(value = defaults4.spatial) {
    if (!isBoolean4(value)) {
      throw new Error("[audio] spatial not a boolean");
    }
    this._spatial = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get distanceModel() {
    return this._distanceModel;
  }
  set distanceModel(value = defaults4.distanceModel) {
    if (!isDistanceModel(value)) {
      throw new Error("[audio] distanceModel not valid");
    }
    this._distanceModel = value;
    if (this.pannerNode) {
      this.pannerNode.distanceModel = this._distanceModel;
    }
  }
  get refDistance() {
    return this._refDistance;
  }
  set refDistance(value = defaults4.refDistance) {
    if (!isNumber3(value)) {
      throw new Error("[audio] refDistance not a number");
    }
    this._refDistance = value;
    if (this.pannerNode) {
      this.pannerNode.refDistance = this._refDistance;
    }
  }
  get maxDistance() {
    return this._maxDistance;
  }
  set maxDistance(value = defaults4.maxDistance) {
    if (!isNumber3(value)) {
      throw new Error("[audio] maxDistance not a number");
    }
    this._maxDistance = value;
    if (this.pannerNode) {
      this.pannerNode.maxDistance = this._maxDistance;
    }
  }
  get rolloffFactor() {
    return this._rolloffFactor;
  }
  set rolloffFactor(value = defaults4.rolloffFactor) {
    if (!isNumber3(value)) {
      throw new Error("[audio] rolloffFactor not a number");
    }
    this._rolloffFactor = value;
    if (this.pannerNode) {
      this.pannerNode.rolloffFactor = this._rolloffFactor;
    }
  }
  get coneInnerAngle() {
    return this._coneInnerAngle;
  }
  set coneInnerAngle(value = defaults4.coneInnerAngle) {
    if (!isNumber3(value)) {
      throw new Error("[audio] coneInnerAngle not a number");
    }
    this._coneInnerAngle = value;
    if (this.pannerNode) {
      this.pannerNode.coneInnerAngle = this._coneInnerAngle;
    }
  }
  get coneOuterAngle() {
    return this._coneOuterAngle;
  }
  set coneOuterAngle(value = defaults4.coneOuterAngle) {
    if (!isNumber3(value)) {
      throw new Error("[audio] coneOuterAngle not a number");
    }
    this._coneOuterAngle = value;
    if (this.pannerNode) {
      this.pannerNode.coneOuterAngle = this._coneOuterAngle;
    }
  }
  get coneOuterGain() {
    return this._coneOuterGain;
  }
  set coneOuterGain(value = defaults4.coneOuterGain) {
    if (!isNumber3(value)) {
      throw new Error("[audio] coneOuterGain not a number");
    }
    this._coneOuterGain = value;
    if (this.pannerNode) {
      this.pannerNode.coneOuterGain = this._coneOuterGain;
    }
  }
  get currentTime() {
    const audio = this.ctx.world.audio;
    if (!audio) {
      return 0;
    }
    if (this.source) {
      return audio.ctx.currentTime - this.startTime;
    }
    return this.offset;
  }
  set currentTime(time) {
    if (!isNumber3(time)) {
      throw new Error("[audio] currentTime not a number");
    }
    const offset = Math.max(0, time);
    if (this.source) {
      this.stop();
      this.offset = offset;
      this.play();
    } else {
      this.offset = offset;
    }
  }
  get isPlaying() {
    return !!this.source;
  }
  async play(restartIfPlaying = false) {
    if (!this.ctx.world) return;
    const loader = this.ctx.world.loader;
    const audio = this.ctx.world.audio;
    if (!audio) return;
    if (!this._src) return;
    if (restartIfPlaying) this.stop();
    if (this.source) return;
    const n6 = ++this.n;
    let buffer2;
    try {
      buffer2 = loader.get("audio", this._src);
      if (!buffer2) buffer2 = await loader.load("audio", this._src);
    } catch (err) {
      console.error(err);
      return;
    }
    if (n6 !== this.n) return;
    this.source = audio.ctx.createBufferSource();
    this.source.buffer = buffer2;
    this.source.loop = this._loop;
    this.gainNode = audio.ctx.createGain();
    this.gainNode.gain.value = this._volume;
    if (this._spatial) {
      this.pannerNode = audio.ctx.createPanner();
      this.pannerNode.panningModel = "HRTF";
      this.pannerNode.distanceModel = this._distanceModel;
      this.pannerNode.refDistance = this._refDistance;
      this.pannerNode.maxDistance = this._maxDistance;
      this.pannerNode.rolloffFactor = this._rolloffFactor;
      this.pannerNode.coneInnerAngle = this._coneInnerAngle;
      this.pannerNode.coneOuterAngle = this._coneOuterAngle;
      this.pannerNode.coneOuterGain = this._coneOuterGain;
      this.source.connect(this.gainNode);
      this.gainNode.connect(this.pannerNode);
      this.pannerNode.connect(audio.groupGains[this._group]);
      this.updatePannerPosition();
    } else {
      this.source.connect(this.gainNode);
      this.gainNode.connect(audio.groupGains[this._group]);
    }
    audio.ready(() => {
      if (n6 !== this.n) return;
      this.startTime = audio.ctx.currentTime - this.offset;
      this.source.start(0, this.offset);
      if (!this._loop) {
        this.source.onended = () => this.stop();
      }
    });
  }
  pause() {
    const audio = this.ctx.world.audio;
    if (!audio) return;
    if (this.source) {
      this.n++;
      this.offset = audio.ctx.currentTime - this.startTime;
      this.source.onended = null;
      this.source.stop();
      this.source = null;
      this.gainNode?.disconnect();
      this.gainNode = null;
      this.pannerNode?.disconnect();
      this.pannerNode = null;
    }
  }
  stop() {
    const audio = this.ctx.world.audio;
    if (!audio) return;
    this.n++;
    this.offset = 0;
    if (this.source) {
      this.source.onended = null;
      this.source?.stop();
      this.source = null;
      this.gainNode?.disconnect();
      this.gainNode = null;
      this.pannerNode?.disconnect();
      this.pannerNode = null;
    }
  }
  setPlaybackRate(rate) {
    const audio = this.ctx.world.audio;
    const endTime = audio.ctx.currentTime + audio.lastDelta;
    this.source?.playbackRate.linearRampToValueAtTime(rate, endTime);
  }
  getProxy() {
    var self2 = this;
    if (!this.proxy) {
      let proxy = {
        get src() {
          return self2.src;
        },
        set src(value) {
          self2.src = value;
        },
        get volume() {
          return self2.volume;
        },
        set volume(value) {
          self2.volume = value;
        },
        get loop() {
          return self2.loop;
        },
        set loop(value) {
          self2.loop = value;
        },
        get group() {
          return self2.group;
        },
        set group(value) {
          self2.group = value;
        },
        get spatial() {
          return self2.spatial;
        },
        set spatial(value) {
          self2.spatial = value;
        },
        get distanceModel() {
          return self2.distanceModel;
        },
        set distanceModel(value) {
          self2.distanceModel = value;
        },
        get refDistance() {
          return self2.refDistance;
        },
        set refDistance(value) {
          self2.refDistance = value;
        },
        get maxDistance() {
          return self2.maxDistance;
        },
        set maxDistance(value) {
          self2.maxDistance = value;
        },
        get rolloffFactor() {
          return self2.rolloffFactor;
        },
        set rolloffFactor(value) {
          self2.rolloffFactor = value;
        },
        get coneInnerAngle() {
          return self2.coneInnerAngle;
        },
        set coneInnerAngle(value) {
          self2.coneInnerAngle = value;
        },
        get coneOuterAngle() {
          return self2.coneOuterAngle;
        },
        set coneOuterAngle(value) {
          self2.coneOuterAngle = value;
        },
        get coneOuterGain() {
          return self2.coneOuterGain;
        },
        set coneOuterGain(value) {
          self2.coneOuterGain = value;
        },
        get currentTime() {
          return self2.currentTime;
        },
        set currentTime(value) {
          self2.currentTime = value;
        },
        get isPlaying() {
          return self2.isPlaying;
        },
        play(restartIfPlaying) {
          self2.play(restartIfPlaying);
        },
        pause() {
          self2.pause();
        },
        stop() {
          self2.stop();
        },
        setPlaybackRate(rate) {
          self2.setPlaybackRate(rate);
        }
      };
      proxy = Object.defineProperties(proxy, Object.getOwnPropertyDescriptors(super.getProxy()));
      this.proxy = proxy;
    }
    return this.proxy;
  }
};
function isDistanceModel(value) {
  return distanceModels.includes(value);
}
function isGroup(value) {
  return groups.includes(value);
}

// src/core/nodes/Video.js
import { isBoolean as isBoolean5, isNumber as isNumber4, isString as isString2 } from "lodash-es";

// src/core/libs/three-custom-shader-material/index.js
import * as T from "three";
var D = (
  /* glsl */
  `
    
#ifdef IS_VERTEX
    vec3 csm_Position;
    vec4 csm_PositionRaw;
    vec3 csm_Normal;

    // csm_PointSize
    #ifdef IS_POINTSMATERIAL
        float csm_PointSize;
    #endif
#else
    vec4 csm_DiffuseColor;
    vec4 csm_FragColor;
    float csm_UnlitFac;

    // csm_Emissive, csm_Roughness, csm_Metalness
    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL
        vec3 csm_Emissive;
        float csm_Roughness;
        float csm_Metalness;
        float csm_Iridescence;
        
        #if defined IS_MESHPHYSICALMATERIAL
            float csm_Clearcoat;
            float csm_ClearcoatRoughness;
            vec3 csm_ClearcoatNormal;
            float csm_Transmission;
            float csm_Thickness;
        #endif
    #endif

    // csm_AO
    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL
        float csm_AO;
    #endif

    // csm_Bump
    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL 
        vec3 csm_Bump;
        vec3 csm_FragNormal;
    #endif

    float csm_DepthAlpha;
#endif
`
);
var P = (
  /* glsl */
  `

#ifdef IS_VERTEX
    // csm_Position & csm_PositionRaw
    #ifdef IS_UNKNOWN
        csm_Position = vec3(0.0);
        csm_PositionRaw = vec4(0.0);
        csm_Normal = vec3(0.0);
    #else
        csm_Position = position;
        csm_PositionRaw = projectionMatrix * modelViewMatrix * vec4(position, 1.);
        csm_Normal = normal;
    #endif

    // csm_PointSize
    #ifdef IS_POINTSMATERIAL
        csm_PointSize = size;
    #endif
#else
    csm_UnlitFac = 0.0;

    // csm_DiffuseColor & csm_FragColor
    #if defined IS_UNKNOWN || defined IS_SHADERMATERIAL || defined IS_MESHDEPTHMATERIAL || defined IS_MESHDISTANCEMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_SHADOWMATERIAL
        csm_DiffuseColor = vec4(1.0, 0.0, 1.0, 1.0);
        csm_FragColor = vec4(1.0, 0.0, 1.0, 1.0);
    #else
        #ifdef USE_MAP
            vec4 _csm_sampledDiffuseColor = texture2D(map, vMapUv);

            #ifdef DECODE_VIDEO_TEXTURE
            // inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)
            _csm_sampledDiffuseColor = vec4(mix(pow(_csm_sampledDiffuseColor.rgb * 0.9478672986 + vec3(0.0521327014), vec3(2.4)), _csm_sampledDiffuseColor.rgb * 0.0773993808, vec3(lessThanEqual(_csm_sampledDiffuseColor.rgb, vec3(0.04045)))), _csm_sampledDiffuseColor.w);
            #endif

            csm_DiffuseColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;
            csm_FragColor = vec4(diffuse, opacity) * _csm_sampledDiffuseColor;
        #else
            csm_DiffuseColor = vec4(diffuse, opacity);
            csm_FragColor = vec4(diffuse, opacity);
        #endif
    #endif

    // csm_Emissive, csm_Roughness, csm_Metalness
    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL
        csm_Emissive = emissive;
        csm_Roughness = roughness;
        csm_Metalness = metalness;

        #ifdef USE_IRIDESCENCE
            csm_Iridescence = iridescence;
        #else
            csm_Iridescence = 0.0;
        #endif

        #if defined IS_MESHPHYSICALMATERIAL
            #ifdef USE_CLEARCOAT
                csm_Clearcoat = clearcoat;
                csm_ClearcoatRoughness = clearcoatRoughness;
            #else
                csm_Clearcoat = 0.0;
                csm_ClearcoatRoughness = 0.0;
            #endif

            #ifdef USE_TRANSMISSION
                csm_Transmission = transmission;
                csm_Thickness = thickness;
            #else
                csm_Transmission = 0.0;
                csm_Thickness = 0.0;
            #endif
        #endif
    #endif

    // csm_AO
    #if defined IS_MESHSTANDARDMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHBASICMATERIAL || defined IS_MESHLAMBERTMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHTOONMATERIAL
        csm_AO = 0.0;
    #endif

    // csm_Bump
    #if defined IS_MESHLAMBERTMATERIAL || defined IS_MESHMATCAPMATERIAL || defined IS_MESHNORMALMATERIAL || defined IS_MESHPHONGMATERIAL || defined IS_MESHPHYSICALMATERIAL || defined IS_MESHSTANDARDMATERIAL || defined IS_MESHTOONMATERIAL || defined IS_SHADOWMATERIAL 
        csm_Bump = vec3(0.0);
        #ifdef FLAT_SHADED
            vec3 fdx = dFdx( vViewPosition );
            vec3 fdy = dFdy( vViewPosition );
            csm_FragNormal = normalize( cross( fdx, fdy ) );
        #else
            csm_FragNormal = normalize(vNormal);
            #ifdef DOUBLE_SIDED
                csm_FragNormal *= gl_FrontFacing ? 1.0 : - 1.0;
            #endif
        #endif
    #endif

    csm_DepthAlpha = 1.0;
#endif
`
);
var H = (
  /* glsl */
  `
    varying mat4 csm_internal_vModelViewMatrix;
`
);
var x = (
  /* glsl */
  `
    csm_internal_vModelViewMatrix = modelViewMatrix;
`
);
var y = (
  /* glsl */
  `
    varying mat4 csm_internal_vModelViewMatrix;
`
);
var F = (
  /* glsl */
  `
    
`
);
var e = {
  // PBR (frag)
  diffuse: "csm_DiffuseColor",
  // Color + alpha
  roughness: "csm_Roughness",
  // Roughness
  metalness: "csm_Metalness",
  // Metalness
  emissive: "csm_Emissive",
  // Emissive
  ao: "csm_AO",
  // AO
  bump: "csm_Bump",
  // Bump
  fragNormal: "csm_FragNormal",
  // Fragment Normal
  clearcoat: "csm_Clearcoat",
  // Clearcoat factor
  clearcoatRoughness: "csm_ClearcoatRoughness",
  // Clearcoat roughness
  clearcoatNormal: "csm_ClearcoatNormal",
  // Clearcoat normals
  transmission: "csm_Transmission",
  // Transmission
  thickness: "csm_Thickness",
  // Thickness
  iridescence: "csm_Iridescence",
  // Iridescence
  // Extras
  pointSize: "csm_PointSize",
  // gl_PointSize (Frag)
  fragColor: "csm_FragColor",
  // gl_FragColor (Frag)
  depthAlpha: "csm_DepthAlpha",
  // Depth (MeshDepthMaterial)
  unlitFac: "csm_UnlitFac",
  // Unlit factor (mix between csm_FragColor and csm_DiffuseColor)
  // Vert
  position: "csm_Position",
  // gl_Position
  positionRaw: "csm_PositionRaw",
  // gl_Position (without projection)
  normal: "csm_Normal"
  // Vertex Normal
};
var O = {
  [`${e.position}`]: "*",
  [`${e.positionRaw}`]: "*",
  [`${e.normal}`]: "*",
  [`${e.depthAlpha}`]: "*",
  [`${e.pointSize}`]: ["PointsMaterial"],
  [`${e.diffuse}`]: "*",
  [`${e.fragColor}`]: "*",
  [`${e.fragNormal}`]: "*",
  [`${e.unlitFac}`]: "*",
  [`${e.emissive}`]: ["MeshStandardMaterial", "MeshPhysicalMaterial"],
  [`${e.roughness}`]: ["MeshStandardMaterial", "MeshPhysicalMaterial"],
  [`${e.metalness}`]: ["MeshStandardMaterial", "MeshPhysicalMaterial"],
  [`${e.iridescence}`]: ["MeshStandardMaterial", "MeshPhysicalMaterial"],
  [`${e.ao}`]: [
    "MeshStandardMaterial",
    "MeshPhysicalMaterial",
    "MeshBasicMaterial",
    "MeshLambertMaterial",
    "MeshPhongMaterial",
    "MeshToonMaterial"
  ],
  [`${e.bump}`]: [
    "MeshLambertMaterial",
    "MeshMatcapMaterial",
    "MeshNormalMaterial",
    "MeshPhongMaterial",
    "MeshPhysicalMaterial",
    "MeshStandardMaterial",
    "MeshToonMaterial",
    "ShadowMaterial"
  ],
  [`${e.clearcoat}`]: ["MeshPhysicalMaterial"],
  [`${e.clearcoatRoughness}`]: ["MeshPhysicalMaterial"],
  [`${e.clearcoatNormal}`]: ["MeshPhysicalMaterial"],
  [`${e.transmission}`]: ["MeshPhysicalMaterial"],
  [`${e.thickness}`]: ["MeshPhysicalMaterial"]
};
var b = {
  // VERT
  "*": {
    "#include <lights_physical_fragment>": T.ShaderChunk.lights_physical_fragment,
    "#include <transmission_fragment>": T.ShaderChunk.transmission_fragment
  },
  [`${e.normal}`]: {
    "#include <beginnormal_vertex>": `
    vec3 objectNormal = ${e.normal};
    #ifdef USE_TANGENT
	    vec3 objectTangent = vec3( tangent.xyz );
    #endif
    `
  },
  [`${e.position}`]: {
    "#include <begin_vertex>": `
    vec3 transformed = ${e.position};
  `
  },
  [`${e.positionRaw}`]: {
    "#include <begin_vertex>": `
    vec4 csm_internal_positionUnprojected = ${e.positionRaw};
    mat4x4 csm_internal_unprojectMatrix = projectionMatrix * modelViewMatrix;
    #ifdef USE_INSTANCING
      csm_internal_unprojectMatrix = csm_internal_unprojectMatrix * instanceMatrix;
    #endif
    csm_internal_positionUnprojected = inverse(csm_internal_unprojectMatrix) * csm_internal_positionUnprojected;
    vec3 transformed = csm_internal_positionUnprojected.xyz;
  `
  },
  [`${e.pointSize}`]: {
    "gl_PointSize = size;": `
    gl_PointSize = ${e.pointSize};
    `
  },
  // FRAG
  [`${e.diffuse}`]: {
    "#include <color_fragment>": `
    #include <color_fragment>
    diffuseColor = ${e.diffuse};
  `
  },
  [`${e.fragColor}`]: {
    "#include <opaque_fragment>": `
    #include <opaque_fragment>
    gl_FragColor = mix(gl_FragColor, ${e.fragColor}, ${e.unlitFac});
  `
  },
  [`${e.emissive}`]: {
    "vec3 totalEmissiveRadiance = emissive;": `
    vec3 totalEmissiveRadiance = ${e.emissive};
    `
  },
  [`${e.roughness}`]: {
    "#include <roughnessmap_fragment>": `
    #include <roughnessmap_fragment>
    roughnessFactor = ${e.roughness};
    `
  },
  [`${e.metalness}`]: {
    "#include <metalnessmap_fragment>": `
    #include <metalnessmap_fragment>
    metalnessFactor = ${e.metalness};
    `
  },
  [`${e.ao}`]: {
    "#include <aomap_fragment>": `
    #include <aomap_fragment>
    reflectedLight.indirectDiffuse *= 1. - ${e.ao};
    `
  },
  [`${e.bump}`]: {
    "#include <normal_fragment_maps>": `
    #include <normal_fragment_maps>

    vec3 csm_internal_orthogonal = ${e.bump} - (dot(${e.bump}, normal) * normal);
    vec3 csm_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_internal_orthogonal;
    normal = normalize(normal - csm_internal_projectedbump);
    `
  },
  [`${e.fragNormal}`]: {
    "#include <normal_fragment_maps>": `
      #include <normal_fragment_maps>
      normal = ${e.fragNormal};
    `
  },
  [`${e.depthAlpha}`]: {
    "gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );": `
      gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity * 1.0 - ${e.depthAlpha} );
    `,
    "gl_FragColor = packDepthToRGBA( fragCoordZ );": `
      if(${e.depthAlpha} < 1.0) discard;
      gl_FragColor = packDepthToRGBA( dist );
    `,
    "gl_FragColor = packDepthToRGBA( dist );": `
      if(${e.depthAlpha} < 1.0) discard;
      gl_FragColor = packDepthToRGBA( dist );
    `
  },
  [`${e.clearcoat}`]: {
    "material.clearcoat = clearcoat;": `material.clearcoat = ${e.clearcoat};`
  },
  [`${e.clearcoatRoughness}`]: {
    "material.clearcoatRoughness = clearcoatRoughness;": `material.clearcoatRoughness = ${e.clearcoatRoughness};`
  },
  [`${e.clearcoatNormal}`]: {
    "#include <clearcoat_normal_fragment_begin>": `
      vec3 csm_coat_internal_orthogonal = csm_ClearcoatNormal - (dot(csm_ClearcoatNormal, nonPerturbedNormal) * nonPerturbedNormal);
      vec3 csm_coat_internal_projectedbump = mat3(csm_internal_vModelViewMatrix) * csm_coat_internal_orthogonal;
      vec3 clearcoatNormal = normalize(nonPerturbedNormal - csm_coat_internal_projectedbump);
    `
  },
  [`${e.transmission}`]: {
    "material.transmission = transmission;": `
      material.transmission = ${e.transmission};
    `
  },
  [`${e.thickness}`]: {
    "material.thickness = thickness;": `
      material.thickness = ${e.thickness};
    `
  },
  [`${e.iridescence}`]: {
    "material.iridescence = iridescence;": `
      material.iridescence = ${e.iridescence};
    `
  }
};
var w = {
  clearcoat: [e.clearcoat, e.clearcoatNormal, e.clearcoatRoughness],
  transmission: [e.transmission],
  iridescence: [e.iridescence]
};
function U(M4) {
  let n6 = 0;
  for (let m7 = 0; m7 < M4.length; m7++) n6 = M4.charCodeAt(m7) + (n6 << 6) + (n6 << 16) - n6;
  const S4 = n6 >>> 0;
  return String(S4);
}
function k(M4) {
  try {
    new M4();
  } catch (n6) {
    if (n6.message.indexOf("is not a constructor") >= 0) return false;
  }
  return true;
}
function L(M4) {
  return M4.replace(/\/\*[\s\S]*?\*\/|\/\/.*/g, "");
}
var B = class extends T.Material {
  constructor({ baseMaterial: n6, vertexShader: S4, fragmentShader: h6, uniforms: m7, patchMap: I4, cacheKey: f5, ...r6 }) {
    if (!n6) throw new Error("CustomShaderMaterial: baseMaterial is required.");
    let i5;
    if (k(n6)) {
      const _4 = Object.keys(r6).length === 0;
      i5 = new n6(_4 ? void 0 : r6);
    } else i5 = n6, Object.assign(i5, r6);
    if (["ShaderMaterial", "RawShaderMaterial"].includes(i5.type))
      throw new Error(`CustomShaderMaterial does not support ${i5.type} as a base material.`);
    super(), this.uniforms = {}, this.vertexShader = "", this.fragmentShader = "";
    const t6 = i5;
    t6.name = `CustomShaderMaterial<${i5.name}>`, t6.update = this.update.bind(t6), t6.__csm = { prevOnBeforeCompile: i5.onBeforeCompile };
    const o5 = { ...t6.uniforms || {}, ...m7 || {} };
    return t6.uniforms = this.uniforms = o5, t6.vertexShader = this.vertexShader = S4 || "", t6.fragmentShader = this.fragmentShader = h6 || "", t6.update({
      fragmentShader: t6.fragmentShader,
      vertexShader: t6.vertexShader,
      uniforms: t6.uniforms,
      patchMap: I4,
      cacheKey: f5
    }), t6;
  }
  update({ fragmentShader: n6, vertexShader: S4, uniforms: h6, cacheKey: m7, patchMap: I4 }) {
    const f5 = L(S4 || ""), r6 = L(n6 || ""), i5 = this;
    h6 && (i5.uniforms = h6), S4 && (i5.vertexShader = S4), n6 && (i5.fragmentShader = n6), Object.entries(w).forEach(([a5, o5]) => {
      for (const _4 in o5) {
        const s5 = o5[_4];
        (r6 && r6.includes(s5) || f5 && f5.includes(s5)) && (i5[a5] || (i5[a5] = 1));
      }
    });
    const p5 = i5.__csm.prevOnBeforeCompile, t6 = (a5, o5, _4) => {
      var c5;
      let s5, d5 = "";
      if (o5) {
        const l5 = /void\s+main\s*\(\s*\)[^{]*{((?:[^{}]+|{(?:[^{}]+|{(?:[^{}]+|{(?:[^{}]+|{[^{}]*})*})*})*})*})/gm;
        s5 = (c5 = o5.matchAll(l5).next().value) == null ? void 0 : c5[1], s5 && (s5 = s5.slice(0, -1));
        const u5 = o5.indexOf("void main() {");
        d5 = o5.slice(0, u5);
      }
      if (_4 && o5 && o5.includes(e.fragColor) && s5 && (s5 = `csm_UnlitFac = 1.0;
` + s5), a5.includes("//~CSM_DEFAULTS")) {
        a5 = a5.replace(
          "void main() {",
          `
          // THREE-CustomShaderMaterial by Faraz Shaikh: https://github.com/FarazzShaikh/THREE-CustomShaderMaterial
  
          ${d5}
          
          void main() {
          `
        );
        const l5 = a5.lastIndexOf("//~CSM_MAIN_END");
        if (l5 !== -1) {
          const v11 = `
            ${s5 ? `${s5}` : ""}
            //~CSM_MAIN_END
          `;
          a5 = a5.slice(0, l5) + v11 + a5.slice(l5);
        }
      } else {
        const l5 = /void\s*main\s*\(\s*\)\s*{/gm;
        a5 = a5.replace(
          l5,
          `
          // THREE-CustomShaderMaterial by Faraz Shaikh: https://github.com/FarazzShaikh/THREE-CustomShaderMaterial
  
          //~CSM_DEFAULTS
          ${_4 ? y : H}
          ${D}
  
          ${d5}
          
          void main() {
            {
              ${P}
            }
            ${_4 ? F : x}

            ${s5 ? `${s5}` : ""}
            //~CSM_MAIN_END
          `
        );
      }
      return a5;
    };
    i5.onBeforeCompile = (a5, o5) => {
      p5 == null || p5(a5, o5);
      const s5 = { ...b, ...I4 || {} }, d5 = i5.type, R4 = d5 ? `#define IS_${d5.toUpperCase()};
` : `#define IS_UNKNOWN;
`;
      a5.vertexShader = R4 + `#define IS_VERTEX
` + a5.vertexShader, a5.fragmentShader = R4 + `#define IS_FRAGMENT
` + a5.fragmentShader;
      for (const c5 in s5) {
        const l5 = c5 === "*" || f5 && f5.includes(c5);
        if (c5 === "*" || r6 && r6.includes(c5) || l5) {
          const u5 = O[c5];
          if (u5 && u5 !== "*" && (Array.isArray(u5) ? !u5.includes(d5) : u5 !== d5)) {
            console.error(`CustomShaderMaterial: ${c5} is not available in ${d5}. Shader cannot compile.`);
            return;
          }
          const C4 = s5[c5];
          for (const g5 in C4) {
            const A4 = C4[g5];
            if (typeof A4 == "object") {
              const $3 = A4.type, N4 = A4.value;
              $3 === "fs" ? a5.fragmentShader = a5.fragmentShader.replace(g5, N4) : $3 === "vs" && (a5.vertexShader = a5.vertexShader.replace(g5, N4));
            } else
              A4 && (a5.vertexShader = a5.vertexShader.replace(g5, A4), a5.fragmentShader = a5.fragmentShader.replace(g5, A4));
          }
        }
      }
      ;
      a5.vertexShader = t6(a5.vertexShader, f5, false), a5.fragmentShader = t6(a5.fragmentShader, r6, true), h6 && (a5.uniforms = { ...a5.uniforms, ...i5.uniforms }), i5.uniforms = a5.uniforms;
    };
    const E4 = i5.customProgramCacheKey;
    i5.customProgramCacheKey = () => ((m7 == null ? void 0 : m7()) || U((f5 || "") + (r6 || ""))) + (E4 == null ? void 0 : E4.call(i5)), i5.needsUpdate = true;
  }
};

// src/core/utils.js
import { some } from "lodash-es";
import { customAlphabet } from "nanoid";
var ALPHABET = "1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
var uuid = customAlphabet(ALPHABET, 10);
function clamp(n6, low, high) {
  return Math.max(Math.min(n6, high), low);
}
function hasRole(arr, ...roles) {
  if (!arr) return false;
  return some(roles, (role) => arr.includes(role) || arr.includes(`~${role}`));
}
function num(min, max, dp = 0) {
  const value = Math.random() * (max - min) + min;
  return parseFloat(value.toFixed(dp));
}

// src/core/nodes/Video.js
var v13 = new Vector3Enhanced();
var v22 = new Vector3Enhanced();
var q12 = new three_exports.Quaternion();
var groups2 = ["music", "sfx"];
var distanceModels2 = ["linear", "inverse", "exponential"];
var fits = ["none", "cover", "contain"];
var pivots = [
  "top-left",
  "top-center",
  "top-right",
  "center-left",
  "center",
  "center-right",
  "bottom-left",
  "bottom-center",
  "bottom-right"
];
var defaults5 = {
  screenId: null,
  src: null,
  linked: false,
  loop: false,
  visible: true,
  color: "black",
  lit: false,
  doubleside: false,
  castShadow: false,
  receiveShadow: false,
  aspect: 16 / 9,
  fit: "contain",
  width: null,
  height: 1,
  pivot: "center",
  geometry: null,
  volume: 1,
  group: "music",
  spatial: true,
  distanceModel: "inverse",
  refDistance: 1,
  maxDistance: 40,
  rolloffFactor: 3,
  coneInnerAngle: 360,
  coneOuterAngle: 360,
  coneOuterGain: 0
};
var Video = class extends Node {
  constructor(data = {}) {
    super(data);
    this.name = "video";
    this.screenId = data.screenId;
    this.src = data.src;
    this.linked = data.linked;
    this.loop = data.loop;
    this.visible = data.visible;
    this.color = data.color;
    this.lit = data.lit;
    this.doubleside = data.doubleside;
    this.castShadow = data.castShadow;
    this.receiveShadow = data.receiveShadow;
    this.aspect = data.aspect;
    this.fit = data.fit;
    this.width = data.width;
    this.height = data.height;
    this.pivot = data.pivot;
    this.geometry = data.geometry;
    this.volume = data.volume;
    this.group = data.group;
    this.spatial = data.spatial;
    this.distanceModel = data.distanceModel;
    this.refDistance = data.refDistance;
    this.maxDistance = data.maxDistance;
    this.rolloffFactor = data.rolloffFactor;
    this.coneInnerAngle = data.coneInnerAngle;
    this.coneOuterAngle = data.coneOuterAngle;
    this.coneOuterGain = data.coneOuterGain;
    this.n = 0;
    this._loading = true;
  }
  async mount() {
    this.needsRebuild = false;
    if (this.ctx.world.network.isServer) return;
    this._loading = true;
    const n6 = ++this.n;
    let key = "";
    if (this._linked === true) {
      key += "default";
    } else if (this._linked === false) {
      key += uuid();
    } else {
      key += this._linked;
    }
    let screen;
    if (this._screenId) {
      screen = this.ctx.world.livekit.registerScreenNode(this);
    }
    if (screen) {
      this.instance = screen;
    } else if (this._src) {
      let factory = this.ctx.world.loader.get("video", this._src);
      if (!factory) factory = await this.ctx.world.loader.load("video", this._src);
      if (this.n !== n6) return;
      this.instance = factory.get(key);
    }
    if (this._visible) {
      let material2;
      let vidAspect = this.instance?.width / this.instance?.height || this._aspect;
      const uniforms = {
        uMap: { value: null },
        uHasMap: { value: 0 },
        uVidAspect: { value: vidAspect },
        uGeoAspect: { value: this._aspect },
        uFit: { value: this._fit === "cover" ? 1 : this._fit === "contain" ? 2 : 0 },
        // 0 = none, 1 = cover, 2 = contain
        uColor: { value: new three_exports.Color(this._color) },
        uOffset: { value: new three_exports.Vector2(0, 0) }
      };
      material2 = new B({
        baseMaterial: this._lit ? three_exports.MeshStandardMaterial : three_exports.MeshBasicMaterial,
        ...this._lit ? { roughness: 1, metalness: 0 } : {},
        // color,
        side: this._doubleside ? three_exports.DoubleSide : three_exports.FrontSide,
        uniforms,
        vertexShader: `
          varying vec2 vUv;
          void main() {
            vUv = uv;
          }
        `,
        fragmentShader: `
          uniform sampler2D uMap;
          uniform float uHasMap;
          uniform float uVidAspect;
          uniform float uGeoAspect;
          uniform float uFit; // 0 = none, 1 = cover, 2 = contain
          uniform vec3 uColor; 
          uniform vec2 uOffset;
          
          varying vec2 vUv;

          vec4 sRGBToLinear(vec4 color) {
            return vec4(pow(color.rgb, vec3(2.2)), color.a);
          }
          
          vec4 LinearToSRGB(vec4 color) {
              return vec4(pow(color.rgb, vec3(1.0 / 2.2)), color.a);
          }
          
          void main() {
            // Calculate aspect ratio relationship between video and geometry
            float aspect = uGeoAspect / uVidAspect;

            vec2 uv = vUv;

            // Apply UV offset
            uv = uv + uOffset;
            
            // COVER MODE (uFit = 1.0)
            if (abs(uFit - 1.0) < 0.01) {
              // Center the UV coordinates
              uv = uv - 0.5;
              
              if (aspect > 1.0) {
                // Geometry is wider than video:
                // - Fill horizontally (maintain x scale)
                // - Scale vertically to maintain aspect ratio (shrink y)
                uv.y /= aspect;
              } else {
                // Geometry is taller than video:
                // - Fill vertically (maintain y scale)
                // - Scale horizontally to maintain aspect ratio (shrink x)
                uv.x *= aspect;
              }
              
              // Return to 0-1 range
              uv = uv + 0.5;
            }
            // CONTAIN MODE (uFit = 2.0)
            else if (abs(uFit - 2.0) < 0.01) {
              // Center the UV coordinates
              uv = uv - 0.5;
              
              if (aspect > 1.0) {
                // Geometry is wider than video:
                // - Fill vertically (maintain y scale)
                // - Scale horizontally to fit entire video (expand x)
                uv.x *= aspect;
              } else {
                // Geometry is taller than video:
                // - Fill horizontally (maintain x scale)
                // - Scale vertically to fit entire video (expand y)
                uv.y /= aspect;
              }
              
              // Return to 0-1 range
              uv = uv + 0.5;
            }

            // pull UV into [0,1] before sampling
            vec2 uvClamped = clamp(uv, 0.0, 1.0);
            vec4 col = texture2D(uMap, uvClamped);

            // outside coloring (for contain mode)
            if (uFit >= 1.5) {
              const float EPS = 0.005;
              // decide \u201Coutside\u201D based on the *raw* uv
              bool outside = uv.x < -EPS || uv.x > 1.0 + EPS || uv.y < -EPS || uv.y > 1.0 + EPS;
              if (outside) {
                col = vec4(uColor, 1.0);
              }
            } 

            csm_DiffuseColor = sRGBToLinear(col);
          }
        `
      });
      this.ctx.world.setupMaterial(material2);
      let geometry;
      if (this._geometry) {
        geometry = this._geometry;
      }
      if (!this._geometry) {
        let width = this._width;
        let height = this._height;
        let preAspect = this._aspect;
        if (width === null && height === null) {
          height = 0;
          width = 0;
        } else if (width !== null && height === null) {
          height = width / preAspect;
        } else if (height !== null && width === null) {
          width = height * preAspect;
        }
        geometry = new three_exports.PlaneGeometry(width, height);
        geometry._oWidth = width;
        geometry._oHeight = height;
        applyPivot(geometry, width, height, this._pivot);
      }
      this.mesh = new three_exports.Mesh(geometry, material2);
      this.mesh.castShadow = this._castShadow;
      this.mesh.receiveShadow = this._receiveShadow;
      this.mesh.matrixWorld.copy(this.matrixWorld);
      this.mesh.matrixAutoUpdate = false;
      this.mesh.matrixWorldAutoUpdate = false;
      this.ctx.world.stage.scene.add(this.mesh);
      this.sItem = {
        matrix: this.matrixWorld,
        geometry,
        material: material2,
        getEntity: () => this.ctx.entity,
        node: this
      };
      this.ctx.world.stage.octree.insert(this.sItem);
    }
    if (!this.instance) return;
    await this.instance.prepare;
    if (this.n !== n6) return;
    this.instance.loop = this._loop;
    this.gain = this.ctx.world.audio.ctx.createGain();
    this.gain.gain.value = this._volume;
    this.gain.connect(this.ctx.world.audio.groupGains.music);
    if (this._spatial) {
      this.panner = this.ctx.world.audio.ctx.createPanner();
      this.panner.panningModel = "HRTF";
      this.panner.distanceModel = this._distanceModel;
      this.panner.refDistance = this._refDistance;
      this.panner.maxDistance = this._maxDistance;
      this.panner.rolloffFactor = this._rolloffFactor;
      this.panner.coneInnerAngle = this._coneInnerAngle;
      this.panner.coneOuterAngle = this._coneOuterAngle;
      this.panner.coneOuterGain = this._coneOuterGain;
      this.panner.connect(this.gain);
      this.instance.audio?.connect(this.panner);
      this.updatePannerPosition();
    } else {
      this.instance.audio?.connect(this.gain);
    }
    if (this._visible) {
      const geometry = this.mesh.geometry;
      const material2 = this.mesh.material;
      let vidAspect;
      let geoAspect;
      if (this._geometry) {
        vidAspect = this.instance.width / this.instance.height;
        geoAspect = this._aspect;
      }
      if (!this._geometry) {
        vidAspect = this.instance.width / this.instance.height;
        let width = this._width;
        let height = this._height;
        if (width === null && height === null) {
          height = 0;
          width = 0;
        } else if (width !== null && height === null) {
          height = width / vidAspect;
        } else if (height !== null && width === null) {
          width = height * vidAspect;
        }
        if (geometry._oWidth !== width || geometry._oHeight !== height) {
          const newGeometry = new three_exports.PlaneGeometry(width, height);
          applyPivot(newGeometry, width, height, this._pivot);
          this.mesh.geometry = newGeometry;
          geometry.dispose();
        }
        geoAspect = width / height;
      }
      material2.color.set("white");
      material2.uniforms.uVidAspect.value = vidAspect;
      material2.uniforms.uGeoAspect.value = geoAspect;
      material2.uniforms.uMap.value = this.instance.texture;
      material2.uniforms.uHasMap.value = 1;
      material2.needsUpdate = true;
      this._loading = false;
      this._onLoad?.();
      if (this.shouldPlay) {
        this.instance.play();
        this.shouldPlay = false;
      }
    }
  }
  commit(didMove) {
    if (this.needsRebuild) {
      this.unmount();
      this.mount();
      return;
    }
    if (didMove) {
      if (this.mesh) {
        this.mesh.matrixWorld.copy(this.matrixWorld);
      }
      if (this.sItem) {
        this.ctx.world.stage.octree.move(this.sItem);
      }
      if (this.panner) {
        this.updatePannerPosition();
      }
    }
  }
  unmount() {
    if (this.ctx.world.network.isServer) return;
    this.n++;
    if (this.mesh) {
      this.ctx.world.stage.scene.remove(this.mesh);
      this.mesh.material.dispose();
      this.mesh.geometry.dispose();
      this.mesh = null;
    }
    if (this.instance) {
      if (this.panner) {
        this.instance.audio?.disconnect(this.panner);
      } else {
        this.instance.audio?.disconnect(this.gain);
      }
      this.panner = null;
      this.gain = null;
      this.instance.release();
      this.instance = null;
    }
    if (this.sItem) {
      this.ctx.world.stage.octree.remove(this.sItem);
      this.sItem = null;
    }
    this.ctx.world.livekit.unregisterScreenNode(this);
  }
  updatePannerPosition() {
    const audio = this.ctx.world.audio;
    const pos = v13.setFromMatrixPosition(this.matrixWorld);
    const qua = q12.setFromRotationMatrix(this.matrixWorld);
    const dir = v22.set(0, 0, -1).applyQuaternion(qua);
    if (this.panner.positionX) {
      const endTime = audio.ctx.currentTime + audio.lastDelta;
      this.panner.positionX.linearRampToValueAtTime(pos.x, endTime);
      this.panner.positionY.linearRampToValueAtTime(pos.y, endTime);
      this.panner.positionZ.linearRampToValueAtTime(pos.z, endTime);
      this.panner.orientationX.linearRampToValueAtTime(dir.x, endTime);
      this.panner.orientationY.linearRampToValueAtTime(dir.y, endTime);
      this.panner.orientationZ.linearRampToValueAtTime(dir.z, endTime);
    } else {
      this.panner.setPosition(pos.x, pos.y, pos.z);
      this.panner.setOrientation(dir.x, dir.y, dir.z);
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this._screenId = source._screenId;
    this._src = source._src;
    this._linked = source._linked;
    this._loop = source._loop;
    this._visible = source._visible;
    this._color = source._color;
    this._lit = source._lit;
    this._doubleside = source._doubleside;
    this._castShadow = source._castShadow;
    this._receiveShadow = source._receiveShadow;
    this._aspect = source._aspect;
    this._fit = source._fit;
    this._width = source._width;
    this._height = source._height;
    this._pivot = source._pivot;
    this._geometry = source._geometry;
    this._volume = source._volume;
    this._spatial = source._spatial;
    this._group = source._group;
    this._spatial = source._spatial;
    this._distanceModel = source._distanceModel;
    this._refDistance = source._refDistance;
    this._maxDistance = source._maxDistance;
    this._rolloffFactor = source._rolloffFactor;
    this._coneInnerAngle = source._coneInnerAngle;
    this._coneOuterAngle = source._coneOuterAngle;
    this._coneOuterGain = source._coneOuterGain;
    return this;
  }
  get screenId() {
    return this._screenId;
  }
  set screenId(value = defaults5.screenId) {
    if (value !== null && !isString2(value)) {
      throw new Error("[video] screenId not null or string");
    }
    if (this._screenId === value) return;
    this._screenId = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get src() {
    return this._src;
  }
  set src(value = defaults5.src) {
    if (value !== null && !isString2(value)) {
      throw new Error("[video] src not null or string");
    }
    if (this._src === value) return;
    this._src = value;
    this._loading = true;
    this.needsRebuild = true;
    this.setDirty();
  }
  get linked() {
    return this._linked;
  }
  set linked(value = defaults5.linked) {
    if (!isBoolean5(value) && !isString2(value)) {
      throw new Error("[video] linked not boolean or string");
    }
    if (this._linked === value) return;
    this._linked = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get loop() {
    return this._loop;
  }
  set loop(value = defaults5.loop) {
    if (!isBoolean5(value)) {
      throw new Error("[video] loop not boolean");
    }
    if (this._loop === value) return;
    this._loop = value;
    if (this.instance) {
      this.instance.loop = value;
    }
  }
  get visible() {
    return this._visible;
  }
  set visible(value = defaults5.visible) {
    if (!isBoolean5(value)) {
      throw new Error("[video] visible not a boolean");
    }
    if (this._visible === value) return;
    this._visible = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get color() {
    return this._color;
  }
  set color(value = defaults5.color) {
    if (value !== null && !isString2(value)) {
      throw new Error("[video] color not null or string");
    }
    if (this._color === value) return;
    this._color = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get lit() {
    return this._lit;
  }
  set lit(value = defaults5.lit) {
    if (!isBoolean5(value)) {
      throw new Error("[video] lit not boolean");
    }
    if (this._lit === value) return;
    this._lit = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get doubleside() {
    return this._doubleside;
  }
  set doubleside(value = defaults5.doubleside) {
    if (!isBoolean5(value)) {
      throw new Error("[video] doubleside not boolean");
    }
    if (this._doubleside === value) return;
    this._doubleside = value;
    if (this.mesh) {
      this.mesh.material.side = value ? three_exports.DoubleSide : three_exports.FrontSide;
      this.mesh.material.needsUpdate = true;
    }
  }
  get castShadow() {
    return this._castShadow;
  }
  set castShadow(value = defaults5.castShadow) {
    if (!isBoolean5(value)) {
      throw new Error("[video] castShadow not boolean");
    }
    if (this._castShadow === value) return;
    this._castShadow = value;
    if (this.mesh) {
      this.mesh.castShadow = value;
    }
  }
  get receiveShadow() {
    return this._receiveShadow;
  }
  set receiveShadow(value = defaults5.receiveShadow) {
    if (!isBoolean5(value)) {
      throw new Error("[video] receiveShadow not boolean");
    }
    if (this._receiveShadow === value) return;
    this._receiveShadow = value;
    if (this.mesh) {
      this.mesh.receiveShadow = value;
    }
  }
  get aspect() {
    return this._aspect;
  }
  set aspect(value = defaults5.aspect) {
    if (!isNumber4(value)) {
      throw new Error("[video] aspect not a number");
    }
    if (this._aspect === value) return;
    this._aspect = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get fit() {
    return this._fit;
  }
  set fit(value = defaults5.fit) {
    if (!isFit(value)) {
      throw new Error("[video] fit invalid");
    }
    if (this._fit === value) return;
    this._fit = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get width() {
    return this._width;
  }
  set width(value = defaults5.width) {
    if (value !== null && !isNumber4(value)) {
      throw new Error("[video] width not null or number");
    }
    if (this._width === value) return;
    this._width = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get height() {
    return this._height;
  }
  set height(value = defaults5.height) {
    if (value !== null && !isNumber4(value)) {
      throw new Error("[video] height not null or number");
    }
    if (this._height === value) return;
    this._height = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get pivot() {
    return this._pivot;
  }
  set pivot(value = defaults5.pivot) {
    if (!isPivot(value)) {
      throw new Error("[video] pivot invalid");
    }
    if (this._pivot === value) return;
    this._pivot = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get geometry() {
    return secureRef({}, () => this._geometry);
  }
  set geometry(value = defaults5.geometry) {
    this._geometry = getRef(value);
    this.needsRebuild = true;
    this.setDirty();
  }
  get volume() {
    return this._volume;
  }
  set volume(value = defaults5.volume) {
    if (!isNumber4(value)) {
      throw new Error("[video] volume not number");
    }
    if (this._volume === value) return;
    this._volume = value;
    if (this.gain) {
      this.gain.gain.value = value;
    }
  }
  get group() {
    return this._group;
  }
  set group(value = defaults5.group) {
    if (!isGroup2(value)) {
      throw new Error("[video] group not valid");
    }
    this._group = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get spatial() {
    return this._spatial;
  }
  set spatial(value = defaults5.spatial) {
    if (!isBoolean5(value)) {
      throw new Error("[video] spatial not boolean");
    }
    if (this._spatial === value) return;
    this._spatial = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get distanceModel() {
    return this._distanceModel;
  }
  set distanceModel(value = defaults5.distanceModel) {
    if (!isDistanceModel2(value)) {
      throw new Error("[audio] distanceModel not valid");
    }
    this._distanceModel = value;
    if (this.pannerNode) {
      this.pannerNode.distanceModel = this._distanceModel;
    }
  }
  get refDistance() {
    return this._refDistance;
  }
  set refDistance(value = defaults5.refDistance) {
    if (!isNumber4(value)) {
      throw new Error("[audio] refDistance not a number");
    }
    this._refDistance = value;
    if (this.pannerNode) {
      this.pannerNode.refDistance = this._refDistance;
    }
  }
  get maxDistance() {
    return this._maxDistance;
  }
  set maxDistance(value = defaults5.maxDistance) {
    if (!isNumber4(value)) {
      throw new Error("[audio] maxDistance not a number");
    }
    this._maxDistance = value;
    if (this.pannerNode) {
      this.pannerNode.maxDistance = this._maxDistance;
    }
  }
  get rolloffFactor() {
    return this._rolloffFactor;
  }
  set rolloffFactor(value = defaults5.rolloffFactor) {
    if (!isNumber4(value)) {
      throw new Error("[audio] rolloffFactor not a number");
    }
    this._rolloffFactor = value;
    if (this.pannerNode) {
      this.pannerNode.rolloffFactor = this._rolloffFactor;
    }
  }
  get coneInnerAngle() {
    return this._coneInnerAngle;
  }
  set coneInnerAngle(value = defaults5.coneInnerAngle) {
    if (!isNumber4(value)) {
      throw new Error("[audio] coneInnerAngle not a number");
    }
    this._coneInnerAngle = value;
    if (this.pannerNode) {
      this.pannerNode.coneInnerAngle = this._coneInnerAngle;
    }
  }
  get coneOuterAngle() {
    return this._coneOuterAngle;
  }
  set coneOuterAngle(value = defaults5.coneOuterAngle) {
    if (!isNumber4(value)) {
      throw new Error("[audio] coneOuterAngle not a number");
    }
    this._coneOuterAngle = value;
    if (this.pannerNode) {
      this.pannerNode.coneOuterAngle = this._coneOuterAngle;
    }
  }
  get coneOuterGain() {
    return this._coneOuterGain;
  }
  set coneOuterGain(value = defaults5.coneOuterGain) {
    if (!isNumber4(value)) {
      throw new Error("[audio] coneOuterGain not a number");
    }
    this._coneOuterGain = value;
    if (this.pannerNode) {
      this.pannerNode.coneOuterGain = this._coneOuterGain;
    }
  }
  get loading() {
    return this._loading;
  }
  get duration() {
    return this.instance ? this.instance.duration : 0;
  }
  get playing() {
    return this.instance ? this.instance.isPlaying : false;
  }
  get time() {
    return this.instance ? this.instance.currentTime : 0;
  }
  set time(value) {
    if (this.instance) {
      this.instance.currentTime = value;
    }
  }
  get material() {
    if (!this._materialProxy) {
      const self2 = this;
      this._materialProxy = {
        get textureX() {
          return self2.mesh.material.uniforms.uOffset.value.x;
        },
        set textureX(value) {
          self2.mesh.material.uniforms.uOffset.value.x = value;
        },
        get textureY() {
          return self2.mesh.material.uniforms.uOffset.value.y;
        },
        set textureY(value) {
          self2.mesh.material.uniforms.uOffset.value.y = value;
        }
      };
    }
    return this._materialProxy;
  }
  set material(value) {
    throw new Error("[video] cannot set material");
  }
  get onLoad() {
    return this._onLoad;
  }
  set onLoad(value) {
    this._onLoad = value;
  }
  play(restartIfPlaying) {
    if (this.instance) {
      this.instance.play(restartIfPlaying);
    } else {
      this.shouldPlay = true;
    }
  }
  pause() {
    this.instance?.pause();
  }
  stop() {
    this.instance?.stop();
  }
  getProxy() {
    var self2 = this;
    if (!this.proxy) {
      let proxy = {
        get screenId() {
          return self2.screenId;
        },
        set screenId(value) {
          self2.screenId = value;
        },
        get src() {
          return self2.src;
        },
        set src(value) {
          self2.src = value;
        },
        get linked() {
          return self2.linked;
        },
        set linked(value) {
          self2.linked = value;
        },
        get loop() {
          return self2.loop;
        },
        set loop(value) {
          self2.loop = value;
        },
        get visible() {
          return self2.visible;
        },
        set visible(value) {
          self2.visible = value;
        },
        get color() {
          return self2.color;
        },
        set color(value) {
          self2.color = value;
        },
        get lit() {
          return self2.lit;
        },
        set lit(value) {
          self2.lit = value;
        },
        get doubleside() {
          return self2.doubleside;
        },
        set doubleside(value) {
          self2.doubleside = value;
        },
        get castShadow() {
          return self2.castShadow;
        },
        set castShadow(value) {
          self2.castShadow = value;
        },
        get receiveShadow() {
          return self2.receiveShadow;
        },
        set receiveShadow(value) {
          self2.receiveShadow = value;
        },
        get aspect() {
          return self2.aspect;
        },
        set aspect(value) {
          self2.aspect = value;
        },
        get fit() {
          return self2.fit;
        },
        set fit(value) {
          self2.fit = value;
        },
        get width() {
          return self2.width;
        },
        set width(value) {
          self2.width = value;
        },
        get height() {
          return self2.height;
        },
        set height(value) {
          self2.height = value;
        },
        get pivot() {
          return self2.pivot;
        },
        set pivot(value) {
          self2.pivot = value;
        },
        get geometry() {
          return self2.geometry;
        },
        set geometry(value) {
          self2.geometry = value;
        },
        get volume() {
          return self2.volume;
        },
        set volume(value) {
          self2.volume = value;
        },
        get group() {
          return self2.group;
        },
        set group(value) {
          self2.group = value;
        },
        get spatial() {
          return self2.spatial;
        },
        set spatial(value) {
          self2.spatial = value;
        },
        get distanceModel() {
          return self2.distanceModel;
        },
        set distanceModel(value) {
          self2.distanceModel = value;
        },
        get refDistance() {
          return self2.refDistance;
        },
        set refDistance(value) {
          self2.refDistance = value;
        },
        get maxDistance() {
          return self2.maxDistance;
        },
        set maxDistance(value) {
          self2.maxDistance = value;
        },
        get rolloffFactor() {
          return self2.rolloffFactor;
        },
        set rolloffFactor(value) {
          self2.rolloffFactor = value;
        },
        get coneInnerAngle() {
          return self2.coneInnerAngle;
        },
        set coneInnerAngle(value) {
          self2.coneInnerAngle = value;
        },
        get coneOuterAngle() {
          return self2.coneOuterAngle;
        },
        set coneOuterAngle(value) {
          self2.coneOuterAngle = value;
        },
        get coneOuterGain() {
          return self2.coneOuterGain;
        },
        set coneOuterGain(value) {
          self2.coneOuterGain = value;
        },
        get loading() {
          return self2.loading;
        },
        get duration() {
          return self2.duration;
        },
        get playing() {
          return self2.playing;
        },
        get isPlaying() {
          return self2.playing;
        },
        get time() {
          return self2.time;
        },
        set time(value) {
          self2.time = value;
        },
        get currentTime() {
          return self2.time;
        },
        set currentTime(value) {
          self2.time = value;
        },
        get material() {
          return self2.material;
        },
        set material(value) {
          self2.material = value;
        },
        get onLoad() {
          return self2.onLoad;
        },
        set onLoad(value) {
          self2.onLoad = value;
        },
        play(restartIfPlaying) {
          self2.play(restartIfPlaying);
        },
        pause() {
          self2.pause();
        },
        stop() {
          self2.stop();
        }
      };
      proxy = Object.defineProperties(proxy, Object.getOwnPropertyDescriptors(super.getProxy()));
      this.proxy = proxy;
    }
    return this.proxy;
  }
};
function isDistanceModel2(value) {
  return distanceModels2.includes(value);
}
function isGroup2(value) {
  return groups2.includes(value);
}
function isFit(value) {
  return fits.includes(value);
}
function isPivot(value) {
  return pivots.includes(value);
}
function applyPivot(geometry, width, height, pivot) {
  if (pivot === "center") return;
  let offsetX = 0;
  let offsetY = 0;
  if (pivot.includes("left")) {
    offsetX = width / 2;
  } else if (pivot.includes("right")) {
    offsetX = -width / 2;
  }
  if (pivot.includes("top")) {
    offsetY = -height / 2;
  } else if (pivot.includes("bottom")) {
    offsetY = height / 2;
  }
  if (offsetX !== 0 || offsetY !== 0) {
    geometry.translate(offsetX, offsetY, 0);
  }
}

// src/core/nodes/Image.js
import { isBoolean as isBoolean6, isNumber as isNumber5, isString as isString3 } from "lodash-es";
var fits2 = ["none", "cover", "contain"];
var pivots2 = [
  "top-left",
  "top-center",
  "top-right",
  "center-left",
  "center",
  "center-right",
  "bottom-left",
  "bottom-center",
  "bottom-right"
];
var defaults6 = {
  src: null,
  width: null,
  height: 1,
  fit: "contain",
  color: "black",
  pivot: "center",
  lit: false,
  doubleside: false,
  castShadow: false,
  receiveShadow: false
};
var Image2 = class extends Node {
  constructor(data = {}) {
    super(data);
    this.name = "image";
    this.src = data.src;
    this.width = data.width;
    this.height = data.height;
    this.fit = data.fit;
    this.color = data.color;
    this.pivot = data.pivot;
    this.lit = data.lit;
    this.doubleside = data.doubleside;
    this.castShadow = data.castShadow;
    this.receiveShadow = data.receiveShadow;
    this.n = 0;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this._src = source._src;
    this._width = source._width;
    this._height = source._height;
    this._fit = source._fit;
    this._color = source._color;
    this._pivot = source._pivot;
    this._lit = source._lit;
    this._doubleside = source._doubleside;
    this._castShadow = source._castShadow;
    this._receiveShadow = source._receiveShadow;
    return this;
  }
  async mount() {
    this.build();
  }
  commit(didMove) {
    if (this.needsRebuild) {
      this.build();
      return;
    }
    if (didMove) {
      if (this.mesh) {
        this.mesh.matrixWorld.copy(this.matrixWorld);
      }
    }
  }
  unmount() {
    this.unbuild();
  }
  async build() {
    this.needsRebuild = false;
    if (this.ctx.world.network.isServer) return;
    if (!this._src) return;
    const n6 = ++this.n;
    let image = this.ctx.world.loader.get("image", this._src);
    if (!image) image = await this.ctx.world.loader.load("image", this._src);
    if (this.n !== n6) return;
    this.unbuild();
    const imgAspect = image.width / image.height;
    let width = this._width;
    let height = this._height;
    if (width === null && height === null) {
      height = 0;
      width = 0;
    } else if (width !== null && height === null) {
      height = width / imgAspect;
    } else if (height !== null && width === null) {
      width = height * imgAspect;
    }
    const geoAspect = width / height;
    this.texture = new three_exports.Texture(image);
    this.texture.colorSpace = three_exports.SRGBColorSpace;
    this.texture.anisotropy = this.ctx.world.graphics.maxAnisotropy;
    this.texture.needsUpdate = true;
    if (this._width && this._height) {
      applyFit(this.texture, width, height, this._fit);
    }
    const geometry = new three_exports.PlaneGeometry(width, height);
    applyPivot2(geometry, width, height, this._pivot);
    const uniforms = {
      uMap: { value: this.texture },
      uImgAspect: { value: imgAspect },
      uGeoAspect: { value: geoAspect },
      uFit: { value: this._fit === "cover" ? 1 : this._fit === "contain" ? 2 : 0 },
      // 0 = none, 1 = cover, 2 = contain
      uColor: { value: new three_exports.Color(this._color) },
      uTransparent: { value: this._color === "transparent" ? 1 : 0 }
    };
    const material2 = new B({
      baseMaterial: this._lit ? three_exports.MeshStandardMaterial : three_exports.MeshBasicMaterial,
      ...this._lit ? { roughness: 1, metalness: 0 } : {},
      side: this._doubleside ? three_exports.DoubleSide : three_exports.FrontSide,
      transparent: this._color === "transparent",
      uniforms,
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
        }
      `,
      fragmentShader: `
        uniform sampler2D uMap;
        uniform float uImgAspect;
        uniform float uGeoAspect;
        uniform float uFit; // 0 = none, 1 = cover, 2 = contain
        uniform vec3 uColor; 
        uniform float uTransparent;
        
        varying vec2 vUv;

        vec4 sRGBToLinear(vec4 color) {
          return vec4(pow(color.rgb, vec3(2.2)), color.a);
        }
        
        vec4 LinearToSRGB(vec4 color) {
            return vec4(pow(color.rgb, vec3(1.0 / 2.2)), color.a);
        }
        
        void main() {
          // Calculate aspect ratio relationship between image and geometry
          float aspect = uGeoAspect / uImgAspect;

          vec2 uv = vUv;
          
          // COVER MODE (uFit = 1.0)
          if (abs(uFit - 1.0) < 0.01) {
            // Center the UV coordinates
            uv = uv - 0.5;
            
            if (aspect > 1.0) {
              // Geometry is wider than video:
              // - Fill horizontally (maintain x scale)
              // - Scale vertically to maintain aspect ratio (shrink y)
              uv.y /= aspect;
            } else {
              // Geometry is taller than video:
              // - Fill vertically (maintain y scale)
              // - Scale horizontally to maintain aspect ratio (shrink x)
              uv.x *= aspect;
            }
            
            // Return to 0-1 range
            uv = uv + 0.5;
          }
          // CONTAIN MODE (uFit = 2.0)
          else if (abs(uFit - 2.0) < 0.01) {
            // Center the UV coordinates
            uv = uv - 0.5;
            
            if (aspect > 1.0) {
              // Geometry is wider than video:
              // - Fill vertically (maintain y scale)
              // - Scale horizontally to fit entire video (expand x)
              uv.x *= aspect;
            } else {
              // Geometry is taller than video:
              // - Fill horizontally (maintain x scale)
              // - Scale vertically to fit entire video (expand y)
              uv.y /= aspect;
            }
            
            // Return to 0-1 range
            uv = uv + 0.5;
          }
          
          // pull UV into [0,1] before sampling
          vec2 uvClamped = clamp(uv, 0.0, 1.0);
          vec4 col = texture2D(uMap, uvClamped);

          // outside coloring (for contain mode)
          if (uFit >= 1.5) {
            const float EPS = 0.005;
            // decide \u201Coutside\u201D based on the *raw* uv
            bool outside = uv.x < -EPS || uv.x > 1.0 + EPS || uv.y < -EPS || uv.y > 1.0 + EPS;
            if (outside) {
              col = uTransparent > 0.5 ? vec4(0.0, 0.0, 0.0, 0.0) : vec4(uColor, 1.0);
            }
          } 

          csm_DiffuseColor = col;
        }
      `
    });
    this.ctx.world.setupMaterial(material2);
    this.mesh = new three_exports.Mesh(geometry, material2);
    this.mesh.castShadow = this._castShadow;
    this.mesh.receiveShadow = this._receiveShadow;
    this.mesh.matrixWorld.copy(this.matrixWorld);
    this.mesh.matrixAutoUpdate = false;
    this.mesh.matrixWorldAutoUpdate = false;
    this.ctx.world.stage.scene.add(this.mesh);
    this.sItem = {
      matrix: this.matrixWorld,
      geometry,
      material: material2,
      getEntity: () => this.ctx.entity,
      node: this
    };
    this.ctx.world.stage.octree.insert(this.sItem);
  }
  unbuild() {
    this.n++;
    if (this.mesh) {
      this.ctx.world.stage.scene.remove(this.mesh);
      this.mesh.material.dispose();
      this.mesh.geometry.dispose();
      this.mesh = null;
    }
    if (this.sItem) {
      this.ctx.world.stage.octree.remove(this.sItem);
      this.sItem = null;
    }
  }
  get src() {
    return this._src;
  }
  set src(value = defaults6.src) {
    if (value !== null && !isString3(value)) {
      throw new Error("[image] src not null or string");
    }
    if (this._src === value) return;
    this._src = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get width() {
    return this._width;
  }
  set width(value = defaults6.width) {
    if (value !== null && !isNumber5(value)) {
      throw new Error("[image] width not null or number");
    }
    if (this._width === value) return;
    this._width = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get height() {
    return this._height;
  }
  set height(value = defaults6.height) {
    if (value !== null && !isNumber5(value)) {
      throw new Error("[image] height not null or number");
    }
    if (this._height === value) return;
    this._height = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get fit() {
    return this._fit;
  }
  set fit(value = defaults6.fit) {
    if (!isFit2(value)) {
      throw new Error("[image] fit invalid");
    }
    if (this._fit === value) return;
    this._fit = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get color() {
    return this._color;
  }
  set color(value = defaults6.color) {
    if (value !== null && !isString3(value)) {
      throw new Error("[image] color not null or string");
    }
    if (this._color === value) return;
    this._color = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get pivot() {
    return this._pivot;
  }
  set pivot(value = defaults6.pivot) {
    if (!isPivot2(value)) {
      throw new Error("[image] pivot invalid");
    }
    if (this._pivot === value) return;
    this._pivot = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get lit() {
    return this._lit;
  }
  set lit(value = defaults6.lit) {
    if (!isBoolean6(value)) {
      throw new Error("[image] lit not a boolean");
    }
    if (this._lit === value) return;
    this._lit = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get doubleside() {
    return this._doubleside;
  }
  set doubleside(value = defaults6.doubleside) {
    if (!isBoolean6(value)) {
      throw new Error("[image] doubleside not a boolean");
    }
    if (this._doubleside === value) return;
    this._doubleside = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get castShadow() {
    return this._castShadow;
  }
  set castShadow(value = defaults6.castShadow) {
    if (!isBoolean6(value)) {
      throw new Error("[image] castShadow not a boolean");
    }
    if (this._castShadow === value) return;
    this._castShadow = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get receiveShadow() {
    return this._receiveShadow;
  }
  set receiveShadow(value = defaults6.receiveShadow) {
    if (!isBoolean6(value)) {
      throw new Error("[image] receiveShadow not a boolean");
    }
    if (this._receiveShadow === value) return;
    this._receiveShadow = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  getProxy() {
    if (!this.proxy) {
      const self2 = this;
      let proxy = {
        get src() {
          return self2.src;
        },
        set src(value) {
          self2.src = value;
        },
        get width() {
          return self2.width;
        },
        set width(value) {
          self2.width = value;
        },
        get height() {
          return self2.height;
        },
        set height(value) {
          self2.height = value;
        },
        get fit() {
          return self2.fit;
        },
        set fit(value) {
          self2.fit = value;
        },
        get color() {
          return self2.color;
        },
        set color(value) {
          self2.color = value;
        },
        get pivot() {
          return self2.pivot;
        },
        set pivot(value) {
          self2.pivot = value;
        },
        get lit() {
          return self2.lit;
        },
        set lit(value) {
          self2.lit = value;
        },
        get doubleside() {
          return self2.doubleside;
        },
        set doubleside(value) {
          self2.doubleside = value;
        },
        get castShadow() {
          return self2.castShadow;
        },
        set castShadow(value) {
          self2.castShadow = value;
        },
        get receiveShadow() {
          return self2.receiveShadow;
        },
        set receiveShadow(value) {
          self2.receiveShadow = value;
        }
      };
      proxy = Object.defineProperties(proxy, Object.getOwnPropertyDescriptors(super.getProxy()));
      this.proxy = proxy;
    }
    return this.proxy;
  }
};
function isFit2(value) {
  return fits2.includes(value);
}
function isPivot2(value) {
  return pivots2.includes(value);
}
function applyPivot2(geometry, width, height, pivot) {
  if (pivot === "center") return;
  let offsetX = 0;
  let offsetY = 0;
  if (pivot.includes("left")) {
    offsetX = width / 2;
  } else if (pivot.includes("right")) {
    offsetX = -width / 2;
  }
  if (pivot.includes("top")) {
    offsetY = -height / 2;
  } else if (pivot.includes("bottom")) {
    offsetY = height / 2;
  }
  if (offsetX !== 0 || offsetY !== 0) {
    geometry.translate(offsetX, offsetY, 0);
  }
}
function applyFit(texture, width, height, fit) {
  if (fit === "none") return;
  const containerAspect = width / height;
  const imageAspect = texture.image.width / texture.image.height;
  let scaleX = 1;
  let scaleY = 1;
  if (fit === "contain") {
    if (imageAspect > containerAspect) {
      scaleY = containerAspect / imageAspect;
      texture.offset.y = (1 - scaleY) / 2;
    } else {
      scaleX = imageAspect / containerAspect;
      texture.offset.x = (1 - scaleX) / 2;
    }
  } else if (fit === "cover") {
    if (imageAspect > containerAspect) {
      scaleX = containerAspect / imageAspect;
      texture.offset.x = (1 - 1 / scaleX) / 2;
      scaleX = 1 / scaleX;
    } else {
      scaleY = imageAspect / containerAspect;
      texture.offset.y = (1 - 1 / scaleY) / 2;
      scaleY = 1 / scaleY;
    }
  }
  texture.repeat.set(scaleX, scaleY);
  texture.needsUpdate = true;
}

// src/core/nodes/Snap.js
var Snap = class extends Node {
  constructor(data = {}) {
    super(data);
    this.name = "snap";
    this.worldPosition = new Vector3Enhanced();
  }
  mount() {
    this.worldPosition.setFromMatrixPosition(this.matrixWorld);
    this.handle = this.ctx.world.snaps?.create(this.worldPosition, !this.ctx.moving);
  }
  commit(didMove) {
    if (didMove) {
      this.worldPosition.setFromMatrixPosition(this.matrixWorld);
      this.handle?.move();
    }
  }
  unmount() {
    this.handle?.destroy();
    this.handle = null;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    return this;
  }
  getProxy() {
    if (!this.proxy) {
      let proxy = {
        // ...
      };
      proxy = Object.defineProperties(proxy, Object.getOwnPropertyDescriptors(super.getProxy()));
      this.proxy = proxy;
    }
    return this.proxy;
  }
};

// src/core/nodes/Avatar.js
import { isString as isString4 } from "lodash-es";
import * as THREE3 from "three";
var defaults7 = {
  src: null,
  emote: null,
  onLoad: null
};
var Avatar = class extends Node {
  constructor(data = {}) {
    super(data);
    this.name = "avatar";
    this.src = data.src;
    this.emote = data.emote;
    this.onLoad = data.onLoad;
    this.factory = data.factory;
    this.hooks = data.hooks;
    this.instance = null;
    this.n = 0;
  }
  async mount() {
    this.needsRebuild = false;
    if (this._src) {
      const n6 = ++this.n;
      let avatar = this.ctx.world.loader.get("avatar", this._src);
      if (!avatar) avatar = await this.ctx.world.loader.load("avatar", this._src);
      if (this.n !== n6) return;
      this.factory = avatar?.factory;
      this.hooks = avatar?.hooks;
    }
    if (this.factory) {
      this.instance = this.factory.create(this.matrixWorld, this.hooks, this);
      this.instance.setEmote(this._emote);
      this.ctx.world?.setHot(this.instance, true);
      this.onLoad?.();
    }
  }
  commit(didMove) {
    if (this.needsRebuild) {
      this.unmount();
      this.mount();
    }
    if (didMove) {
      this.instance?.move(this.matrixWorld);
    }
  }
  unmount() {
    this.n++;
    if (this.instance) {
      this.ctx.world?.setHot(this.instance, false);
      this.instance.destroy();
      this.instance = null;
    }
  }
  applyStats(stats) {
    this.factory?.applyStats(stats);
  }
  get src() {
    return this._src;
  }
  set src(value = defaults7.src) {
    if (value !== null && !isString4(value)) {
      throw new Error("[avatar] src not a string");
    }
    if (this._src === value) return;
    this._src = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get emote() {
    return this._emote;
  }
  set emote(value = defaults7.emote) {
    if (value !== null && !isString4(value)) {
      throw new Error("[avatar] emote not a string");
    }
    if (this._emote === value) return;
    this._emote = value;
    this.instance?.setEmote(value);
  }
  get onLoad() {
    return this._onLoad;
  }
  set onLoad(value) {
    this._onLoad = value;
  }
  getHeight() {
    return this.instance?.height || null;
  }
  getHeadToHeight() {
    return this.instance?.headToHeight || null;
  }
  getBoneTransform(boneName) {
    return this.instance?.getBoneTransform(boneName);
  }
  setEmote(url) {
    this.emote = url;
  }
  get height() {
    return this.getHeight();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this._src = source._src;
    this._emote = source._emote;
    this._onLoad = source._onLoad;
    this.factory = source.factory;
    this.hooks = source.hooks;
    return this;
  }
  getProxy() {
    if (!this.proxy) {
      const self2 = this;
      let proxy = {
        get src() {
          return self2.src;
        },
        set src(value) {
          self2.src = value;
        },
        get emote() {
          return self2.emote;
        },
        set emote(value) {
          self2.emote = value;
        },
        get onLoad() {
          return self2.onLoad;
        },
        set onLoad(value) {
          self2.onLoad = value;
        },
        getHeight() {
          return self2.getHeight();
        },
        getHeadToHeight() {
          return self2.getHeadToHeight();
        },
        getBoneTransform(boneName) {
          return self2.getBoneTransform(boneName);
        },
        setEmote(url) {
          return self2.setEmote(url);
        },
        get height() {
          return self2.height;
        }
      };
      proxy = Object.defineProperties(proxy, Object.getOwnPropertyDescriptors(super.getProxy()));
      this.proxy = proxy;
    }
    return this.proxy;
  }
};

// src/core/nodes/Action.js
import { isFunction as isFunction2, isNumber as isNumber6, isString as isString5 } from "lodash-es";
var defaults8 = {
  label: "Interact",
  distance: 3,
  duration: 0.5,
  onStart: () => {
  },
  onTrigger: () => {
  },
  onCancel: () => {
  }
};
var Action = class extends Node {
  constructor(data = {}) {
    super(data);
    this.name = "action";
    this.label = data.label;
    this.distance = data.distance;
    this.duration = data.duration;
    this.onStart = data.onStart;
    this.onTrigger = data.onTrigger;
    this.onCancel = data.onCancel;
    this.worldPos = new Vector3Enhanced();
    this.progress = 0;
  }
  mount() {
    this.ctx.world.actions?.register(this);
    this.worldPos.setFromMatrixPosition(this.matrixWorld);
  }
  commit(didMove) {
    if (didMove) {
      this.worldPos.setFromMatrixPosition(this.matrixWorld);
    }
  }
  unmount() {
    this.ctx.world.actions?.unregister(this);
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this._label = source._label;
    this._distance = source._distance;
    this._duration = source._duration;
    this._onStart = source._onStart;
    this._onTrigger = source._onTrigger;
    this._onCancel = source._onCancel;
    return this;
  }
  get label() {
    return this._label;
  }
  set label(value) {
    this._label = isString5(value) ? value : isNumber6(value) ? value + "" : defaults8.label;
  }
  get distance() {
    return this._distance;
  }
  set distance(value = defaults8.distance) {
    if (!isNumber6(value)) {
      throw new Error("[action] distance not a number");
    }
    this._distance = value;
  }
  get duration() {
    return this._duration;
  }
  set duration(value = defaults8.duration) {
    if (!isNumber6(value)) {
      throw new Error("[action] duration not a number");
    }
    this._duration = value;
  }
  get onStart() {
    return this._onStart;
  }
  set onStart(value = defaults8.onStart) {
    if (!isFunction2(value)) {
      throw new Error("[action] onStart not a function");
    }
    this._onStart = value;
  }
  get onTrigger() {
    return this._onTrigger;
  }
  set onTrigger(value = defaults8.onTrigger) {
    if (!isFunction2(value)) {
      throw new Error("[action] onTrigger not a function");
    }
    this._onTrigger = value;
  }
  get onCancel() {
    return this._onCancel;
  }
  set onCancel(value = defaults8.onCancel) {
    if (!isFunction2(value)) {
      throw new Error("[action] onCancel not a function");
    }
    this._onCancel = value;
  }
  getProxy() {
    var self2 = this;
    if (!this.proxy) {
      let proxy = {
        get label() {
          return self2.label;
        },
        set label(value) {
          self2.label = value;
        },
        get distance() {
          return self2.distance;
        },
        set distance(value) {
          self2.distance = value;
        },
        get duration() {
          return self2.duration;
        },
        set duration(value) {
          self2.duration = value;
        },
        get onStart() {
          return self2.onStart;
        },
        set onStart(value) {
          self2.onStart = value;
        },
        get onTrigger() {
          return self2.onTrigger;
        },
        set onTrigger(value) {
          self2.onTrigger = value;
        },
        get onCancel() {
          return self2.onCancel;
        },
        set onCancel(value) {
          self2.onCancel = value;
        }
      };
      proxy = Object.defineProperties(proxy, Object.getOwnPropertyDescriptors(super.getProxy()));
      this.proxy = proxy;
    }
    return this.proxy;
  }
};

// src/core/nodes/Anchor.js
var Anchor = class extends Node {
  constructor(data = {}) {
    super(data);
    this.name = "anchor";
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    return this;
  }
  mount() {
    this.anchorId = `${this.ctx?.entity?.data.id || ""}:${this.id}`;
    this.ctx.world.anchors.add(this.anchorId, this.matrixWorld);
  }
  unmount() {
    this.ctx.world.anchors.remove(this.anchorId);
  }
  getProxy() {
    if (!this.proxy) {
      const self2 = this;
      let proxy = {
        get anchorId() {
          return self2.anchorId;
        }
      };
      proxy = Object.defineProperties(proxy, Object.getOwnPropertyDescriptors(super.getProxy()));
      this.proxy = proxy;
    }
    return this.proxy;
  }
};

// src/core/nodes/Nametag.js
import { isNumber as isNumber7, isString as isString6 } from "lodash-es";
var defaults9 = {
  label: "...",
  health: 100
};
var Nametag = class extends Node {
  constructor(data = {}) {
    super(data);
    this.name = "nametag";
    this.label = data.label;
    this.health = data.health;
  }
  mount() {
    if (this.ctx.world.nametags) {
      this.handle = this.ctx.world.nametags.add({ name: this._label, health: this._health });
      this.handle?.move(this.matrixWorld);
    }
  }
  commit(didMove) {
    if (didMove) {
      this.handle?.move(this.matrixWorld);
    }
  }
  unmount() {
    this.handle?.destroy();
    this.handle = null;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this._label = source._label;
    return this;
  }
  get label() {
    return this._label;
  }
  set label(value = defaults9.label) {
    if (isNumber7(value)) {
      value = value + "";
    }
    if (!isString6(value)) {
      throw new Error("[nametag] label invalid");
    }
    if (this._label === value) return;
    this._label = value;
    this.handle?.setName(value);
  }
  get health() {
    return this._health;
  }
  set health(value = defaults9.health) {
    if (!isNumber7(value)) {
      throw new Error("[nametag] health not a number");
    }
    if (this._health === value) return;
    this._health = value;
    this.handle?.setHealth(value);
  }
  getProxy() {
    var self2 = this;
    if (!this.proxy) {
      let proxy = {
        get label() {
          return self2.label;
        },
        set label(value) {
          self2.label = value;
        },
        get health() {
          return self2.health;
        },
        set health(value) {
          self2.health = value;
        }
      };
      proxy = Object.defineProperties(proxy, Object.getOwnPropertyDescriptors(super.getProxy()));
      this.proxy = proxy;
    }
    return this.proxy;
  }
};

// src/core/nodes/Particles.js
import { every as every2, isArray as isArray2, isBoolean as isBoolean7, isFunction as isFunction3, isNumber as isNumber8, isString as isString7 } from "lodash-es";
var shapeTypes = ["point", "sphere", "hemisphere", "cone", "box", "circle", "rectangle"];
var spaces = ["local", "world"];
var blendings = ["additive", "normal"];
var billboards = ["full", "y", "direction"];
var defaults10 = {
  // emitter
  emitting: true,
  shape: ["cone", 1, 1, 25],
  direction: 0,
  // 0 = no direction randomization, 1 = completely randomize direction
  rate: 10,
  // number of particles emitted per second
  bursts: [],
  // bursts of particles at specific times – { time: 0, count: 10 }
  duration: 5,
  // how long particles emit for (null forever)
  loop: true,
  // start again after duration ends
  max: 1e3,
  // maximum number of particles before oldest start being used
  timescale: 1,
  // override to increase/decrease emitter time scale
  // initial values (see start format)
  life: "5",
  // particle lifetime
  speed: "1",
  // particle start speed
  size: "1",
  // particle start size
  rotate: "0",
  // particle start rotation (degrees)
  color: "white",
  // particle start color
  alpha: "1",
  // particle start alpha
  emissive: "1",
  // particle start emissive intensity (bloom)
  // rendering
  image: "/particle.png",
  spritesheet: null,
  // [rows, cols, frameRate, loops]
  blending: "normal",
  // additive or normal (normal requires sorting)
  lit: false,
  // lit or unlit material
  billboard: "full",
  space: "world",
  // world or local space
  // simulation
  force: null,
  // vector3 for gravity, levitation, wind etc
  velocityLinear: null,
  // [x,y,z]
  velocityOrbital: null,
  // [x,y,z]
  velocityRadial: null,
  // number
  rateOverDistance: 0,
  sizeOverLife: null,
  // see lifetime format above for this and the following...
  rotateOverLife: null,
  colorOverLife: null,
  alphaOverLife: null,
  emissiveOverLife: null,
  onEnd: null
};
var Particles = class extends Node {
  constructor(data = {}) {
    super(data);
    this.name = "particles";
    this.emitting = data.emitting;
    this.shape = data.shape;
    this.direction = data.direction;
    this.rate = data.rate;
    this.bursts = data.bursts;
    this.duration = data.duration;
    this.loop = data.loop;
    this.max = data.max;
    this.timescale = data.timescale;
    this.life = data.life;
    this.speed = data.speed;
    this.size = data.size;
    this.rotate = data.rotate;
    this.color = data.color;
    this.alpha = data.alpha;
    this.emissive = data.emissive;
    this.image = data.image;
    this.spritesheet = data.spritesheet;
    this.blending = data.blending;
    this.lit = data.lit;
    this.billboard = data.billboard;
    this.space = data.space;
    this.force = data.force;
    this.velocityLinear = data.velocityLinear;
    this.velocityOrbital = data.velocityOrbital;
    this.velocityRadial = data.velocityRadial;
    this.rateOverDistance = data.rateOverDistance;
    this.sizeOverLife = data.sizeOverLife;
    this.rotateOverLife = data.rotateOverLife;
    this.colorOverLife = data.colorOverLife;
    this.alphaOverLife = data.alphaOverLife;
    this.emissiveOverLife = data.emissiveOverLife;
    this.onEnd = data.onEnd;
  }
  mount() {
    this.needsRebuild = false;
    if (!this.ctx.world.network.isClient) return;
    this.emitter = this.ctx.world.particles.register(this);
  }
  commit(didMove) {
    if (this.needsRebuild) {
      this.unmount();
      this.mount();
      return;
    }
    if (didMove) {
    }
  }
  unmount() {
    this.emitter?.destroy();
    this.emitter = null;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this._emitting = source._emitting;
    this._shape = source._shape;
    this._direction = source._direction;
    this._rate = source._rate;
    this._bursts = source._bursts;
    this._duration = source._duration;
    this._loop = source._loop;
    this._max = source._max;
    this._timescale = source._timescale;
    this._life = source._life;
    this._speed = source._speed;
    this._size = source._size;
    this._rotate = source._rotate;
    this._color = source._color;
    this._alpha = source._alpha;
    this._emissive = source._emissive;
    this._image = source._image;
    this._spritesheet = source._spritesheet;
    this._blending = source._blending;
    this._lit = source._lit;
    this._billboard = source._billboard;
    this._space = source._space;
    this._force = source._force;
    this._velocityLinear = source._velocityLinear;
    this._velocityOrbital = source._velocityOrbital;
    this._velocityRadial = source._velocityRadial;
    this._rateOverDistance = source._rateOverDistance;
    this._sizeOverLife = source._sizeOverLife;
    this._rotateOverLife = source._rotateOverLife;
    this._colorOverLife = source._colorOverLife;
    this._alphaOverLife = source._alphaOverLife;
    this._emissiveOverLife = source._emissiveOverLife;
    this._onEnd = source._onEnd;
    return this;
  }
  getConfig() {
    const config3 = {
      emitting: this._emitting,
      shape: this._shape,
      direction: this._direction,
      rate: this._rate,
      bursts: this._bursts,
      duration: this._duration,
      loop: this._loop,
      max: this._max,
      timescale: this._timescale,
      life: this._life,
      speed: this._speed,
      size: this._size,
      rotate: this._rotate,
      color: this._color,
      alpha: this._alpha,
      emissive: this._emissive,
      image: this._image,
      spritesheet: this._spritesheet,
      blending: this._blending,
      lit: this._lit,
      billboard: this._billboard,
      space: this._space,
      force: this._force?.toArray() || null,
      velocityLinear: this._velocityLinear?.toArray() || null,
      velocityOrbital: this._velocityOrbital?.toArray() || null,
      velocityRadial: this._velocityRadial,
      rateOverDistance: this._rateOverDistance,
      sizeOverLife: this._sizeOverLife,
      rotateOverLife: this._rotateOverLife,
      colorOverLife: this._colorOverLife,
      alphaOverLife: this._alphaOverLife,
      emissiveOverLife: this._emissiveOverLife
    };
    return config3;
  }
  get emitting() {
    return this._emitting;
  }
  set emitting(value = defaults10.emitting) {
    if (!isBoolean7(value)) {
      throw new Error("[particles] emitting not a boolean");
    }
    if (this._emitting === value) return;
    this._emitting = value;
    this.emitter?.setEmitting(value);
  }
  get shape() {
    return this._shape;
  }
  set shape(value = defaults10.shape) {
    if (!isShape(value)) {
      throw new Error("[particles] shape invalid");
    }
    this._shape = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get direction() {
    return this._direction;
  }
  set direction(value = defaults10.direction) {
    if (!isNumber8(value)) {
      throw new Error("[particles] direction not a number");
    }
    this._direction = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get rate() {
    return this._rate;
  }
  set rate(value = defaults10.rate) {
    if (!isNumber8(value)) {
      throw new Error("[particles] rate not a number");
    }
    this._rate = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get bursts() {
    return this._bursts;
  }
  set bursts(value = defaults10.bursts) {
    if (!isBursts(value)) {
      throw new Error("[particles] bursts invalid");
    }
    this._bursts = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get duration() {
    return this._duration;
  }
  set duration(value = defaults10.duration) {
    if (!isNumber8(value)) {
      throw new Error("[particles] duration not a number");
    }
    this._duration = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get loop() {
    return this._loop;
  }
  set loop(value = defaults10.loop) {
    if (!isBoolean7(value)) {
      throw new Error("[particles] loop not a boolean");
    }
    this._loop = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get max() {
    return this._max;
  }
  set max(value = defaults10.max) {
    if (!isNumber8(value)) {
      throw new Error("[particles] max not a number");
    }
    this._max = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get timescale() {
    return this._timescale;
  }
  set timescale(value = defaults10.timescale) {
    if (!isNumber8(value)) {
      throw new Error("[particles] timescale not a number");
    }
    this._timescale = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get life() {
    return this._life;
  }
  set life(value = defaults10.life) {
    if (!isStartNumeric(value)) {
      throw new Error("[particles] life invalid");
    }
    this._life = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get speed() {
    return this._speed;
  }
  set speed(value = defaults10.speed) {
    if (!isStartNumeric(value)) {
      throw new Error("[particles] speed invalid");
    }
    this._speed = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get size() {
    return this._size;
  }
  set size(value = defaults10.size) {
    if (!isStartNumeric(value)) {
      throw new Error("[particles] size invalid");
    }
    this._size = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get rotate() {
    return this._rotate;
  }
  set rotate(value = defaults10.rotate) {
    if (!isStartNumeric(value)) {
      throw new Error("[particles] rotate invalid");
    }
    this._rotate = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get color() {
    return this._color;
  }
  set color(value = defaults10.color) {
    if (!isStartColor(value)) {
      throw new Error("[particles] color invalid");
    }
    this._color = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get alpha() {
    return this._alpha;
  }
  set alpha(value = defaults10.alpha) {
    if (!isStartNumeric(value)) {
      throw new Error("[particles] alpha invalid");
    }
    this._alpha = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get emissive() {
    return this._emissive;
  }
  set emissive(value = defaults10.emissive) {
    if (!isStartNumeric(value)) {
      throw new Error("[particles] emissive invalid");
    }
    this._emissive = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get image() {
    return this._image;
  }
  set image(value = defaults10.image) {
    if (!isString7(value)) {
      throw new Error("[particles] image not a string");
    }
    this._image = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get spritesheet() {
    return this._spritesheet;
  }
  set spritesheet(value = defaults10.spritesheet) {
    if (value !== null && !isSpritesheet(value)) {
      throw new Error("[particles] spritesheet invalid");
    }
    this._spritesheet = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get blending() {
    return this._blending;
  }
  set blending(value = defaults10.blending) {
    if (!isBlending(value)) {
      throw new Error("[particles] blending invalid");
    }
    this._blending = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get lit() {
    return this._lit;
  }
  set lit(value = defaults10.lit) {
    if (!isBoolean7(value)) {
      throw new Error("[particles] lit not a boolean");
    }
    this._lit = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get billboard() {
    return this._billboard;
  }
  set billboard(value = defaults10.billboard) {
    if (!isBillboard(value)) {
      throw new Error("[particles] billboard invalid");
    }
    this._billboard = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get space() {
    return this._space;
  }
  set space(value = defaults10.space) {
    if (value !== null && !isSpace(value)) {
      throw new Error("[particles] space invalid");
    }
    this._space = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get force() {
    return this._force;
  }
  set force(value = defaults10.force) {
    if (value !== null && !value.isVector3) {
      throw new Error("[particles] force not a Vector3");
    }
    this._force = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get velocityLinear() {
    return this._velocityLinear;
  }
  set velocityLinear(value = defaults10.velocityLinear) {
    if (value !== null && !value.isVector3) {
      throw new Error("[particles] velocityLinear not a Vector3");
    }
    this._velocityLinear = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get velocityOrbital() {
    return this._velocityOrbital;
  }
  set velocityOrbital(value = defaults10.velocityOrbital) {
    if (value !== null && !value.isVector3) {
      throw new Error("[particles] velocityOrbital not a Vector3");
    }
    this._velocityOrbital = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get velocityRadial() {
    return this._velocityRadial;
  }
  set velocityRadial(value = defaults10.velocityRadial) {
    if (value !== null && !isNumber8(value)) {
      throw new Error("[particles] velocityRadial not a number");
    }
    this._velocityRadial = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get rateOverDistance() {
    return this._rateOverDistance;
  }
  set rateOverDistance(value = defaults10.rateOverDistance) {
    if (!isNumber8(value)) {
      throw new Error("[particles] rateOverDistance not a number");
    }
    this._rateOverDistance = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get sizeOverLife() {
    return this._sizeOverLife;
  }
  set sizeOverLife(value = defaults10.sizeOverLife) {
    if (value !== null && !isString7(value)) {
      throw new Error("[particles] sizeOverLife invalid");
    }
    this._sizeOverLife = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get rotateOverLife() {
    return this._rotateOverLife;
  }
  set rotateOverLife(value = defaults10.rotateOverLife) {
    if (value !== null && !isString7(value)) {
      throw new Error("[particles] rotateOverLife invalid");
    }
    this._rotateOverLife = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get colorOverLife() {
    return this._colorOverLife;
  }
  set colorOverLife(value = defaults10.colorOverLife) {
    if (value !== null && !isString7(value)) {
      throw new Error("[particles] colorOverLife invalid");
    }
    this._colorOverLife = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get alphaOverLife() {
    return this._alphaOverLife;
  }
  set alphaOverLife(value = defaults10.alphaOverLife) {
    if (value !== null && !isString7(value)) {
      throw new Error("[particles] alphaOverLife invalid");
    }
    this._alphaOverLife = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get emissiveOverLife() {
    return this._emissiveOverLife;
  }
  set emissiveOverLife(value = defaults10.emissiveOverLife) {
    if (value !== null && !isString7(value)) {
      throw new Error("[particles] emissiveOverLife invalid");
    }
    this._emissiveOverLife = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get onEnd() {
    return this._onEnd;
  }
  set onEnd(value = defaults10.onEnd) {
    this._onEnd = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  getProxy() {
    var self2 = this;
    if (!this.proxy) {
      let proxy = {
        get emitting() {
          return self2.emitting;
        },
        set emitting(value) {
          self2.emitting = value;
        },
        get shape() {
          return self2.shape;
        },
        set shape(value) {
          self2.shape = value;
        },
        get direction() {
          return self2.direction;
        },
        set direction(value) {
          self2.direction = value;
        },
        get rate() {
          return self2.rate;
        },
        set rate(value) {
          self2.rate = value;
        },
        get bursts() {
          return self2.bursts;
        },
        set bursts(value) {
          self2.bursts = value;
        },
        get duration() {
          return self2.duration;
        },
        set duration(value) {
          self2.duration = value;
        },
        get loop() {
          return self2.loop;
        },
        set loop(value) {
          self2.loop = value;
        },
        get max() {
          return self2.max;
        },
        set max(value) {
          self2.max = value;
        },
        get timescale() {
          return self2.timescale;
        },
        set timescale(value) {
          self2.timescale = value;
        },
        get life() {
          return self2.life;
        },
        set life(value) {
          self2.life = value;
        },
        get speed() {
          return self2.speed;
        },
        set speed(value) {
          self2.speed = value;
        },
        get size() {
          return self2.size;
        },
        set size(value) {
          self2.size = value;
        },
        get rotate() {
          return self2.rotate;
        },
        set rotate(value) {
          self2.rotate = value;
        },
        get color() {
          return self2.color;
        },
        set color(value) {
          self2.color = value;
        },
        get alpha() {
          return self2.alpha;
        },
        set alpha(value) {
          self2.alpha = value;
        },
        get emissive() {
          return self2.emissive;
        },
        set emissive(value) {
          self2.emissive = value;
        },
        get image() {
          return self2.image;
        },
        set image(value) {
          self2.image = value;
        },
        get spritesheet() {
          return self2.spritesheet;
        },
        set spritesheet(value) {
          self2.spritesheet = value;
        },
        get blending() {
          return self2.blending;
        },
        set blending(value) {
          self2.blending = value;
        },
        get lit() {
          return self2.lit;
        },
        set lit(value) {
          self2.lit = value;
        },
        get billboard() {
          return self2.billboard;
        },
        set billboard(value) {
          self2.billboard = value;
        },
        get space() {
          return self2.space;
        },
        set space(value) {
          self2.space = value;
        },
        get force() {
          return self2.force;
        },
        set force(value) {
          self2.force = value;
        },
        get velocityLinear() {
          return self2.velocityLinear;
        },
        set velocityLinear(value) {
          self2.velocityLinear = value;
        },
        get velocityOrbital() {
          return self2.velocityOrbital;
        },
        set velocityOrbital(value) {
          self2.velocityOrbital = value;
        },
        get velocityRadial() {
          return self2.velocityRadial;
        },
        set velocityRadial(value) {
          self2.velocityRadial = value;
        },
        get rateOverDistance() {
          return self2.rateOverDistance;
        },
        set rateOverDistance(value) {
          self2.rateOverDistance = value;
        },
        get sizeOverLife() {
          return self2.sizeOverLife;
        },
        set sizeOverLife(value) {
          self2.sizeOverLife = value;
        },
        get rotateOverLife() {
          return self2.rotateOverLife;
        },
        set rotateOverLife(value) {
          self2.rotateOverLife = value;
        },
        get colorOverLife() {
          return self2.colorOverLife;
        },
        set colorOverLife(value) {
          self2.colorOverLife = value;
        },
        get alphaOverLife() {
          return self2.alphaOverLife;
        },
        set alphaOverLife(value) {
          self2.alphaOverLife = value;
        },
        get emissiveOverLife() {
          return self2.emissiveOverLife;
        },
        set emissiveOverLife(value) {
          self2.emissiveOverLife = value;
        },
        get onEnd() {
          return self2.onEnd;
        },
        set onEnd(value) {
          self2.onEnd = value;
        }
      };
      proxy = Object.defineProperties(proxy, Object.getOwnPropertyDescriptors(super.getProxy()));
      this.proxy = proxy;
    }
    return this.proxy;
  }
};
function isShape(value) {
  return isArray2(value) && shapeTypes.includes(value[0]);
}
function isBursts(value) {
  return isArray2(value) && every2(value, (item) => isNumber8(item.time) && isNumber8(item.count));
}
function isStartNumeric(value) {
  return isString7(value);
}
function isStartColor(value) {
  return isString7(value);
}
function isSpritesheet(value) {
  return isArray2(value) && value.length === 4;
}
function isBlending(value) {
  return blendings.includes(value);
}
function isSpace(value) {
  return spaces.includes(value);
}
function isBillboard(value) {
  return billboards.includes(value);
}

// src/core/nodes/Sky.js
import { isNumber as isNumber9, isString as isString8 } from "lodash-es";
var defaults11 = {
  bg: null,
  hdr: null,
  sunDirection: null,
  sunIntensity: null,
  sunColor: null,
  fogNear: null,
  fogFar: null,
  fogColor: null
};
var Sky = class extends Node {
  constructor(data = {}) {
    super(data);
    this.name = "sky";
    this.bg = data.bg;
    this.hdr = data.hdr;
    this.sunDirection = data.sunDirection;
    this.sunIntensity = data.sunIntensity;
    this.sunColor = data.sunColor;
    this.fogNear = data.fogNear;
    this.fogFar = data.fogFar;
    this.fogColor = data.fogColor;
  }
  mount() {
    this.handle = this.ctx.world.environment.addSky?.(this);
  }
  commit(didMove) {
    if (this.needsRebuild) {
      this.handle?.destroy();
      this.handle = this.ctx.world.environment.addSky?.(this);
      this.needsRebuild = false;
    }
  }
  unmount() {
    this.handle?.destroy();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this._bg = source._bg;
    this._hdr = source._hdr;
    this._sunDirection = source._sunDirection;
    this._sunIntensity = source._sunIntensity;
    this._sunColor = source._sunColor;
    return this;
  }
  get bg() {
    return this._bg;
  }
  set bg(value = defaults11.bg) {
    if (value !== null && !isString8(value)) {
      throw new Error("[sky] bg not a string");
    }
    if (this._bg === value) return;
    this._bg = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get hdr() {
    return this._hdr;
  }
  set hdr(value = defaults11.hdr) {
    if (value !== null && !isString8(value)) {
      throw new Error("[sky] hdr not a string");
    }
    if (this._hdr === value) return;
    this._hdr = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get sunDirection() {
    return this._sunDirection;
  }
  set sunDirection(value = defaults11.sunDirection) {
    if (value !== null && !value?.isVector3) {
      throw new Error("[sky] sunDirection not a Vector3");
    }
    if (this._sunDirection === value) return;
    this._sunDirection = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get sunIntensity() {
    return this._sunIntensity;
  }
  set sunIntensity(value = defaults11.sunIntensity) {
    if (value !== null && !isNumber9(value)) {
      throw new Error("[sky] sunIntensity not a number");
    }
    if (this._sunIntensity === value) return;
    this._sunIntensity = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get sunColor() {
    return this._sunColor;
  }
  set sunColor(value = defaults11.sunColor) {
    if (value !== null && !isString8(value)) {
      throw new Error("[sky] sunColor not a string");
    }
    if (this._sunColor === value) return;
    this._sunColor = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get fogNear() {
    return this._fogNear;
  }
  set fogNear(value = defaults11.fogNear) {
    if (value !== null && !isNumber9(value)) {
      throw new Error("[sky] fogNear not a number");
    }
    if (this._fogNear === value) return;
    this._fogNear = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get fogFar() {
    return this._fogFar;
  }
  set fogFar(value = defaults11.fogFar) {
    if (value !== null && !isNumber9(value)) {
      throw new Error("[sky] fogFar not a number");
    }
    if (this._fogFar === value) return;
    this._fogFar = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get fogColor() {
    return this._fogColor;
  }
  set fogColor(value = defaults11.fogColor) {
    if (value !== null && !isString8(value)) {
      throw new Error("[sky] fogColor not a string");
    }
    if (this._fogColor === value) return;
    this._fogColor = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  getProxy() {
    var self2 = this;
    if (!this.proxy) {
      let proxy = {
        get bg() {
          return self2.bg;
        },
        set bg(value) {
          self2.bg = value;
        },
        get hdr() {
          return self2.hdr;
        },
        set hdr(value) {
          self2.hdr = value;
        },
        get sunDirection() {
          return self2.sunDirection;
        },
        set sunDirection(value) {
          self2.sunDirection = value;
        },
        get sunIntensity() {
          return self2.sunIntensity;
        },
        set sunIntensity(value) {
          self2.sunIntensity = value;
        },
        get sunColor() {
          return self2.sunColor;
        },
        set sunColor(value) {
          self2.sunColor = value;
        },
        get fogNear() {
          return self2.fogNear;
        },
        set fogNear(value) {
          self2.fogNear = value;
        },
        get fogFar() {
          return self2.fogFar;
        },
        set fogFar(value) {
          self2.fogFar = value;
        },
        get fogColor() {
          return self2.fogColor;
        },
        set fogColor(value) {
          self2.fogColor = value;
        }
      };
      proxy = Object.defineProperties(proxy, Object.getOwnPropertyDescriptors(super.getProxy()));
      this.proxy = proxy;
    }
    return this.proxy;
  }
};

// src/core/nodes/UI.js
import { every as every3, isArray as isArray3, isBoolean as isBoolean8, isNumber as isNumber10, isString as isString9 } from "lodash-es";
import Yoga2 from "yoga-layout";

// src/core/extras/roundRect.js
function roundRect(ctx, x5, y7, width, height, radius) {
  if (!radius) {
    ctx.rect(x5, y7, width, height);
    return;
  }
  const maxRadius = Math.min(width / 2, height / 2);
  radius = Math.min(radius, maxRadius);
  ctx.moveTo(x5 + radius, y7);
  ctx.lineTo(x5 + width - radius, y7);
  ctx.arc(x5 + width - radius, y7 + radius, radius, -Math.PI / 2, 0);
  ctx.lineTo(x5 + width, y7 + height - radius);
  ctx.arc(x5 + width - radius, y7 + height - radius, radius, 0, Math.PI / 2);
  ctx.lineTo(x5 + radius, y7 + height);
  ctx.arc(x5 + radius, y7 + height - radius, radius, Math.PI / 2, Math.PI);
  ctx.lineTo(x5, y7 + radius);
  ctx.arc(x5 + radius, y7 + radius, radius, Math.PI, Math.PI * 3 / 2);
  ctx.closePath();
}
function fillRoundRect(ctx, x5, y7, width, height, radius, fillStyle) {
  ctx.beginPath();
  roundRect(ctx, x5, y7, width, height, radius);
  ctx.fillStyle = fillStyle;
  ctx.fill();
}
function imageRoundRect(ctx, x5, y7, width, height, radius, img, imgX, imgY, imgWidth, imgHeight) {
  ctx.save();
  ctx.beginPath();
  roundRect(ctx, x5, y7, width, height, radius);
  ctx.clip();
  if (imgX !== void 0 && imgY !== void 0 && imgWidth !== void 0 && imgHeight !== void 0) {
    ctx.drawImage(img, imgX, imgY, imgWidth, imgHeight);
  } else {
    ctx.drawImage(img, x5, y7, width, height);
  }
  ctx.restore();
}

// src/core/extras/yoga.js
import Yoga from "yoga-layout";
var Display = {};
var FlexDirection = {};
var JustifyContent = {};
var AlignItems = {};
var AlignContent = {};
var FlexWrap = {};
var initYoga = () => {
  Display["flex"] = Yoga.DISPLAY_FLEX;
  Display["none"] = Yoga.DISPLAY_NONE;
  FlexDirection["column"] = Yoga.FLEX_DIRECTION_COLUMN;
  FlexDirection["column-reverse"] = Yoga.FLEX_DIRECTION_COLUMN_REVERSE;
  FlexDirection["row"] = Yoga.FLEX_DIRECTION_ROW;
  FlexDirection["row-reverse"] = Yoga.FLEX_DIRECTION_ROW_REVERSE;
  JustifyContent["flex-start"] = Yoga.JUSTIFY_FLEX_START;
  JustifyContent["flex-end"] = Yoga.JUSTIFY_FLEX_END;
  JustifyContent["center"] = Yoga.JUSTIFY_CENTER;
  JustifyContent["space-between"] = Yoga.JUSTIFY_SPACE_BETWEEN;
  JustifyContent["space-around"] = Yoga.JUSTIFY_SPACE_AROUND;
  JustifyContent["space-evenly"] = Yoga.JUSTIFY_SPACE_EVENLY;
  AlignItems["stretch"] = Yoga.ALIGN_STRETCH;
  AlignItems["flex-start"] = Yoga.ALIGN_FLEX_START;
  AlignItems["flex-end"] = Yoga.ALIGN_FLEX_END;
  AlignItems["center"] = Yoga.ALIGN_CENTER;
  AlignItems["baseline"] = Yoga.ALIGN_BASELINE;
  AlignContent["flex-start"] = Yoga.ALIGN_FLEX_START;
  AlignContent["flex-end"] = Yoga.ALIGN_FLEX_END;
  AlignContent["stretch"] = Yoga.ALIGN_STRETCH;
  AlignContent["center"] = Yoga.ALIGN_CENTER;
  AlignContent["space-between"] = Yoga.ALIGN_SPACE_BETWEEN;
  AlignContent["space-around"] = Yoga.ALIGN_SPACE_AROUND;
  AlignContent["space-evenly"] = Yoga.ALIGN_SPACE_EVENLY;
  FlexWrap["no-wrap"] = Yoga.WRAP_NO_WRAP;
  FlexWrap["wrap"] = Yoga.WRAP_WRAP;
  FlexWrap["wrap-reverse"] = Yoga.WRAP_WRAP_REVERSE;
};
var displays = ["flex", "none"];
function isDisplay(value) {
  return displays.includes(value);
}
var flexDirections = ["column", "column-reverse", "row", "row-reverse", "flex-start", "flex-end", "center"];
function isFlexDirection(value) {
  return flexDirections.includes(value);
}
var justifyContents = ["flex-start", "flex-end", "center", "space-between", "space-around", "space-evenly"];
function isJustifyContent(value) {
  return justifyContents.includes(value);
}
var alignItems = ["stretch", "flex-start", "flex-end", "center", "baseline"];
function isAlignItem(value) {
  return alignItems.includes(value);
}
var alignContents = ["flex-start", "flex-end", "stretch", "center", "space-between", "space-around", "space-evenly"];
function isAlignContent(value) {
  return alignContents.includes(value);
}
var flexWraps = ["no-wrap", "wrap", "wrap-reverse"];
function isFlexWrap(value) {
  return flexWraps.includes(value);
}

// src/core/extras/borderRoundRect.js
function borderRoundRect(ctx, x5, y7, width, height, radius, thickness) {
  const insetLeft = x5 + thickness / 2;
  const insetTop = y7 + thickness / 2;
  const insetWidth = width - thickness;
  const insetHeight = height - thickness;
  const adjustedRadius = Math.max(0, radius - thickness / 2);
  ctx.beginPath();
  ctx.moveTo(insetLeft + adjustedRadius, insetTop);
  ctx.lineTo(insetLeft + insetWidth - adjustedRadius, insetTop);
  ctx.arcTo(insetLeft + insetWidth, insetTop, insetLeft + insetWidth, insetTop + adjustedRadius, adjustedRadius);
  ctx.lineTo(insetLeft + insetWidth, insetTop + insetHeight - adjustedRadius);
  ctx.arcTo(
    insetLeft + insetWidth,
    insetTop + insetHeight,
    insetLeft + insetWidth - adjustedRadius,
    insetTop + insetHeight,
    adjustedRadius
  );
  ctx.lineTo(insetLeft + adjustedRadius, insetTop + insetHeight);
  ctx.arcTo(insetLeft, insetTop + insetHeight, insetLeft, insetTop + insetHeight - adjustedRadius, adjustedRadius);
  ctx.lineTo(insetLeft, insetTop + adjustedRadius);
  ctx.arcTo(insetLeft, insetTop, insetLeft + adjustedRadius, insetTop, adjustedRadius);
  ctx.closePath();
  ctx.stroke();
}

// src/core/nodes/UI.js
var v14 = new Vector3Enhanced();
var v23 = new Vector3Enhanced();
var v3 = new Vector3Enhanced();
var v4 = new Vector3Enhanced();
var v5 = new Vector3Enhanced();
var v6 = new Vector3Enhanced();
var q13 = new three_exports.Quaternion();
var q2 = new three_exports.Quaternion();
var e1 = new three_exports.Euler(0, 0, 0, "YXZ");
var m12 = new three_exports.Matrix4();
var FORWARD = new Vector3Enhanced(0, 0, 1);
var iQuaternion = new three_exports.Quaternion(0, 0, 0, 1);
var iScale = new Vector3Enhanced(1, 1, 1);
var spaces2 = ["world", "screen"];
var billboards2 = ["none", "full", "y"];
var pivots3 = [
  "top-left",
  "top-center",
  "top-right",
  "center-left",
  "center",
  "center-right",
  "bottom-left",
  "bottom-center",
  "bottom-right"
];
var defaults12 = {
  space: "world",
  width: 100,
  height: 100,
  size: 0.01,
  res: 2,
  lit: false,
  doubleside: true,
  billboard: "none",
  pivot: "center",
  offset: [0, 0, 0],
  scaler: null,
  pointerEvents: true,
  transparent: true,
  backgroundColor: null,
  borderWidth: 0,
  borderColor: null,
  borderRadius: 0,
  padding: 0,
  flexDirection: "column",
  justifyContent: "flex-start",
  alignItems: "stretch",
  alignContent: "flex-start",
  flexWrap: "no-wrap",
  gap: 0
};
var UI = class extends Node {
  constructor(data = {}) {
    super(data);
    this.name = "ui";
    this.space = data.space;
    this.width = data.width;
    this.height = data.height;
    this.size = data.size;
    this.res = data.res;
    this.lit = data.lit;
    this.doubleside = data.doubleside;
    this.billboard = data.billboard;
    this.pivot = data.pivot;
    this._offset = new Vector3Enhanced().fromArray(data.offset || defaults12.offset);
    this.scaler = data.scaler;
    this.pointerEvents = data.pointerEvents;
    this.transparent = data.transparent;
    this.backgroundColor = data.backgroundColor;
    this.borderWidth = data.borderWidth;
    this.borderColor = data.borderColor;
    this.borderRadius = data.borderRadius;
    this.padding = data.padding;
    this.flexDirection = data.flexDirection;
    this.justifyContent = data.justifyContent;
    this.alignItems = data.alignItems;
    this.alignContent = data.alignContent;
    this.flexWrap = data.flexWrap;
    this.gap = data.gap;
    this.ui = this;
    this._offset._onChange = () => this.rebuild();
  }
  build() {
    this.unbuild();
    this.canvas = document.createElement("canvas");
    this.canvas.width = this._width * this._res;
    this.canvas.height = this._height * this._res;
    this.canvasCtx = this.canvas.getContext("2d");
    if (this._space === "world") {
      this.texture = new three_exports.CanvasTexture(this.canvas);
      this.texture.colorSpace = three_exports.SRGBColorSpace;
      this.texture.anisotropy = this.ctx.world.graphics.maxAnisotropy;
      this.geometry = new three_exports.PlaneGeometry(this._width, this._height);
      this.geometry.scale(this._size, this._size, this._size);
      pivotGeometry(this._pivot, this.geometry, this._width * this._size, this._height * this._size);
      this.pivotOffset = getPivotOffset(this._pivot, this._width, this._height);
      this.material = this.createMaterial(this._lit, this.texture, this._transparent, this._doubleside);
      this.mesh = new three_exports.Mesh(this.geometry, this.material);
      this.mesh.matrixAutoUpdate = false;
      this.mesh.matrixWorldAutoUpdate = false;
      this.mesh.matrixWorld.copy(this.matrixWorld);
      this.ctx.world.stage.scene.add(this.mesh);
      if (this._pointerEvents) {
        this.sItem = {
          matrix: this.mesh.matrixWorld,
          geometry: this.geometry,
          material: this.material,
          getEntity: () => this.ctx.entity,
          node: this
        };
        this.ctx.world.stage.octree.insert(this.sItem);
      }
      this.ctx.world.setHot(this, true);
    } else {
      this.canvas.style.position = "absolute";
      this.canvas.style.width = this._width + "px";
      this.canvas.style.height = this._height + "px";
      pivotCanvas(this._pivot, this.canvas, this._width, this._height);
      this.canvas.style.left = `calc(${this.position.x * 100}% + ${this._offset.x}px)`;
      this.canvas.style.top = `calc(${this.position.y * 100}% + ${this._offset.y}px)`;
      this.canvas.style.pointerEvents = this._pointerEvents ? "auto" : "none";
      if (this._pointerEvents) {
        let hit;
        const canvas = this.canvas;
        const world2 = this.ctx.world;
        const onPointerEnter = (e7) => {
          hit = {
            node: this,
            coords: new Vector3Enhanced(0, 0, 0)
          };
          world2.pointer.setScreenHit(hit);
        };
        const onPointerMove = (e7) => {
          const rect = canvas.getBoundingClientRect();
          const x5 = (e7.clientX - rect.left) * this._res;
          const y7 = (e7.clientY - rect.top) * this._res;
          hit.coords.x = x5;
          hit.coords.y = y7;
        };
        const onPointerLeave = (e7) => {
          hit = null;
          world2.pointer.setScreenHit(null);
        };
        canvas.addEventListener("pointerenter", onPointerEnter);
        canvas.addEventListener("pointermove", onPointerMove);
        canvas.addEventListener("pointerleave", onPointerLeave);
        this.cleanupPointer = () => {
          if (hit) world2.pointer.setScreenHit(null);
          canvas.removeEventListener("pointerenter", onPointerEnter);
          canvas.removeEventListener("pointermove", onPointerMove);
          canvas.removeEventListener("pointerleave", onPointerLeave);
        };
      }
      this.ctx.world.pointer.ui.prepend(this.canvas);
    }
    this.needsRebuild = false;
  }
  unbuild() {
    if (this.mesh) {
      this.ctx.world.stage.scene.remove(this.mesh);
      this.texture.dispose();
      this.mesh.material.dispose();
      this.mesh.geometry.dispose();
      this.mesh = null;
      this.canvas = null;
      if (this.sItem) {
        this.ctx.world.stage.octree.remove(this.sItem);
        this.sItem = null;
      }
      this.ctx.world.setHot(this, false);
    }
    if (this.canvas) {
      this.ctx.world.pointer.ui.removeChild(this.canvas);
      this.canvas = null;
    }
    this.cleanupPointer?.();
    this.cleanupPointer = null;
  }
  draw() {
    this.yogaNode.calculateLayout(this._width * this._res, this._height * this._res, Yoga2.DIRECTION_LTR);
    const ctx = this.canvasCtx;
    ctx.clearRect(0, 0, this._width * this._res, this._height * this._res);
    const left = this.yogaNode.getComputedLeft();
    const top = this.yogaNode.getComputedTop();
    const width = this.yogaNode.getComputedWidth();
    const height = this.yogaNode.getComputedHeight();
    if (this._backgroundColor) {
      const inset = this._borderColor && this._borderWidth ? 1 * this._res : 0;
      const radius = Math.max(0, this._borderRadius * this._res - inset);
      const insetLeft = left + inset;
      const insetTop = top + inset;
      const insetWidth = width - inset * 2;
      const insetHeight = height - inset * 2;
      fillRoundRect(ctx, insetLeft, insetTop, insetWidth, insetHeight, radius, this._backgroundColor);
    }
    if (this._borderWidth && this._borderColor) {
      const radius = this._borderRadius * this._res;
      const thickness = this._borderWidth * this._res;
      ctx.strokeStyle = this._borderColor;
      ctx.lineWidth = thickness;
      if (this._borderRadius) {
        borderRoundRect(ctx, left, top, width, height, radius, thickness);
      } else {
        const insetLeft = left + thickness / 2;
        const insetTop = top + thickness / 2;
        const insetWidth = width - thickness;
        const insetHeight = height - thickness;
        ctx.strokeRect(insetLeft, insetTop, insetWidth, insetHeight);
      }
    }
    this.box = { left, top, width, height };
    this.children.forEach((child) => child.draw(ctx, left, top));
    if (this.texture) this.texture.needsUpdate = true;
    this.needsRedraw = false;
  }
  mount() {
    if (this.ctx.world.network.isServer) return;
    if (this.parent?.ui) return console.error("ui: cannot be nested inside another ui");
    this.yogaNode = Yoga2.Node.create();
    this.yogaNode.setWidth(this._width * this._res);
    this.yogaNode.setHeight(this._height * this._res);
    this.yogaNode.setBorder(Yoga2.EDGE_ALL, this._borderWidth * this._res);
    if (isArray3(this._padding)) {
      const [top, right, bottom, left] = this._padding;
      this.yogaNode.setPadding(Yoga2.EDGE_TOP, top * this._res);
      this.yogaNode.setPadding(Yoga2.EDGE_RIGHT, right * this._res);
      this.yogaNode.setPadding(Yoga2.EDGE_BOTTOM, bottom * this._res);
      this.yogaNode.setPadding(Yoga2.EDGE_LEFT, left * this._res);
    } else {
      this.yogaNode.setPadding(Yoga2.EDGE_ALL, this._padding * this._res);
    }
    this.yogaNode.setFlexDirection(FlexDirection[this._flexDirection]);
    this.yogaNode.setJustifyContent(JustifyContent[this._justifyContent]);
    this.yogaNode.setAlignItems(AlignItems[this._alignItems]);
    this.yogaNode.setAlignContent(AlignContent[this._alignContent]);
    this.yogaNode.setFlexWrap(FlexWrap[this._flexWrap]);
    this.yogaNode.setGap(Yoga2.GUTTER_ALL, this._gap * this._res);
    this.build();
    this.needsRedraw = true;
    this.setDirty();
  }
  commit(didMove) {
    if (this.ctx.world.network.isServer) {
      return;
    }
    if (this.needsRebuild) {
      this.build();
    }
    if (this.needsRedraw) {
      this.draw();
    }
    if (didMove) {
    }
  }
  lateUpdate(delta) {
    if (this._space === "world") {
      const world2 = this.ctx.world;
      const camera = world2.camera;
      const camPosition = v14.setFromMatrixPosition(camera.matrixWorld);
      const uiPosition = v23.setFromMatrixPosition(this.matrixWorld);
      const distance = camPosition.distanceTo(uiPosition);
      this.mesh.renderOrder = -distance;
      const pos = v3;
      const qua = q13;
      const sca = v4;
      this.matrixWorld.decompose(pos, qua, sca);
      if (this._billboard === "full") {
        if (world2.xr.session) {
          v5.subVectors(camPosition, pos).normalize();
          qua.setFromUnitVectors(FORWARD, v5);
          e1.setFromQuaternion(qua);
          e1.z = 0;
          qua.setFromEuler(e1);
        } else {
          qua.copy(world2.rig.quaternion);
        }
      } else if (this._billboard === "y") {
        if (world2.xr.session) {
          v5.subVectors(camPosition, pos).normalize();
          qua.setFromUnitVectors(FORWARD, v5);
          e1.setFromQuaternion(qua);
          e1.x = 0;
          e1.z = 0;
          qua.setFromEuler(e1);
        } else {
          e1.setFromQuaternion(world2.rig.quaternion);
          e1.x = 0;
          e1.z = 0;
          qua.setFromEuler(e1);
        }
      }
      if (this._scaler) {
        const worldToScreenFactor = world2.graphics.worldToScreenFactor;
        const [minDistance, maxDistance, baseScale = 1] = this._scaler;
        const clampedDistance = clamp(distance, minDistance, maxDistance);
        let scaleFactor = baseScale * (worldToScreenFactor * clampedDistance) / this._size;
        sca.setScalar(scaleFactor);
      }
      this.matrixWorld.compose(pos, qua, sca);
      this.mesh.matrixWorld.copy(this.matrixWorld);
      if (this.sItem) {
        world2.stage.octree.move(this.sItem);
      }
    }
  }
  unmount() {
    if (this.ctx.world.network.isServer) return;
    this.unbuild();
    this.needRebuild = false;
    this.needsRedraw = false;
    this.yogaNode?.free();
    this.yogaNode = null;
    this.box = null;
  }
  rebuild() {
    this.needsRebuild = true;
    this.needsRedraw = true;
    this.setDirty();
  }
  redraw() {
    this.needsRedraw = true;
    this.setDirty();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this._space = source._space;
    this._width = source._width;
    this._height = source._height;
    this._size = source._size;
    this._res = source._res;
    this._lit = source._lit;
    this._doubleside = source._doubleside;
    this._billboard = source._billboard;
    this._pivot = source._pivot;
    this._offset = source._offset;
    this._scaler = source._scaler;
    this._pointerEvents = source._pointerEvents;
    this._transparent = source._transparent;
    this._backgroundColor = source._backgroundColor;
    this._borderWidth = source._borderWidth;
    this._borderColor = source._borderColor;
    this._borderRadius = source._borderRadius;
    this._padding = source._padding;
    this._flexDirection = source._flexDirection;
    this._justifyContent = source._justifyContent;
    this._alignItems = source._alignItems;
    this._alignContent = source._alignContent;
    this._flexWrap = source._flexWrap;
    this._gap = source._gap;
    return this;
  }
  resolveHit(hit) {
    if (hit?.point) {
      const inverseMatrix = m12.copy(this.mesh.matrixWorld).invert();
      v14.copy(hit.point).applyMatrix4(inverseMatrix).multiplyScalar(1 / this._size).sub(this.pivotOffset);
      const x5 = v14.x * this._res;
      const y7 = -v14.y * this._res;
      return this.findNodeAt(x5, y7);
    }
    if (hit?.coords) {
      return this.findNodeAt(hit.coords.x, hit.coords.y);
    }
    return null;
  }
  findNodeAt(x5, y7) {
    const findHitNode = (node, offsetX = 0, offsetY = 0) => {
      if (!node.box || node._display === "none") return null;
      const left = offsetX + node.box.left;
      const top = offsetY + node.box.top;
      const width = node.box.width;
      const height = node.box.height;
      if (x5 < left || x5 > left + width || y7 < top || y7 > top + height) {
        return null;
      }
      for (let i5 = node.children.length - 1; i5 >= 0; i5--) {
        const childHit = findHitNode(node.children[i5], offsetX, offsetY);
        if (childHit) return childHit;
      }
      return node;
    };
    return findHitNode(this);
  }
  createMaterial(lit, texture, transparent, doubleside) {
    const material2 = lit ? new three_exports.MeshStandardMaterial({ roughness: 1, metalness: 0 }) : new three_exports.MeshBasicMaterial({});
    material2.color.set("white");
    material2.transparent = transparent;
    material2.map = texture;
    material2.side = doubleside ? three_exports.DoubleSide : three_exports.FrontSide;
    this.ctx.world.setupMaterial(material2);
    return material2;
  }
  get space() {
    return this._space;
  }
  set space(value = defaults12.space) {
    if (!isSpace2(value)) {
      throw new Error("[ui] space not valid");
    }
    if (this._space === value) return;
    this._space = value;
    this.rebuild();
  }
  get width() {
    return this._width;
  }
  set width(value = defaults12.width) {
    if (!isNumber10(value)) {
      throw new Error("[ui] width not a number");
    }
    if (this._width === value) return;
    this._width = value;
    this.yogaNode?.setWidth(this._width * this._res);
    this.rebuild();
  }
  get height() {
    return this._height;
  }
  set height(value = defaults12.height) {
    if (!isNumber10(value)) {
      throw new Error("[ui] height not a number");
    }
    if (this._height === value) return;
    this._height = value;
    this.yogaNode?.setHeight(this._height * this._res);
    this.rebuild();
  }
  get size() {
    return this._size;
  }
  set size(value = defaults12.size) {
    if (!isNumber10(value)) {
      throw new Error("[ui] size not a number");
    }
    if (this._size === value) return;
    this._size = value;
    this.rebuild();
  }
  get res() {
    return this._res;
  }
  set res(value = defaults12.res) {
    if (!isNumber10(value)) {
      throw new Error("[ui] res not a number");
    }
    if (this._res === value) return;
    this._res = value;
    this.rebuild();
  }
  get lit() {
    return this._lit;
  }
  set lit(value = defaults12.lit) {
    if (!isBoolean8(value)) {
      throw new Error("[ui] lit not a boolean");
    }
    if (this._lit === value) return;
    this._lit = value;
    this.rebuild();
  }
  get doubleside() {
    return this._doubleside;
  }
  set doubleside(value = defaults12.doubleside) {
    if (!isBoolean8(value)) {
      throw new Error("[ui] doubleside not a boolean");
    }
    if (this._doubleside === value) return;
    this._doubleside = value;
    this.rebuild();
  }
  get billboard() {
    return this._billboard;
  }
  set billboard(value = defaults12.billboard) {
    if (!isBillboard2(value)) {
      throw new Error(`[ui] billboard invalid: ${value}`);
    }
    if (this._billboard === value) return;
    this._billboard = value;
    this.rebuild();
  }
  get pivot() {
    return this._pivot;
  }
  set pivot(value = defaults12.pivot) {
    if (!isPivot3(value)) {
      throw new Error(`[ui] pivot invalid: ${value}`);
    }
    if (this._pivot === value) return;
    this._pivot = value;
    this.rebuild();
  }
  get offset() {
    return this._offset;
  }
  set offset(value) {
    if (!value || !value.isVector3) {
      throw new Error(`[ui] offset invalid`);
    }
    this._offset.copy(value);
    this.rebuild();
  }
  get scaler() {
    return this._scaler;
  }
  set scaler(value = defaults12.scaler) {
    if (value !== null && !isScaler(value)) {
      throw new Error("[ui] scaler invalid");
    }
    this._scaler = value;
    this.rebuild();
  }
  get pointerEvents() {
    return this._pointerEvents;
  }
  set pointerEvents(value = defaults12.pointerEvents) {
    if (!isBoolean8(value)) {
      throw new Error("[ui] pointerEvents not a boolean");
    }
    if (this._pointerEvents === value) return;
    this._pointerEvents = value;
    this.redraw();
  }
  get transparent() {
    return this._transparent;
  }
  set transparent(value = defaults12.transparent) {
    if (!isBoolean8(value)) {
      throw new Error("[ui] transparent not a boolean");
    }
    if (this._transparent === value) return;
    this._transparent = value;
    this.redraw();
  }
  get backgroundColor() {
    return this._backgroundColor;
  }
  set backgroundColor(value = defaults12.backgroundColor) {
    if (value !== null && !isString9(value)) {
      throw new Error("[ui] backgroundColor not a string");
    }
    if (this._backgroundColor === value) return;
    this._backgroundColor = value;
    this.redraw();
  }
  get borderWidth() {
    return this._borderWidth;
  }
  set borderWidth(value = defaults12.borderWidth) {
    if (!isNumber10(value)) {
      throw new Error("[ui] borderWidth not a number");
    }
    if (this._borderWidth === value) return;
    this._borderWidth = value;
    this.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value = defaults12.borderColor) {
    if (value !== null && !isString9(value)) {
      throw new Error("[ui] borderColor not a string");
    }
    if (this._borderColor === value) return;
    this._borderColor = value;
    this.redraw();
  }
  get borderRadius() {
    return this._borderRadius;
  }
  set borderRadius(value = defaults12.borderRadius) {
    if (!isNumber10(value)) {
      throw new Error("[ui] borderRadius not a number");
    }
    if (this._borderRadius === value) return;
    this._borderRadius = value;
    this.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value = defaults12.padding) {
    if (!isEdge(value)) {
      throw new Error(`[ui] padding not a number or array of numbers`);
    }
    if (this._padding === value) return;
    this._padding = value;
    if (isArray3(this._padding)) {
      const [top, right, bottom, left] = this._padding;
      this.yogaNode?.setPadding(Yoga2.EDGE_TOP, top * this._res);
      this.yogaNode?.setPadding(Yoga2.EDGE_RIGHT, right * this._res);
      this.yogaNode?.setPadding(Yoga2.EDGE_BOTTOM, bottom * this._res);
      this.yogaNode?.setPadding(Yoga2.EDGE_LEFT, left * this._res);
    } else {
      this.yogaNode?.setPadding(Yoga2.EDGE_ALL, this._padding * this._res);
    }
    this.redraw();
  }
  get flexDirection() {
    return this._flexDirection;
  }
  set flexDirection(value = defaults12.flexDirection) {
    if (!isFlexDirection(value)) {
      throw new Error(`[ui] flexDirection invalid: ${value}`);
    }
    if (this._flexDirection === value) return;
    this._flexDirection = value;
    this.yogaNode?.setFlexDirection(FlexDirection[this._flexDirection]);
    this.redraw();
  }
  get justifyContent() {
    return this._justifyContent;
  }
  set justifyContent(value = defaults12.justifyContent) {
    if (!isJustifyContent(value)) {
      throw new Error(`[ui] justifyContent invalid: ${value}`);
    }
    if (this._justifyContent === value) return;
    this._justifyContent = value;
    this.yogaNode?.setJustifyContent(JustifyContent[this._justifyContent]);
    this.redraw();
  }
  get alignItems() {
    return this._alignItems;
  }
  set alignItems(value = defaults12.alignItems) {
    if (!isAlignItem(value)) {
      throw new Error(`[ui] alignItems invalid: ${value}`);
    }
    if (this._alignItems === value) return;
    this._alignItems = value;
    this.yogaNode?.setAlignItems(AlignItems[this._alignItems]);
    this.redraw();
  }
  get alignContent() {
    return this._alignContent;
  }
  set alignContent(value = defaults12.alignContent) {
    if (!isAlignContent(value)) {
      throw new Error(`[ui] alignContent invalid: ${value}`);
    }
    if (this._alignContent === value) return;
    this._alignContent = value;
    this.yogaNode?.setAlignContent(AlignContent[this._alignContent]);
    this.redraw();
  }
  get flexWrap() {
    return this.flexWrap;
  }
  set flexWrap(value = defaults12.flexWrap) {
    if (!isFlexWrap(value)) {
      throw new Error(`[uiview] flexWrap invalid: ${value}`);
    }
    if (this._flexWrap === value) return;
    this._flexWrap = value;
    this.yogaNode?.setFlexWrap(FlexWrap[this._flexWrap]);
    this.redraw();
  }
  get gap() {
    return this._gap;
  }
  set gap(value = defaults12.gap) {
    if (!isNumber10(value)) {
      throw new Error(`[uiview] gap not a number`);
    }
    if (this._gap === value) return;
    this._gap = value;
    this.yogaNode?.setGap(Yoga2.GUTTER_ALL, this._gap * this._res);
    this.redraw();
  }
  getProxy() {
    if (!this.proxy) {
      var self2 = this;
      let proxy = {
        get space() {
          return self2.space;
        },
        set space(value) {
          self2.space = value;
        },
        get width() {
          return self2.width;
        },
        set width(value) {
          self2.width = value;
        },
        get height() {
          return self2.height;
        },
        set height(value) {
          self2.height = value;
        },
        get size() {
          return self2.size;
        },
        set size(value) {
          self2.size = value;
        },
        get res() {
          return self2.res;
        },
        set res(value) {
          self2.res = value;
        },
        get lit() {
          return self2.lit;
        },
        set lit(value) {
          self2.lit = value;
        },
        get doubleside() {
          return self2.doubleside;
        },
        set doubleside(value) {
          self2.doubleside = value;
        },
        get billboard() {
          return self2.billboard;
        },
        set billboard(value) {
          self2.billboard = value;
        },
        get pivot() {
          return self2.pivot;
        },
        set pivot(value) {
          self2.pivot = value;
        },
        get offset() {
          return self2.offset;
        },
        set offset(value) {
          self2.offset = value;
        },
        get scaler() {
          return self2.scaler;
        },
        set scaler(value) {
          self2.scaler = value;
        },
        get pointerEvents() {
          return self2.pointerEvents;
        },
        set pointerEvents(value) {
          self2.pointerEvents = value;
        },
        get transparent() {
          return self2.transparent;
        },
        set transparent(value) {
          self2.transparent = value;
        },
        get backgroundColor() {
          return self2.backgroundColor;
        },
        set backgroundColor(value) {
          self2.backgroundColor = value;
        },
        get borderWidth() {
          return self2.borderWidth;
        },
        set borderWidth(value) {
          self2.borderWidth = value;
        },
        get borderColor() {
          return self2.borderColor;
        },
        set borderColor(value) {
          self2.borderColor = value;
        },
        get borderRadius() {
          return self2.borderRadius;
        },
        set borderRadius(value) {
          self2.borderRadius = value;
        },
        get padding() {
          return self2.padding;
        },
        set padding(value) {
          self2.padding = value;
        },
        get flexDirection() {
          return self2.flexDirection;
        },
        set flexDirection(value) {
          self2.flexDirection = value;
        },
        get justifyContent() {
          return self2.justifyContent;
        },
        set justifyContent(value) {
          self2.justifyContent = value;
        },
        get alignItems() {
          return self2.alignItems;
        },
        set alignItems(value) {
          self2.alignItems = value;
        },
        get alignContent() {
          return self2.alignContent;
        },
        set alignContent(value) {
          self2.alignContent = value;
        },
        get flexWrap() {
          return self2.flexWrap;
        },
        set flexWrap(value) {
          self2.flexWrap = value;
        },
        get gap() {
          return self2.gap;
        },
        set gap(value) {
          self2.gap = value;
        }
      };
      proxy = Object.defineProperties(proxy, Object.getOwnPropertyDescriptors(super.getProxy()));
      this.proxy = proxy;
    }
    return this.proxy;
  }
};
function pivotGeometry(pivot, geometry, width, height) {
  const halfWidth = width / 2;
  const halfHeight = height / 2;
  switch (pivot) {
    case "top-left":
      geometry.translate(halfWidth, -halfHeight, 0);
      break;
    case "top-center":
      geometry.translate(0, -halfHeight, 0);
      break;
    case "top-right":
      geometry.translate(-halfWidth, -halfHeight, 0);
      break;
    case "center-left":
      geometry.translate(halfWidth, 0, 0);
      break;
    case "center-right":
      geometry.translate(-halfWidth, 0, 0);
      break;
    case "bottom-left":
      geometry.translate(halfWidth, halfHeight, 0);
      break;
    case "bottom-center":
      geometry.translate(0, halfHeight, 0);
      break;
    case "bottom-right":
      geometry.translate(-halfWidth, halfHeight, 0);
      break;
    case "center":
    default:
      break;
  }
}
function pivotCanvas(pivot, canvas, width, height) {
  switch (pivot) {
    case "top-left":
      canvas.style.transform = `translate(0%, 0%)`;
      break;
    case "top-center":
      canvas.style.transform = `translate(-50%, 0%)`;
      break;
    case "top-right":
      canvas.style.transform = `translate(-100%, 0%)`;
      break;
    case "center-left":
      canvas.style.transform = `translate(0%, -50%)`;
      break;
    case "center-right":
      canvas.style.transform = `translate(-100%, -50%)`;
      break;
    case "bottom-left":
      canvas.style.transform = `translate(0%, -100%)`;
      break;
    case "bottom-center":
      canvas.style.transform = `translate(-50%, -100%)`;
      break;
    case "bottom-right":
      canvas.style.transform = `translate(-100%, -100%)`;
      break;
    case "center":
    default:
      canvas.style.transform = `translate(-50%, -50%)`;
      break;
  }
}
function isBillboard2(value) {
  return billboards2.includes(value);
}
function isPivot3(value) {
  return pivots3.includes(value);
}
function isSpace2(value) {
  return spaces2.includes(value);
}
function getPivotOffset(pivot, width, height) {
  const halfW = width / 2;
  const halfH = height / 2;
  let tx = 0, ty = 0;
  switch (pivot) {
    case "top-left":
      tx = +halfW;
      ty = -halfH;
      break;
    case "top-center":
      tx = 0;
      ty = -halfH;
      break;
    case "top-right":
      tx = -halfW;
      ty = -halfH;
      break;
    case "center-left":
      tx = +halfW;
      ty = 0;
      break;
    case "center-right":
      tx = -halfW;
      ty = 0;
      break;
    case "bottom-left":
      tx = +halfW;
      ty = +halfH;
      break;
    case "bottom-center":
      tx = 0;
      ty = +halfH;
      break;
    case "bottom-right":
      tx = -halfW;
      ty = +halfH;
      break;
    case "center":
    default:
      tx = 0;
      ty = 0;
      break;
  }
  return new three_exports.Vector2(-halfW + tx, +halfH + ty);
}
function isEdge(value) {
  if (isNumber10(value)) {
    return true;
  }
  if (isArray3(value)) {
    return value.length === 4 && every3(value, (n6) => isNumber10(n6));
  }
  return false;
}
function isScaler(value) {
  return isArray3(value) && isNumber10(value[0]) && isNumber10(value[1]);
}

// src/core/nodes/UIView.js
import Yoga3 from "yoga-layout";
import { every as every4, isArray as isArray4, isBoolean as isBoolean9, isNumber as isNumber11, isString as isString10 } from "lodash-es";
var defaults13 = {
  display: "flex",
  width: null,
  height: null,
  absolute: false,
  top: null,
  right: null,
  bottom: null,
  left: null,
  backgroundColor: null,
  borderWidth: 0,
  borderColor: null,
  borderRadius: 0,
  margin: 0,
  padding: 0,
  flexDirection: "column",
  justifyContent: "flex-start",
  alignItems: "stretch",
  alignContent: "flex-start",
  flexWrap: "no-wrap",
  gap: 0,
  flexBasis: "auto",
  flexGrow: 0,
  flexShrink: 1
};
var UIView = class extends Node {
  constructor(data = {}) {
    super(data);
    this.name = "uiview";
    this.display = data.display;
    this.width = data.width;
    this.height = data.height;
    this.absolute = data.absolute;
    this.top = data.top;
    this.right = data.right;
    this.bottom = data.bottom;
    this.left = data.left;
    this.backgroundColor = data.backgroundColor;
    this.borderWidth = data.borderWidth;
    this.borderColor = data.borderColor;
    this.borderRadius = data.borderRadius;
    this.margin = data.margin;
    this.padding = data.padding;
    this.flexDirection = data.flexDirection;
    this.justifyContent = data.justifyContent;
    this.alignItems = data.alignItems;
    this.alignContent = data.alignContent;
    this.flexWrap = data.flexWrap;
    this.gap = data.gap;
    this.flexBasis = data.flexBasis;
    this.flexGrow = data.flexGrow;
    this.flexShrink = data.flexShrink;
  }
  draw(ctx, offsetLeft, offsetTop) {
    if (this._display === "none") return;
    this.box = {};
    const left = offsetLeft + this.yogaNode.getComputedLeft();
    const top = offsetTop + this.yogaNode.getComputedTop();
    const width = this.yogaNode.getComputedWidth();
    const height = this.yogaNode.getComputedHeight();
    if (this._backgroundColor) {
      const inset = this._borderColor && this._borderWidth ? 0.5 * this.ui._res : 0;
      const radius = Math.max(0, this._borderRadius * this.ui._res - inset);
      const insetLeft = left + inset;
      const insetTop = top + inset;
      const insetWidth = width - inset * 2;
      const insetHeight = height - inset * 2;
      fillRoundRect(ctx, insetLeft, insetTop, insetWidth, insetHeight, radius, this._backgroundColor);
    }
    if (this._borderWidth && this._borderColor) {
      const radius = this._borderRadius * this.ui._res;
      const thickness = this._borderWidth * this.ui._res;
      ctx.strokeStyle = this._borderColor;
      ctx.lineWidth = thickness;
      if (this._borderRadius) {
        borderRoundRect(ctx, left, top, width, height, radius, thickness);
      } else {
        const insetLeft = left + thickness / 2;
        const insetTop = top + thickness / 2;
        const insetWidth = width - thickness;
        const insetHeight = height - thickness;
        ctx.strokeRect(insetLeft, insetTop, insetWidth, insetHeight);
      }
    }
    this.box = { left, top, width, height };
    this.children.forEach((child) => child.draw(ctx, left, top));
  }
  mount() {
    if (this.ctx.world.network.isServer) return;
    this.ui = this.parent?.ui;
    if (!this.ui) return console.error("uiview: must be child of ui node");
    this.yogaNode = Yoga3.Node.create();
    this.yogaNode.setDisplay(Display[this._display]);
    this.yogaNode.setWidth(this._width === null ? void 0 : this._width * this.ui._res);
    this.yogaNode.setHeight(this._height === null ? void 0 : this._height * this.ui._res);
    this.yogaNode.setPositionType(this._absolute ? Yoga3.POSITION_TYPE_ABSOLUTE : Yoga3.POSITION_TYPE_RELATIVE);
    this.yogaNode.setPosition(Yoga3.EDGE_TOP, isNumber11(this._top) ? this._top * this.ui._res : void 0);
    this.yogaNode.setPosition(Yoga3.EDGE_RIGHT, isNumber11(this._right) ? this._right * this.ui._res : void 0);
    this.yogaNode.setPosition(Yoga3.EDGE_BOTTOM, isNumber11(this._bottom) ? this._bottom * this.ui._res : void 0);
    this.yogaNode.setPosition(Yoga3.EDGE_LEFT, isNumber11(this._left) ? this._left * this.ui._res : void 0);
    this.yogaNode.setBorder(Yoga3.EDGE_ALL, this._borderWidth * this.ui._res);
    if (isArray4(this._margin)) {
      const [top, right, bottom, left] = this._margin;
      this.yogaNode.setMargin(Yoga3.EDGE_TOP, top * this.ui._res);
      this.yogaNode.setMargin(Yoga3.EDGE_RIGHT, right * this.ui._res);
      this.yogaNode.setMargin(Yoga3.EDGE_BOTTOM, bottom * this.ui._res);
      this.yogaNode.setMargin(Yoga3.EDGE_LEFT, left * this.ui._res);
    } else {
      this.yogaNode.setMargin(Yoga3.EDGE_ALL, this._margin * this.ui._res);
    }
    if (isArray4(this._padding)) {
      const [top, right, bottom, left] = this._padding;
      this.yogaNode.setPadding(Yoga3.EDGE_TOP, top * this.ui._res);
      this.yogaNode.setPadding(Yoga3.EDGE_RIGHT, right * this.ui._res);
      this.yogaNode.setPadding(Yoga3.EDGE_BOTTOM, bottom * this.ui._res);
      this.yogaNode.setPadding(Yoga3.EDGE_LEFT, left * this.ui._res);
    } else {
      this.yogaNode.setPadding(Yoga3.EDGE_ALL, this._padding * this.ui._res);
    }
    this.yogaNode.setFlexDirection(FlexDirection[this._flexDirection]);
    this.yogaNode.setJustifyContent(JustifyContent[this._justifyContent]);
    this.yogaNode.setAlignItems(AlignItems[this._alignItems]);
    this.yogaNode.setAlignContent(AlignContent[this._alignContent]);
    this.yogaNode.setFlexWrap(FlexWrap[this._flexWrap]);
    this.yogaNode.setGap(Yoga3.GUTTER_ALL, this._gap * this.ui._res);
    this.yogaNode.setFlexBasis(this._flexBasis);
    this.yogaNode.setFlexGrow(this._flexGrow);
    this.yogaNode.setFlexShrink(this._flexShrink);
    this.parent.yogaNode.insertChild(this.yogaNode, this.parent.yogaNode.getChildCount());
    this.ui?.redraw();
  }
  commit(didMove) {
  }
  unmount() {
    if (this.ctx.world.network.isServer) return;
    if (this.yogaNode) {
      this.parent.yogaNode?.removeChild(this.yogaNode);
      this.yogaNode.free();
      this.yogaNode = null;
      this.box = null;
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this._display = source._display;
    this._width = source._width;
    this._height = source._height;
    this._absolute = source._absolute;
    this._top = source._top;
    this._right = source._right;
    this._bottom = source._bottom;
    this._left = source._left;
    this._backgroundColor = source._backgroundColor;
    this._borderWidth = source._borderWidth;
    this._borderColor = source._borderColor;
    this._borderRadius = source._borderRadius;
    this._margin = source._margin;
    this._padding = source._padding;
    this._flexDirection = source._flexDirection;
    this._justifyContent = source._justifyContent;
    this._alignItems = source._alignItems;
    this._alignContent = source._alignContent;
    this._flexBasis = source._flexBasis;
    this._flexGrow = source._flexGrow;
    this._flexShrink = source._flexShrink;
    this._flexWrap = source._flexWrap;
    this._gap = source._gap;
    return this;
  }
  get display() {
    return this._display;
  }
  set display(value = defaults13.display) {
    if (!isDisplay(value)) {
      throw new Error(`[uiview] display invalid: ${value}`);
    }
    if (this._display === value) return;
    this._display = value;
    this.yogaNode?.setDisplay(Display[this._display]);
    this.ui?.redraw();
  }
  get width() {
    return this._width;
  }
  set width(value = defaults13.width) {
    if (value !== null && !isNumber11(value)) {
      throw new Error(`[uiview] width not a number`);
    }
    if (this._width === value) return;
    this._width = value;
    this.yogaNode?.setWidth(this._width === null ? void 0 : this._width * this.ui._res);
    this.ui?.redraw();
  }
  get height() {
    return this._height;
  }
  set height(value = defaults13.height) {
    if (value !== null && !isNumber11(value)) {
      throw new Error(`[uiview] height not a number`);
    }
    if (this._height === value) return;
    this._height = value;
    this.yogaNode?.setHeight(this._height === null ? void 0 : this._height * this.ui._res);
    this.ui?.redraw();
  }
  get absolute() {
    return this._absolute;
  }
  set absolute(value = defaults13.absolute) {
    if (!isBoolean9(value)) {
      throw new Error(`[uiview] absolute not a boolean`);
    }
    if (this._absolute === value) return;
    this._absolute = value;
    this.yogaNode?.setPositionType(this._absolute ? Yoga3.POSITION_TYPE_ABSOLUTE.ABSOLUTE : Yoga3.POSITION_TYPE_RELATIVE);
    this.ui?.redraw();
  }
  get top() {
    return this._top;
  }
  set top(value = defaults13.top) {
    const isNum = isNumber11(value);
    if (value !== null && !isNum) {
      throw new Error(`[uiview] top must be a number or null`);
    }
    if (this._top === value) return;
    this._top = value;
    this.yogaNode?.setPosition(Yoga3.EDGE_TOP, isNum ? this._top * this.ui._res : void 0);
    this.ui?.redraw();
  }
  get right() {
    return this._right;
  }
  set right(value = defaults13.right) {
    const isNum = isNumber11(value);
    if (value !== null && !isNum) {
      throw new Error(`[uiview] right must be a number or null`);
    }
    if (this._right === value) return;
    this._right = value;
    this.yogaNode?.setPosition(Yoga3.EDGE_RIGHT, isNum ? this._right * this.ui._res : void 0);
    this.ui?.redraw();
  }
  get bottom() {
    return this._bottom;
  }
  set bottom(value = defaults13.bottom) {
    const isNum = isNumber11(value);
    if (value !== null && !isNum) {
      throw new Error(`[uiview] bottom must be a number or null`);
    }
    if (this._bottom === value) return;
    this._bottom = value;
    this.yogaNode?.setPosition(Yoga3.EDGE_BOTTOM, isNum ? this._bottom * this.ui._res : void 0);
    this.ui?.redraw();
  }
  get left() {
    return this._left;
  }
  set left(value = defaults13.left) {
    const isNum = isNumber11(value);
    if (value !== null && !isNum) {
      throw new Error(`[uiview] left must be a number or null`);
    }
    if (this._left === value) return;
    this._left = value;
    this.yogaNode?.setPosition(Yoga3.EDGE_LEFT, isNum ? this._left * this.ui._res : void 0);
    this.ui?.redraw();
  }
  get backgroundColor() {
    return this._backgroundColor;
  }
  set backgroundColor(value = defaults13.backgroundColor) {
    if (value !== null && !isString10(value)) {
      throw new Error(`[uiview] backgroundColor not a string`);
    }
    if (this._backgroundColor === value) return;
    this._backgroundColor = value;
    this.ui?.redraw();
  }
  get borderWidth() {
    return this._borderWidth;
  }
  set borderWidth(value = defaults13.borderWidth) {
    if (!isNumber11(value)) {
      throw new Error(`[uiview] borderWidth not a number`);
    }
    if (this._borderWidth === value) return;
    this._borderWidth = value;
    this.ui?.redraw();
  }
  get borderColor() {
    return this._borderColor;
  }
  set borderColor(value = defaults13.borderColor) {
    if (value !== null && !isString10(value)) {
      throw new Error(`[uiview] borderColor not a string`);
    }
    if (this._borderColor === value) return;
    this._borderColor = value;
    this.ui?.redraw();
  }
  get borderRadius() {
    return this._borderRadius;
  }
  set borderRadius(value = defaults13.borderRadius) {
    if (!isNumber11(value)) {
      throw new Error(`[uiview] borderRadius not a number`);
    }
    if (this._borderRadius === value) return;
    this._borderRadius = value;
    this.ui?.redraw();
  }
  get margin() {
    return this._margin;
  }
  set margin(value = defaults13.margin) {
    if (!isEdge2(value)) {
      throw new Error(`[uiview] margin not a number or array of numbers`);
    }
    if (this._margin === value) return;
    this._margin = value;
    if (isArray4(this._margin)) {
      const [top, right, bottom, left] = this._margin;
      this.yogaNode?.setMargin(Yoga3.EDGE_TOP, top * this.ui._res);
      this.yogaNode?.setMargin(Yoga3.EDGE_RIGHT, right * this.ui._res);
      this.yogaNode?.setMargin(Yoga3.EDGE_BOTTOM, bottom * this.ui._res);
      this.yogaNode?.setMargin(Yoga3.EDGE_LEFT, left * this.ui._res);
    } else {
      this.yogaNode?.setMargin(Yoga3.EDGE_ALL, this._margin * this.ui._res);
    }
    this.ui?.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value = defaults13.padding) {
    if (!isEdge2(value)) {
      throw new Error(`[uiview] padding not a number or array of numbers`);
    }
    if (this._padding === value) return;
    this._padding = value;
    if (isArray4(this._padding)) {
      const [top, right, bottom, left] = this._padding;
      this.yogaNode?.setPadding(Yoga3.EDGE_TOP, top * this.ui._res);
      this.yogaNode?.setPadding(Yoga3.EDGE_RIGHT, right * this.ui._res);
      this.yogaNode?.setPadding(Yoga3.EDGE_BOTTOM, bottom * this.ui._res);
      this.yogaNode?.setPadding(Yoga3.EDGE_LEFT, left * this.ui._res);
    } else {
      this.yogaNode?.setPadding(Yoga3.EDGE_ALL, this._padding * this.ui._res);
    }
    this.ui?.redraw();
  }
  get flexDirection() {
    return this._flexDirection;
  }
  set flexDirection(value = defaults13.flexDirection) {
    if (!isFlexDirection(value)) {
      throw new Error(`[uiview] flexDirection invalid: ${value}`);
    }
    if (this._flexDirection === value) return;
    this._flexDirection = value;
    this.yogaNode?.setFlexDirection(FlexDirection[this._flexDirection]);
    this.ui?.redraw();
  }
  get justifyContent() {
    return this._justifyContent;
  }
  set justifyContent(value = defaults13.justifyContent) {
    if (!isJustifyContent(value)) {
      throw new Error(`[uiview] justifyContent invalid: ${value}`);
    }
    if (this._justifyContent === value) return;
    this._justifyContent = value;
    this.yogaNode?.setJustifyContent(JustifyContent[this._justifyContent]);
    this.ui?.redraw();
  }
  get alignItems() {
    return this._alignItems;
  }
  set alignItems(value = defaults13.alignItems) {
    if (!isAlignItem(value)) {
      throw new Error(`[uiview] alignItems invalid: ${value}`);
    }
    if (this._alignItems === value) return;
    this._alignItems = value;
    this.yogaNode?.setAlignItems(AlignItems[this._alignItems]);
    this.ui?.redraw();
  }
  get alignContent() {
    return this._alignContent;
  }
  set alignContent(value = defaults13.alignContent) {
    if (!isAlignContent(value)) {
      throw new Error(`[uiview] alignContent invalid: ${value}`);
    }
    if (this._alignContent === value) return;
    this._alignContent = value;
    this.yogaNode?.setAlignContent(AlignContent[this._alignContent]);
    this.ui?.redraw();
  }
  get flexWrap() {
    return this.flexWrap;
  }
  set flexWrap(value = defaults13.flexWrap) {
    if (!isFlexWrap(value)) {
      throw new Error(`[uiview] flexWrap invalid: ${value}`);
    }
    if (this._flexWrap === value) return;
    this._flexWrap = value;
    this.yogaNode?.setFlexWrap(FlexWrap[this._flexWrap]);
    this.ui?.redraw();
  }
  get gap() {
    return this._gap;
  }
  set gap(value = defaults13.gap) {
    if (!isNumber11(value)) {
      throw new Error(`[uiview] gap not a number`);
    }
    if (this._gap === value) return;
    this._gap = value;
    this.yogaNode?.setGap(Yoga3.GUTTER_ALL, this._gap * this.ui._res);
    this.ui?.redraw();
  }
  get flexBasis() {
    return this._flexBasis;
  }
  set flexBasis(value = defaults13.flexBasis) {
    if (!isNumber11(value) && !isString10(value)) {
      throw new Error(`[uiview] flexBasis invalid`);
    }
    if (this._flexBasis === value) return;
    this._flexBasis = value;
    this.yogaNode?.setFlexBasis(this._flexBasis);
    this.ui?.redraw();
  }
  get flexGrow() {
    return this._flexGrow;
  }
  set flexGrow(value = defaults13.flexGrow) {
    if (!isNumber11(value)) {
      throw new Error(`[uiview] flexGrow not a number`);
    }
    if (this._flexGrow === value) return;
    this._flexGrow = value;
    this.yogaNode?.setFlexGrow(this._flexGrow);
    this.ui?.redraw();
  }
  get flexShrink() {
    return this._flexShrink;
  }
  set flexShrink(value = defaults13.flexShrink) {
    if (!isNumber11(value)) {
      throw new Error(`[uiview] flexShrink not a number`);
    }
    if (this._flexShrink === value) return;
    this._flexShrink = value;
    this.yogaNode?.setFlexShrink(this._flexShrink);
    this.ui?.redraw();
  }
  getProxy() {
    var self2 = this;
    if (!this.proxy) {
      let proxy = {
        get display() {
          return self2.display;
        },
        set display(value) {
          self2.display = value;
        },
        get width() {
          return self2.width;
        },
        set width(value) {
          self2.width = value;
        },
        get height() {
          return self2.height;
        },
        set height(value) {
          self2.height = value;
        },
        get absolute() {
          return self2.absolute;
        },
        set absolute(value) {
          self2.absolute = value;
        },
        get top() {
          return self2.top;
        },
        set top(value) {
          self2.top = value;
        },
        get right() {
          return self2.right;
        },
        set right(value) {
          self2.right = value;
        },
        get bottom() {
          return self2.bottom;
        },
        set bottom(value) {
          self2.bottom = value;
        },
        get left() {
          return self2.left;
        },
        set left(value) {
          self2.left = value;
        },
        get backgroundColor() {
          return self2.backgroundColor;
        },
        set backgroundColor(value) {
          self2.backgroundColor = value;
        },
        get borderWidth() {
          return self2.borderWidth;
        },
        set borderWidth(value) {
          self2.borderWidth = value;
        },
        get borderColor() {
          return self2.borderColor;
        },
        set borderColor(value) {
          self2.borderColor = value;
        },
        get borderRadius() {
          return self2.borderRadius;
        },
        set borderRadius(value) {
          self2.borderRadius = value;
        },
        get margin() {
          return self2.margin;
        },
        set margin(value) {
          self2.margin = value;
        },
        get padding() {
          return self2.padding;
        },
        set padding(value) {
          self2.padding = value;
        },
        get flexDirection() {
          return self2.flexDirection;
        },
        set flexDirection(value) {
          self2.flexDirection = value;
        },
        get justifyContent() {
          return self2.justifyContent;
        },
        set justifyContent(value) {
          self2.justifyContent = value;
        },
        get alignItems() {
          return self2.alignItems;
        },
        set alignItems(value) {
          self2.alignItems = value;
        },
        get alignContent() {
          return self2.alignContent;
        },
        set alignContent(value) {
          self2.alignContent = value;
        },
        get flexWrap() {
          return self2.flexWrap;
        },
        set flexWrap(value) {
          self2.flexWrap = value;
        },
        get gap() {
          return self2.gap;
        },
        set gap(value) {
          self2.gap = value;
        },
        get flexBasis() {
          return self2.flexBasis;
        },
        set flexBasis(value) {
          self2.flexBasis = value;
        },
        get flexGrow() {
          return self2.flexGrow;
        },
        set flexGrow(value) {
          self2.flexGrow = value;
        },
        get flexShrink() {
          return self2.flexShrink;
        },
        set flexShrink(value) {
          self2.flexShrink = value;
        }
      };
      proxy = Object.defineProperties(proxy, Object.getOwnPropertyDescriptors(super.getProxy()));
      this.proxy = proxy;
    }
    return this.proxy;
  }
};
function isEdge2(value) {
  if (isNumber11(value)) {
    return true;
  }
  if (isArray4(value)) {
    return value.length === 4 && every4(value, (n6) => isNumber11(n6));
  }
  return false;
}

// src/core/nodes/UIText.js
import Yoga4 from "yoga-layout";
import { every as every5, isArray as isArray5, isBoolean as isBoolean10, isNumber as isNumber12, isString as isString11 } from "lodash-es";
var textAligns = ["left", "center", "right"];
var defaults14 = {
  display: "flex",
  absolute: false,
  top: null,
  right: null,
  bottom: null,
  left: null,
  backgroundColor: null,
  borderRadius: 0,
  margin: 0,
  padding: 0,
  value: "",
  fontSize: 16,
  color: "#000000",
  lineHeight: 1.2,
  textAlign: "left",
  fontFamily: "Rubik",
  fontWeight: "normal",
  flexBasis: "auto",
  flexGrow: 0,
  flexShrink: 1
};
var offscreenContext;
var getOffscreenContext = () => {
  if (!offscreenContext) {
    const offscreenCanvas = document.createElement("canvas");
    offscreenContext = offscreenCanvas.getContext("2d");
  }
  return offscreenContext;
};
var UIText = class extends Node {
  constructor(data = {}) {
    super(data);
    this.name = "uitext";
    this.display = data.display;
    this.absolute = data.absolute;
    this.top = data.top;
    this.right = data.right;
    this.bottom = data.bottom;
    this.left = data.left;
    this.backgroundColor = data.backgroundColor;
    this.borderRadius = data.borderRadius;
    this.margin = data.margin;
    this.padding = data.padding;
    this.value = data.value;
    this.fontSize = data.fontSize;
    this.color = data.color;
    this.lineHeight = data.lineHeight;
    this.textAlign = data.textAlign;
    this.fontFamily = data.fontFamily;
    this.fontWeight = data.fontWeight;
    this.flexBasis = data.flexBasis;
    this.flexGrow = data.flexGrow;
    this.flexShrink = data.flexShrink;
  }
  draw(ctx, offsetLeft, offsetTop) {
    if (this._display === "none") return;
    const left = offsetLeft + this.yogaNode.getComputedLeft();
    const top = offsetTop + this.yogaNode.getComputedTop();
    const width = this.yogaNode.getComputedWidth();
    const height = this.yogaNode.getComputedHeight();
    if (this._backgroundColor) {
      fillRoundRect(ctx, left, top, width, height, this._borderRadius * this.ui._res, this._backgroundColor);
    }
    ctx.font = `${this._fontWeight} ${this._fontSize * this.ui._res}px ${this._fontFamily}`;
    ctx.textBaseline = "alphabetic";
    ctx.textAlign = this._textAlign;
    ctx.fillStyle = this._color;
    ctx.fillStyle = this._color;
    const paddingLeft = this.yogaNode.getComputedPadding(Yoga4.EDGE_LEFT);
    const paddingTop = this.yogaNode.getComputedPadding(Yoga4.EDGE_TOP);
    const paddingRight = this.yogaNode.getComputedPadding(Yoga4.EDGE_RIGHT);
    const innerWidth = width - paddingLeft - paddingRight;
    let innerX = left + paddingLeft;
    if (this._textAlign === "center") {
      innerX = left + width / 2;
    } else if (this._textAlign === "right") {
      innerX = left + width - paddingRight;
    }
    const lines = wrapText(ctx, this._value, innerWidth);
    let currentBaselineY = 0;
    for (let i5 = 0; i5 < lines.length; i5++) {
      const line = lines[i5];
      const isFirst = i5 === 0;
      const metrics = ctx.measureText(line);
      const ascent = metrics.actualBoundingBoxAscent;
      const descent = metrics.actualBoundingBoxDescent;
      const naturalLineHeight = ascent + descent;
      const baselineGap = naturalLineHeight * this._lineHeight;
      if (isFirst) currentBaselineY += top + paddingTop + metrics.actualBoundingBoxAscent;
      ctx.fillText(line, innerX, currentBaselineY);
      currentBaselineY += baselineGap;
    }
    this.box = { left, top, width, height };
  }
  mount() {
    if (this.ctx.world.network.isServer) return;
    this.ui = this.parent?.ui;
    if (!this.ui) return console.error("uitext: must be child of ui node");
    this.yogaNode = Yoga4.Node.create();
    this.yogaNode.setMeasureFunc(this.measureTextFunc());
    this.yogaNode.setDisplay(Display[this._display]);
    this.yogaNode.setPositionType(this._absolute ? Yoga4.POSITION_TYPE_ABSOLUTE : Yoga4.POSITION_TYPE_RELATIVE);
    this.yogaNode.setPosition(Yoga4.EDGE_TOP, isNumber12(this._top) ? this._top * this.ui._res : void 0);
    this.yogaNode.setPosition(Yoga4.EDGE_RIGHT, isNumber12(this._right) ? this._right * this.ui._res : void 0);
    this.yogaNode.setPosition(Yoga4.EDGE_BOTTOM, isNumber12(this._bottom) ? this._bottom * this.ui._res : void 0);
    this.yogaNode.setPosition(Yoga4.EDGE_LEFT, isNumber12(this._left) ? this._left * this.ui._res : void 0);
    if (isArray5(this._margin)) {
      const [top, right, bottom, left] = this._margin;
      this.yogaNode.setMargin(Yoga4.EDGE_TOP, top * this.ui._res);
      this.yogaNode.setMargin(Yoga4.EDGE_RIGHT, right * this.ui._res);
      this.yogaNode.setMargin(Yoga4.EDGE_BOTTOM, bottom * this.ui._res);
      this.yogaNode.setMargin(Yoga4.EDGE_LEFT, left * this.ui._res);
    } else {
      this.yogaNode.setMargin(Yoga4.EDGE_ALL, this._margin * this.ui._res);
    }
    if (isArray5(this._padding)) {
      const [top, right, bottom, left] = this._padding;
      this.yogaNode.setPadding(Yoga4.EDGE_TOP, top * this.ui._res);
      this.yogaNode.setPadding(Yoga4.EDGE_RIGHT, right * this.ui._res);
      this.yogaNode.setPadding(Yoga4.EDGE_BOTTOM, bottom * this.ui._res);
      this.yogaNode.setPadding(Yoga4.EDGE_LEFT, left * this.ui._res);
    } else {
      this.yogaNode.setPadding(Yoga4.EDGE_ALL, this._padding * this.ui._res);
    }
    this.yogaNode.setFlexBasis(this._flexBasis);
    this.yogaNode.setFlexGrow(this._flexGrow);
    this.yogaNode.setFlexShrink(this._flexShrink);
    this.parent.yogaNode.insertChild(this.yogaNode, this.parent.yogaNode.getChildCount());
    this.ui?.redraw();
  }
  commit(didMove) {
  }
  unmount() {
    if (this.ctx.world.network.isServer) return;
    if (this.yogaNode) {
      this.parent.yogaNode?.removeChild(this.yogaNode);
      this.yogaNode.free();
      this.yogaNode = null;
      this.box = null;
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this._display = source._display;
    this._absolute = source._absolute;
    this._top = source._top;
    this._right = source._right;
    this._bottom = source._bottom;
    this._left = source._left;
    this._backgroundColor = source._backgroundColor;
    this._borderRadius = source._borderRadius;
    this._margin = source._margin;
    this._padding = source._padding;
    this._value = source._value;
    this._fontSize = source._fontSize;
    this._color = source._color;
    this._lineHeight = source._lineHeight;
    this._textAlign = source._textAlign;
    this._fontFamily = source._fontFamily;
    this._fontWeight = source._fontWeight;
    this._flexBasis = source._flexBasis;
    this._flexGrow = source._flexGrow;
    this._flexShrink = source._flexShrink;
    return this;
  }
  measureTextFunc() {
    const ctx = getOffscreenContext();
    return (width, widthMode, height, heightMode) => {
      ctx.font = `${this._fontWeight} ${this._fontSize * this.ui._res}px ${this._fontFamily}`;
      ctx.textBaseline = "alphabetic";
      let lines;
      if (widthMode === Yoga4.MEASURE_MODE_EXACTLY || widthMode === Yoga4.MEASURE_MODE_AT_MOST) {
        lines = wrapText(ctx, this._value, width);
      } else {
        lines = [this._value];
      }
      let finalHeight = 0;
      let finalWidth = 0;
      for (let i5 = 0; i5 < lines.length; i5++) {
        const line = lines[i5];
        const isFirst = i5 === 0;
        const isLast = i5 === lines.length - 1;
        const metrics = ctx.measureText(line);
        const ascent = metrics.actualBoundingBoxAscent;
        const descent = metrics.actualBoundingBoxDescent;
        const naturalLineHeight = ascent + descent;
        if (metrics.width > finalWidth) {
          finalWidth = metrics.width;
        }
        if (isLast) {
          finalHeight += naturalLineHeight;
        } else {
          finalHeight += naturalLineHeight * this._lineHeight;
        }
      }
      if (widthMode === Yoga4.MEASURE_MODE_AT_MOST) {
        finalWidth = Math.min(finalWidth, width);
      }
      return { width: finalWidth, height: finalHeight };
    };
  }
  get display() {
    return this._display;
  }
  set display(value = defaults14.display) {
    if (!isDisplay(value)) {
      throw new Error(`[uitext] display invalid: ${value}`);
    }
    if (this._display === value) return;
    this._display = value;
    this.yogaNode?.setDisplay(Display[this._display]);
    this.yogaNode?.markDirty();
    this.ui?.redraw();
  }
  get absolute() {
    return this._absolute;
  }
  set absolute(value = defaults14.absolute) {
    if (!isBoolean10(value)) {
      throw new Error(`[uitext] absolute not a boolean`);
    }
    if (this._absolute === value) return;
    this._absolute = value;
    this.yogaNode?.setPositionType(this._absolute ? Yoga4.POSITION_TYPE_ABSOLUTE.ABSOLUTE : Yoga4.POSITION_TYPE_RELATIVE);
    this.ui?.redraw();
  }
  get top() {
    return this._top;
  }
  set top(value = defaults14.top) {
    const isNum = isNumber12(value);
    if (value !== null && !isNum) {
      throw new Error(`[uitext] top must be a number or null`);
    }
    if (this._top === value) return;
    this._top = value;
    this.yogaNode?.setPosition(Yoga4.EDGE_TOP, isNum ? this._top * this.ui._res : void 0);
    this.ui?.redraw();
  }
  get right() {
    return this._right;
  }
  set right(value = defaults14.right) {
    const isNum = isNumber12(value);
    if (value !== null && !isNum) {
      throw new Error(`[uitext] right must be a number or null`);
    }
    if (this._right === value) return;
    this._right = value;
    this.yogaNode?.setPosition(Yoga4.EDGE_RIGHT, isNum ? this._right * this.ui._res : void 0);
    this.ui?.redraw();
  }
  get bottom() {
    return this._bottom;
  }
  set bottom(value = defaults14.bottom) {
    const isNum = isNumber12(value);
    if (value !== null && !isNum) {
      throw new Error(`[uitext] bottom must be a number or null`);
    }
    if (this._bottom === value) return;
    this._bottom = value;
    this.yogaNode?.setPosition(Yoga4.EDGE_BOTTOM, isNum ? this._bottom * this.ui._res : void 0);
    this.ui?.redraw();
  }
  get left() {
    return this._left;
  }
  set left(value = defaults14.left) {
    const isNum = isNumber12(value);
    if (value !== null && !isNum) {
      throw new Error(`[uitext] left must be a number or null`);
    }
    if (this._left === value) return;
    this._left = value;
    this.yogaNode?.setPosition(Yoga4.EDGE_LEFT, isNum ? this._left * this.ui._res : void 0);
    this.ui?.redraw();
  }
  get backgroundColor() {
    return this._backgroundColor;
  }
  set backgroundColor(value = defaults14.backgroundColor) {
    if (value !== null && !isString11(value)) {
      throw new Error(`[uitext] backgroundColor not a string`);
    }
    if (this._backgroundColor === value) return;
    this._backgroundColor = value;
    this.ui?.redraw();
  }
  get borderRadius() {
    return this._borderRadius;
  }
  set borderRadius(value = defaults14.borderRadius) {
    if (!isNumber12(value)) {
      throw new Error(`[uitext] borderRadius not a number`);
    }
    if (this._borderRadius === value) return;
    this._borderRadius = value;
    this.ui?.redraw();
  }
  get margin() {
    return this._margin;
  }
  set margin(value = defaults14.margin) {
    if (!isEdge3(value)) {
      throw new Error(`[uitext] margin not a number or array of numbers`);
    }
    if (this._margin === value) return;
    this._margin = value;
    if (isArray5(this._margin)) {
      const [top, right, bottom, left] = this._margin;
      this.yogaNode?.setMargin(Yoga4.EDGE_TOP, top * this.ui._res);
      this.yogaNode?.setMargin(Yoga4.EDGE_RIGHT, right * this.ui._res);
      this.yogaNode?.setMargin(Yoga4.EDGE_BOTTOM, bottom * this.ui._res);
      this.yogaNode?.setMargin(Yoga4.EDGE_LEFT, left * this.ui._res);
    } else {
      this.yogaNode?.setMargin(Yoga4.EDGE_ALL, this._margin * this.ui._res);
    }
    this.ui?.redraw();
  }
  get padding() {
    return this._padding;
  }
  set padding(value = defaults14.padding) {
    if (!isEdge3(value)) {
      throw new Error(`[uitext] padding not a number or array of numbers`);
    }
    if (this._padding === value) rturn;
    this._padding = value;
    if (isArray5(this._padding)) {
      const [top, right, bottom, left] = this._padding;
      this.yogaNode?.setPadding(Yoga4.EDGE_TOP, top * this.ui._res);
      this.yogaNode?.setPadding(Yoga4.EDGE_RIGHT, right * this.ui._res);
      this.yogaNode?.setPadding(Yoga4.EDGE_BOTTOM, bottom * this.ui._res);
      this.yogaNode?.setPadding(Yoga4.EDGE_LEFT, left * this.ui._res);
    } else {
      this.yogaNode?.setPadding(Yoga4.EDGE_ALL, this._padding * this.ui._res);
    }
    this.ui?.redraw();
  }
  get value() {
    return this._value;
  }
  set value(val = defaults14.value) {
    if (isNumber12(val)) {
      val = val + "";
    }
    if (!isString11(val)) {
      throw new Error(`[uitext] value not a string`);
    }
    if (this._value === val) return;
    this._value = val;
    this.yogaNode?.markDirty();
    this.ui?.redraw();
  }
  get fontSize() {
    return this._fontSize;
  }
  set fontSize(value = defaults14.fontSize) {
    if (!isNumber12(value)) {
      throw new Error(`[uitext] fontSize not a number`);
    }
    if (this._fontSize === value) return;
    this._fontSize = value;
    this.yogaNode?.markDirty();
    this.ui?.redraw();
  }
  get color() {
    return this._color;
  }
  set color(value = defaults14.color) {
    if (!isString11(value)) {
      throw new Error(`[uitext] color not a string`);
    }
    if (this._color === value) return;
    this._color = value;
    this.ui?.redraw();
  }
  get lineHeight() {
    return this._lineHeight;
  }
  set lineHeight(value = defaults14.lineHeight) {
    if (!isNumber12(value)) {
      throw new Error(`[uitext] lineHeight not a number`);
    }
    if (this._lineHeight === value) return;
    this._lineHeight = value;
    this.yogaNode?.markDirty();
    this.ui?.redraw();
  }
  get textAlign() {
    return this._textAlign;
  }
  set textAlign(value = defaults14.textAlign) {
    if (!isTextAlign(value)) {
      throw new Error(`[uitext] textAlign invalid: ${value}`);
    }
    if (this._textAlign === value) return;
    this._textAlign = value;
    this.yogaNode?.markDirty();
    this.ui?.redraw();
  }
  get fontFamily() {
    return this._fontFamily;
  }
  set fontFamily(value = defaults14.fontFamily) {
    if (!isString11(value)) {
      throw new Error(`[uitext] fontFamily not a string`);
    }
    if (this._fontFamily === value) return;
    this._fontFamily = value;
    this.yogaNode?.markDirty();
    this.ui?.redraw();
  }
  get fontWeight() {
    return this._fontWeight;
  }
  set fontWeight(value = defaults14.fontWeight) {
    if (!isString11(value) && !isNumber12(value)) {
      throw new Error(`[uitext] fontWeight invalid`);
    }
    if (this._fontWeight === value) return;
    this._fontWeight = value;
    this.yogaNode?.markDirty();
    this.ui?.redraw();
  }
  get flexBasis() {
    return this._flexBasis;
  }
  set flexBasis(value = defaults14.flexBasis) {
    if (!isNumber12(value) && !isString11(value)) {
      throw new Error(`[uitext] flexBasis invalid`);
    }
    if (this._flexBasis === value) return;
    this._flexBasis = value;
    this.yogaNode?.setFlexBasis(this._flexBasis);
    this.ui?.redraw();
  }
  get flexGrow() {
    return this._flexGrow;
  }
  set flexGrow(value = defaults14.flexGrow) {
    if (!isNumber12(value)) {
      throw new Error(`[uitext] flexGrow not a number`);
    }
    if (this._flexGrow === value) return;
    this._flexGrow = value;
    this.yogaNode?.setFlexGrow(this._flexGrow);
    this.ui?.redraw();
  }
  get flexShrink() {
    return this._flexShrink;
  }
  set flexShrink(value = defaults14.flexShrink) {
    if (!isNumber12(value)) {
      throw new Error(`[uitext] flexShrink not a number`);
    }
    if (this._flexShrink === value) return;
    this._flexShrink = value;
    this.yogaNode?.setFlexShrink(this._flexShrink);
    this.ui?.redraw();
  }
  getProxy() {
    var self2 = this;
    if (!this.proxy) {
      let proxy = {
        get display() {
          return self2.display;
        },
        set display(value) {
          self2.display = value;
        },
        get absolute() {
          return self2.absolute;
        },
        set absolute(value) {
          self2.absolute = value;
        },
        get top() {
          return self2.top;
        },
        set top(value) {
          self2.top = value;
        },
        get right() {
          return self2.right;
        },
        set right(value) {
          self2.right = value;
        },
        get bottom() {
          return self2.bottom;
        },
        set bottom(value) {
          self2.bottom = value;
        },
        get left() {
          return self2.left;
        },
        set left(value) {
          self2.left = value;
        },
        get backgroundColor() {
          return self2.backgroundColor;
        },
        set backgroundColor(value) {
          self2.backgroundColor = value;
        },
        get borderRadius() {
          return self2.borderRadius;
        },
        set borderRadius(value) {
          self2.borderRadius = value;
        },
        get margin() {
          return self2.margin;
        },
        set margin(value) {
          self2.margin = value;
        },
        get padding() {
          return self2.padding;
        },
        set padding(value) {
          self2.padding = value;
        },
        get value() {
          return self2.value;
        },
        set value(value) {
          self2.value = value;
        },
        get fontSize() {
          return self2.fontSize;
        },
        set fontSize(value) {
          self2.fontSize = value;
        },
        get color() {
          return self2.color;
        },
        set color(value) {
          self2.color = value;
        },
        get lineHeight() {
          return self2.lineHeight;
        },
        set lineHeight(value) {
          self2.lineHeight = value;
        },
        get textAlign() {
          return self2.textAlign;
        },
        set textAlign(value) {
          self2.textAlign = value;
        },
        get fontFamily() {
          return self2.fontFamily;
        },
        set fontFamily(value) {
          self2.fontFamily = value;
        },
        get fontWeight() {
          return self2.fontWeight;
        },
        set fontWeight(value) {
          self2.fontWeight = value;
        },
        get flexBasis() {
          return self2.flexBasis;
        },
        set flexBasis(value) {
          self2.flexBasis = value;
        },
        get flexGrow() {
          return self2.flexGrow;
        },
        set flexGrow(value) {
          self2.flexGrow = value;
        },
        get flexShrink() {
          return self2.flexShrink;
        },
        set flexShrink(value) {
          self2.flexShrink = value;
        }
      };
      proxy = Object.defineProperties(proxy, Object.getOwnPropertyDescriptors(super.getProxy()));
      this.proxy = proxy;
    }
    return this.proxy;
  }
};
function wrapText(ctx, text, maxWidth) {
  const words = text.split(" ");
  const lines = [];
  let currentLine = words[0];
  for (let i5 = 1; i5 < words.length; i5++) {
    const word = words[i5];
    const width = ctx.measureText(currentLine + " " + word).width;
    if (width <= maxWidth) {
      currentLine += " " + word;
    } else {
      lines.push(currentLine);
      currentLine = word;
    }
  }
  lines.push(currentLine);
  return lines;
}
function isTextAlign(value) {
  return textAligns.includes(value);
}
function isEdge3(value) {
  if (isNumber12(value)) {
    return true;
  }
  if (isArray5(value)) {
    return value.length === 4 && every5(value, (n6) => isNumber12(n6));
  }
  return false;
}

// src/core/nodes/UIImage.js
import Yoga5 from "yoga-layout";
import { every as every6, isArray as isArray6, isBoolean as isBoolean11, isNumber as isNumber13, isString as isString12 } from "lodash-es";
var objectFits = ["contain", "cover", "fill"];
var defaults15 = {
  display: "flex",
  src: null,
  width: null,
  height: null,
  absolute: false,
  top: null,
  right: null,
  bottom: null,
  left: null,
  objectFit: "contain",
  backgroundColor: null,
  borderRadius: 0,
  margin: 0
};
var UIImage = class extends Node {
  constructor(data = {}) {
    super(data);
    this.name = "uiimage";
    this.display = data.display;
    this.src = data.src;
    this.width = data.width;
    this.height = data.height;
    this.absolute = data.absolute;
    this.top = data.top;
    this.right = data.right;
    this.bottom = data.bottom;
    this.left = data.left;
    this.objectFit = data.objectFit;
    this.backgroundColor = data.backgroundColor;
    this.borderRadius = data.borderRadius;
    this.margin = data.margin;
    this.img = null;
  }
  draw(ctx, offsetLeft, offsetTop) {
    if (this._display === "none") return;
    const left = offsetLeft + this.yogaNode.getComputedLeft();
    const top = offsetTop + this.yogaNode.getComputedTop();
    const width = this.yogaNode.getComputedWidth();
    const height = this.yogaNode.getComputedHeight();
    if (this._backgroundColor) {
      fillRoundRect(ctx, left, top, width, height, this._borderRadius * this.ui._res, this._backgroundColor);
    }
    if (this.img) {
      const drawParams = this.calculateDrawParameters(this.img.width, this.img.height, width, height);
      imageRoundRect(
        ctx,
        left,
        top,
        width,
        height,
        this._borderRadius * this.ui._res,
        this.img,
        left + drawParams.x,
        top + drawParams.y,
        drawParams.width,
        drawParams.height
      );
    }
    this.box = { left, top, width, height };
  }
  mount() {
    if (this.ctx.world.network.isServer) return;
    this.ui = this.parent?.ui;
    if (!this.ui) return console.error("uiimage: must be child of ui node");
    this.yogaNode = Yoga5.Node.create();
    this.yogaNode.setDisplay(Display[this._display]);
    this.yogaNode.setPositionType(this._absolute ? Yoga5.POSITION_TYPE_ABSOLUTE : Yoga5.POSITION_TYPE_RELATIVE);
    this.yogaNode.setPosition(Yoga5.EDGE_TOP, isNumber13(this._top) ? this._top * this.ui._res : void 0);
    this.yogaNode.setPosition(Yoga5.EDGE_RIGHT, isNumber13(this._right) ? this._right * this.ui._res : void 0);
    this.yogaNode.setPosition(Yoga5.EDGE_BOTTOM, isNumber13(this._bottom) ? this._bottom * this.ui._res : void 0);
    this.yogaNode.setPosition(Yoga5.EDGE_LEFT, isNumber13(this._left) ? this._left * this.ui._res : void 0);
    if (isArray6(this._margin)) {
      const [top, right, bottom, left] = this._margin;
      this.yogaNode.setMargin(Yoga5.EDGE_TOP, top * this.ui._res);
      this.yogaNode.setMargin(Yoga5.EDGE_RIGHT, right * this.ui._res);
      this.yogaNode.setMargin(Yoga5.EDGE_BOTTOM, bottom * this.ui._res);
      this.yogaNode.setMargin(Yoga5.EDGE_LEFT, left * this.ui._res);
    } else {
      this.yogaNode.setMargin(Yoga5.EDGE_ALL, this._margin * this.ui._res);
    }
    this.yogaNode.setMeasureFunc((width, widthMode, height, heightMode) => {
      if (!this.img) {
        return { width: 0, height: 0 };
      }
      const imgAspectRatio = this.img.width / this.img.height;
      let finalWidth;
      let finalHeight;
      if (this._width !== null && this._height !== null) {
        return {
          width: this._width * this.ui._res,
          height: this._height * this.ui._res
        };
      }
      if (this._width !== null) {
        finalWidth = this._width * this.ui._res;
        finalHeight = finalWidth / imgAspectRatio;
      } else if (this._height !== null) {
        finalHeight = this._height * this.ui._res;
        finalWidth = finalHeight * imgAspectRatio;
      } else {
        if (widthMode === Yoga5.MEASURE_MODE_EXACTLY) {
          finalWidth = width;
          finalHeight = width / imgAspectRatio;
        } else if (widthMode === Yoga5.MEASURE_MODE_AT_MOST) {
          finalWidth = Math.min(this.img.width * this.ui._res, width);
          finalHeight = finalWidth / imgAspectRatio;
        } else {
          finalWidth = this.img.width * this.ui._res;
          finalHeight = this.img.height * this.ui._res;
        }
        if (heightMode === Yoga5.MEASURE_MODE_EXACTLY) {
          finalHeight = height;
          if (this._objectFit === "contain") {
            finalWidth = Math.min(finalWidth, height * imgAspectRatio);
          }
        } else if (heightMode === Yoga5.MEASURE_MODE_AT_MOST && finalHeight > height) {
          finalHeight = height;
          finalWidth = height * imgAspectRatio;
        }
      }
      return { width: finalWidth, height: finalHeight };
    });
    this.parent.yogaNode.insertChild(this.yogaNode, this.parent.yogaNode.getChildCount());
    if (this._src && !this.img) {
      this.loadImage(this._src);
    }
    this.ui?.redraw();
  }
  commit() {
  }
  unmount() {
    if (this.ctx.world.network.isServer) return;
    if (this.yogaNode) {
      this.parent.yogaNode?.removeChild(this.yogaNode);
      this.yogaNode.free();
      this.yogaNode = null;
      this.box = null;
      this.img = null;
      this.ui?.redraw();
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this._display = source._display;
    this._src = source._src;
    this._width = source._width;
    this._height = source._height;
    this._absolute = source._absolute;
    this._top = source._top;
    this._right = source._right;
    this._bottom = source._bottom;
    this._left = source._left;
    this._objectFit = source._objectFit;
    this._backgroundColor = source._backgroundColor;
    this._margin = source._margin;
    return this;
  }
  async loadImage(src) {
    if (!this.ctx?.world) return;
    const url = this.ctx.world.resolveURL(src);
    this.img = this.ctx.world.loader.get("image", url);
    if (!this.img) {
      this.img = await this.ctx.world.loader.load("image", url);
    }
    if (!this.ui) return;
    this.yogaNode?.markDirty();
    this.ui?.redraw();
  }
  calculateDrawParameters(imgWidth, imgHeight, containerWidth, containerHeight) {
    const aspectRatio = imgWidth / imgHeight;
    switch (this._objectFit) {
      case "cover": {
        if (containerWidth / containerHeight > aspectRatio) {
          const width = containerWidth;
          const height = width / aspectRatio;
          return {
            width,
            height,
            x: 0,
            y: (containerHeight - height) / 2
          };
        } else {
          const height = containerHeight;
          const width = height * aspectRatio;
          return {
            width,
            height,
            x: (containerWidth - width) / 2,
            y: 0
          };
        }
      }
      case "contain": {
        if (containerWidth / containerHeight > aspectRatio) {
          const height = containerHeight;
          const width = height * aspectRatio;
          return {
            width,
            height,
            x: (containerWidth - width) / 2,
            y: 0
          };
        } else {
          const width = containerWidth;
          const height = width / aspectRatio;
          return {
            width,
            height,
            x: 0,
            y: (containerHeight - height) / 2
          };
        }
      }
      case "fill":
      default:
        return {
          width: containerWidth,
          height: containerHeight,
          x: 0,
          y: 0
        };
    }
  }
  get display() {
    return this._display;
  }
  set display(value = defaults15.display) {
    if (!isDisplay(value)) {
      throw new Error(`[uiimage] display invalid: ${value}`);
    }
    if (this._display === value) return;
    this._display = value;
    this.yogaNode?.setDisplay(Display[this._display]);
    this.ui?.redraw();
  }
  get absolute() {
    return this._absolute;
  }
  set absolute(value = defaults15.absolute) {
    if (!isBoolean11(value)) {
      throw new Error(`[uiimage] absolute not a boolean`);
    }
    if (this._absolute === value) return;
    this._absolute = value;
    this.yogaNode?.setPositionType(this._absolute ? Yoga5.POSITION_TYPE_ABSOLUTE.ABSOLUTE : Yoga5.POSITION_TYPE_RELATIVE);
    this.ui?.redraw();
  }
  get top() {
    return this._top;
  }
  set top(value = defaults15.top) {
    const isNum = isNumber13(value);
    if (value !== null && !isNum) {
      throw new Error(`[uiimage] top must be a number or null`);
    }
    if (this._top === value) return;
    this._top = value;
    this.yogaNode?.setPosition(Yoga5.EDGE_TOP, isNum ? this._top * this.ui._res : void 0);
    this.ui?.redraw();
  }
  get right() {
    return this._right;
  }
  set right(value = defaults15.right) {
    const isNum = isNumber13(value);
    if (value !== null && !isNum) {
      throw new Error(`[uiimage] right must be a number or null`);
    }
    if (this._right === value) return;
    this._right = value;
    this.yogaNode?.setPosition(Yoga5.EDGE_RIGHT, isNum ? this._right * this.ui._res : void 0);
    this.ui?.redraw();
  }
  get bottom() {
    return this._bottom;
  }
  set bottom(value = defaults15.bottom) {
    const isNum = isNumber13(value);
    if (value !== null && !isNum) {
      throw new Error(`[uiimage] bottom must be a number or null`);
    }
    if (this._bottom === value) return;
    this._bottom = value;
    this.yogaNode?.setPosition(Yoga5.EDGE_BOTTOM, isNum ? this._bottom * this.ui._res : void 0);
    this.ui?.redraw();
  }
  get left() {
    return this._left;
  }
  set left(value = defaults15.left) {
    const isNum = isNumber13(value);
    if (value !== null && !isNum) {
      throw new Error(`[uiimage] left must be a number or null`);
    }
    if (this._left === value) return;
    this._left = value;
    this.yogaNode?.setPosition(Yoga5.EDGE_LEFT, isNum ? this._left * this.ui._res : void 0);
    this.ui?.redraw();
  }
  get src() {
    return this._src;
  }
  set src(value = defaults15.src) {
    if (value !== null && !isString12(value)) {
      throw new Error(`[uiimage] src not a string`);
    }
    if (this._src === value) return;
    this._src = value;
    if (this._src) {
      this.loadImage(this._src);
    } else {
      this.img = null;
      this.ui?.redraw();
    }
  }
  get width() {
    return this._width;
  }
  set width(value = defaults15.width) {
    if (value !== null && !isNumber13(value)) {
      throw new Error(`[uiimage] width not a number`);
    }
    if (this._width === value) return;
    this._width = value;
    this.yogaNode?.markDirty();
    this.ui?.redraw();
  }
  get height() {
    return this._height;
  }
  set height(value = defaults15.height) {
    if (value !== null && !isNumber13(value)) {
      throw new Error(`[uiimage] height not a number`);
    }
    if (this._height === value) return;
    this._height = value;
    this.yogaNode?.markDirty();
    this.ui?.redraw();
  }
  get objectFit() {
    return this._objectFit;
  }
  set objectFit(value = defaults15.objectFit) {
    if (!isObjectFit(value)) {
      throw new Error(`[uiimage] objectFit invalid: ${value}`);
    }
    if (this._objectFit === value) return;
    this._objectFit = value;
    this.ui?.redraw();
  }
  get backgroundColor() {
    return this._backgroundColor;
  }
  set backgroundColor(value = defaults15.backgroundColor) {
    if (value !== null && !isString12(value)) {
      throw new Error(`[uiimage] backgroundColor not a string`);
    }
    if (this._backgroundColor === value) return;
    this._backgroundColor = value;
    this.ui?.redraw();
  }
  get borderRadius() {
    return this._borderRadius;
  }
  set borderRadius(value = defaults15.borderRadius) {
    if (!isNumber13(value)) {
      throw new Error("[uiimage] borderRadius not a number");
    }
    if (this._borderRadius === value) return;
    this._borderRadius = value;
    this.ui?.redraw();
  }
  get margin() {
    return this._margin;
  }
  set margin(value = defaults15.margin) {
    if (!isEdge4(value)) {
      throw new Error(`[uiimage] margin not a number or array of numbers`);
    }
    if (this._margin === value) return;
    this._margin = value;
    if (isArray6(this._margin)) {
      const [top, right, bottom, left] = this._margin;
      this.yogaNode?.setMargin(Yoga5.EDGE_TOP, top * this.ui._res);
      this.yogaNode?.setMargin(Yoga5.EDGE_RIGHT, right * this.ui._res);
      this.yogaNode?.setMargin(Yoga5.EDGE_BOTTOM, bottom * this.ui._res);
      this.yogaNode?.setMargin(Yoga5.EDGE_LEFT, left * this.ui._res);
    } else {
      this.yogaNode?.setMargin(Yoga5.EDGE_ALL, this._margin * this.ui._res);
    }
    this.ui?.redraw();
  }
  getProxy() {
    if (!this.proxy) {
      const self2 = this;
      let proxy = {
        get display() {
          return self2.display;
        },
        set display(value) {
          self2.display = value;
        },
        get absolute() {
          return self2.absolute;
        },
        set absolute(value) {
          self2.absolute = value;
        },
        get top() {
          return self2.top;
        },
        set top(value) {
          self2.top = value;
        },
        get right() {
          return self2.right;
        },
        set right(value) {
          self2.right = value;
        },
        get bottom() {
          return self2.bottom;
        },
        set bottom(value) {
          self2.bottom = value;
        },
        get left() {
          return self2.left;
        },
        set left(value) {
          self2.left = value;
        },
        get src() {
          return self2.src;
        },
        set src(value) {
          self2.src = value;
        },
        get width() {
          return self2.width;
        },
        set width(value) {
          self2.width = value;
        },
        get height() {
          return self2.height;
        },
        set height(value) {
          self2.height = value;
        },
        get objectFit() {
          return self2.objectFit;
        },
        set objectFit(value) {
          self2.objectFit = value;
        },
        get backgroundColor() {
          return self2.backgroundColor;
        },
        set backgroundColor(value) {
          self2.backgroundColor = value;
        },
        get borderRadius() {
          return self2.borderRadius;
        },
        set borderRadius(value) {
          self2.borderRadius = value;
        },
        get margin() {
          return self2.margin;
        },
        set margin(value) {
          self2.margin = value;
        }
      };
      proxy = Object.defineProperties(proxy, Object.getOwnPropertyDescriptors(super.getProxy()));
      this.proxy = proxy;
    }
    return this.proxy;
  }
};
function isObjectFit(value) {
  return objectFits.includes(value);
}
function isEdge4(value) {
  if (isNumber13(value)) {
    return true;
  }
  if (isArray6(value)) {
    return value.length === 4 && every6(value, (n6) => isNumber13(n6));
  }
  return false;
}

// src/core/nodes/Controller.js
import { isNumber as isNumber14, isBoolean as isBoolean12, isString as isString13, isFunction as isFunction4 } from "lodash-es";

// src/core/extras/general.js
var DEG2RAD = three_exports.MathUtils.DEG2RAD;
var RAD2DEG = three_exports.MathUtils.RAD2DEG;

// src/core/nodes/Controller.js
var layers = ["environment", "prop", "player", "tool"];
var defaults16 = {
  radius: 0.4,
  height: 1,
  visible: false,
  layer: "environment",
  tag: null,
  onContactStart: null,
  onContactEnd: null
};
var Controller = class extends Node {
  constructor(data = {}) {
    super(data);
    this.name = "controller";
    this.radius = data.radius;
    this.height = data.height;
    this.visible = data.visible;
    this.layer = data.layer;
    this.tag = data.tag;
    this.onContactStart = data.onContactStart;
    this.onContactEnd = data.onContactEnd;
  }
  mount() {
    this.needsRebuild = false;
    if (this._visible) {
      const geometry = new three_exports.CapsuleGeometry(this._radius, this._height, 2, 8);
      geometry.translate(0, this._height / 2 + this._radius, 0);
      geometry.computeBoundsTree();
      const material2 = new three_exports.MeshStandardMaterial({ color: "green" });
      this.mesh = new three_exports.Mesh(geometry, material2);
      this.mesh.receiveShadow = true;
      this.mesh.castShadow = true;
      this.mesh.matrixAutoUpdate = false;
      this.mesh.matrixWorldAutoUpdate = false;
      this.mesh.matrix.copy(this.matrix);
      this.mesh.matrixWorld.copy(this.matrixWorld);
      this.mesh.node = this;
      this.ctx.world.graphics.scene.add(this.mesh);
    }
    const desc = new PHYSX.PxCapsuleControllerDesc();
    desc.height = this._height;
    desc.radius = this._radius;
    desc.climbingMode = PHYSX.PxCapsuleClimbingModeEnum.eCONSTRAINED;
    desc.slopeLimit = Math.cos(60 * DEG2RAD);
    desc.material = this.ctx.world.physics.defaultMaterial;
    desc.contactOffset = 0.1;
    desc.stepOffset = 0.5;
    this.controller = this.ctx.world.physics.controllerManager.createController(desc);
    PHYSX.destroy(desc);
    const worldPosition = this.getWorldPosition();
    this.controller.setFootPosition(worldPosition.toPxExtVec3());
    const actor = this.controller.getActor();
    const nbShapes = actor.getNbShapes();
    const shapeBuffer = new PHYSX.PxArray_PxShapePtr(nbShapes);
    const shapesCount = actor.getShapes(shapeBuffer.begin(), nbShapes, 0);
    for (let i5 = 0; i5 < shapesCount; i5++) {
      const shape = shapeBuffer.get(i5);
      const layer = Layers[this._layer];
      let pairFlags = PHYSX.PxPairFlagEnum.eNOTIFY_TOUCH_FOUND | PHYSX.PxPairFlagEnum.eNOTIFY_TOUCH_LOST | PHYSX.PxPairFlagEnum.eNOTIFY_CONTACT_POINTS;
      const filterData = new PHYSX.PxFilterData(layer.group, layer.mask, pairFlags, 0);
      const shapeFlags = new PHYSX.PxShapeFlags();
      shapeFlags.raise(PHYSX.PxShapeFlagEnum.eSCENE_QUERY_SHAPE | PHYSX.PxShapeFlagEnum.eSIMULATION_SHAPE);
      shape.setFlags(shapeFlags);
      shape.setQueryFilterData(filterData);
      shape.setSimulationFilterData(filterData);
    }
    const self2 = this;
    this.actorHandle = this.ctx.world.physics.addActor(actor, {
      controller: true,
      node: self2,
      get tag() {
        return self2._tag;
      },
      playerId: null,
      get onContactStart() {
        return self2._onContactStart;
      },
      get onContactEnd() {
        return self2._onContactEnd;
      },
      onTriggerEnter: null,
      onTriggerLeave: null
    });
  }
  commit(didMove) {
    if (this.needsRebuild) {
      this.unmount();
      this.mount();
      return;
    }
    if (didMove) {
      this.mesh?.matrix.copy(this.matrix);
      this.mesh?.matrixWorld.copy(this.matrixWorld);
    }
  }
  unmount() {
    if (this.mesh) {
      this.ctx.world.graphics.scene.remove(this.mesh);
    }
    this.actorHandle?.destroy();
    this.actorHandle = null;
    this.controller?.release();
    this.controller = null;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this._radius = source._radius;
    this._height = source._height;
    this._visible = source._visible;
    this._layer = source._layer;
    this._tag = source._tag;
    this._onContactStart = source._onContactStart;
    this._onContactEnd = source._onContactEnd;
    return this;
  }
  get radius() {
    return this._radius;
  }
  set radius(value = defaults16.radius) {
    if (!isNumber14(value)) {
      throw new Error("[controller] radius not a number");
    }
    this._radius = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get height() {
    return this._height;
  }
  set height(value = defaults16.height) {
    if (!isNumber14(value)) {
      throw new Error("[controller] height not a number");
    }
    this._height = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get visible() {
    return this._visible;
  }
  set visible(value = defaults16.visible) {
    if (!isBoolean12(value)) {
      throw new Error("[controller] visible not a boolean");
    }
    this._visible = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get layer() {
    return this._layer;
  }
  set layer(value = defaults16.layer) {
    if (!isLayer(value)) {
      throw new Error(`[controller] invalid layer: ${value}`);
    }
    this._layer = value;
    if (this.controller) {
      this.needsRebuild = true;
      this.setDirty();
    }
  }
  get tag() {
    return this._tag;
  }
  set tag(value = defaults16.tag) {
    if (isNumber14(value)) {
      value = value + "";
    }
    if (value !== null && !isString13(value)) {
      throw new Error("[controller] tag not a string");
    }
    this._tag = value;
  }
  get onContactStart() {
    return this._onContactStart;
  }
  set onContactStart(value = defaults16.onContactStart) {
    if (value !== null && !isFunction4(value)) {
      throw new Error("[controller] onContactStart not a function");
    }
    this._onContactStart = value;
  }
  get onContactEnd() {
    return this._onContactEnd;
  }
  set onContactEnd(value = defaults16.onContactEnd) {
    if (value !== null && !isFunction4(value)) {
      throw new Error("[controller] onContactEnd not a function");
    }
    this._onContactEnd = value;
  }
  get isGrounded() {
    return this.moveFlags.isSet(PHYSX.PxControllerCollisionFlagEnum.eCOLLISION_DOWN);
  }
  get isCeiling() {
    return this.moveFlags.isSet(PHYSX.PxControllerCollisionFlagEnum.eCOLLISION_UP);
  }
  teleport(vec3) {
    if (!vec3?.isVector3) {
      throw new Error("[controller] teleport expected Vector3");
    }
    this.position.copy(vec3);
    this.controller.setFootPosition(vec3.toPxExtVec3());
  }
  move(vec3) {
    if (!vec3?.isVector3) {
      throw new Error("[controller] move expected Vector3");
    }
    if (!this.controller) return;
    this.moveFlags = this.controller.move(vec3.toPxVec3(), 0, 1 / 60, this.ctx.world.physics.controllerFilters);
    const pos = this.controller.getFootPosition();
    this.position.copy(pos);
    this.didMove = true;
  }
  getProxy() {
    if (!this.proxy) {
      const self2 = this;
      let proxy = {
        get radius() {
          return self2.radius;
        },
        set radius(value) {
          self2.radius = value;
        },
        get height() {
          return self2.height;
        },
        set height(value) {
          self2.height = value;
        },
        get visible() {
          return self2.visible;
        },
        set visible(value) {
          self2.visible = value;
        },
        get layer() {
          return self2.layer;
        },
        set layer(value) {
          if (value === "player") {
            throw new Error("[controller] layer invalid: player");
          }
          self2.layer = value;
        },
        get tag() {
          return self2.tag;
        },
        set tag(value) {
          self2.tag = value;
        },
        get onContactStart() {
          return self2.onContactStart;
        },
        set onContactStart(value) {
          self2.onContactStart = value;
        },
        get onContactEnd() {
          return self2.onContactEnd;
        },
        set onContactEnd(value) {
          self2.onContactEnd = value;
        },
        get isGrounded() {
          return self2.isGrounded;
        },
        get isCeiling() {
          return self2.isCeiling;
        },
        teleport(vec3) {
          return self2.teleport(vec3);
        },
        move(vec3) {
          return self2.move(vec3);
        }
      };
      proxy = Object.defineProperties(proxy, Object.getOwnPropertyDescriptors(super.getProxy()));
      this.proxy = proxy;
    }
    return this.proxy;
  }
};
function isLayer(value) {
  return layers.includes(value);
}

// src/core/nodes/RigidBody.js
import { isFunction as isFunction5, isNumber as isNumber15, isString as isString14 } from "lodash-es";
var _v13 = new Vector3Enhanced();
var _v23 = new Vector3Enhanced();
var _q12 = new three_exports.Quaternion();
var _m12 = new three_exports.Matrix4();
var _m22 = new three_exports.Matrix4();
var _m32 = new three_exports.Matrix4();
var _defaultScale = new Vector3Enhanced(1, 1, 1);
var types2 = ["static", "kinematic", "dynamic"];
var defaults17 = {
  type: "static",
  mass: 1,
  linearDamping: 0,
  // physx default
  angularDamping: 0.05,
  // phyx default
  tag: null,
  onContactStart: null,
  onContactEnd: null,
  onTriggerEnter: null,
  onTriggerLeave: null
};
var forceModes;
function getForceMode(mode) {
  if (!forceModes) {
    forceModes = {
      force: PHYSX.PxForceModeEnum.eFORCE,
      impulse: PHYSX.PxForceModeEnum.eIMPULSE,
      acceleration: PHYSX.PxForceModeEnum.eACCELERATION,
      velocityChange: PHYSX.PxForceModeEnum.eVELOCITY_CHANGE
    };
  }
  return forceModes[mode] || forceModes.force;
}
var RigidBody = class extends Node {
  constructor(data = {}) {
    super(data);
    this.name = "rigidbody";
    this.shapes = /* @__PURE__ */ new Set();
    this.type = data.type;
    this.mass = data.mass;
    this.linearDamping = data.linearDamping;
    this.angularDamping = data.angularDamping;
    this.tag = data.tag;
    this.onContactStart = data.onContactStart;
    this.onContactEnd = data.onContactEnd;
    this.onTriggerEnter = data.onTriggerEnter;
    this.onTriggerLeave = data.onTriggerLeave;
    this._tm = new PHYSX.PxTransform(PHYSX.PxIDENTITYEnum.PxIdentity);
    this.tempVec3 = new Vector3Enhanced();
    this.tempQuat = new three_exports.Quaternion();
  }
  mount() {
    this.needsRebuild = false;
    if (this.ctx.moving) return;
    this.matrixWorld.decompose(_v13, _q12, _v23);
    this.transform = new PHYSX.PxTransform(PHYSX.PxIDENTITYEnum.PxIdentity);
    _v13.toPxTransform(this.transform);
    _q12.toPxTransform(this.transform);
    if (this._type === "static") {
      this.actor = this.ctx.world.physics.physics.createRigidStatic(this.transform);
    } else if (this._type === "kinematic") {
      this.actor = this.ctx.world.physics.physics.createRigidDynamic(this.transform);
      this.actor.setRigidBodyFlag(PHYSX.PxRigidBodyFlagEnum.eKINEMATIC, true);
      PHYSX.PxRigidBodyExt.prototype.setMassAndUpdateInertia(this.actor, this._mass);
    } else if (this._type === "dynamic") {
      this.actor = this.ctx.world.physics.physics.createRigidDynamic(this.transform);
      PHYSX.PxRigidBodyExt.prototype.setMassAndUpdateInertia(this.actor, this._mass);
      if (this._centerOfMass) {
        const pose = new PHYSX.PxTransform(PHYSX.PxIDENTITYEnum.PxIdentity);
        this._centerOfMass.toPxTransform(pose);
        this.actor.setCMassLocalPose(pose);
      }
      this.actor.setLinearDamping(this._linearDamping);
      this.actor.setAngularDamping(this._angularDamping);
    }
    for (const shape of this.shapes) {
      this.actor.attachShape(shape);
    }
    const self2 = this;
    const playerId = this.ctx.entity?.isPlayer ? this.ctx.entity.data.id : null;
    this.actorHandle = this.ctx.world.physics.addActor(this.actor, {
      onInterpolate: this._type === "kinematic" || this._type === "dynamic" ? this.onInterpolate : null,
      node: this,
      get tag() {
        return self2._tag;
      },
      get playerId() {
        return playerId;
      },
      get onContactStart() {
        return self2._onContactStart;
      },
      get onContactEnd() {
        return self2._onContactEnd;
      },
      get onTriggerEnter() {
        return self2._onTriggerEnter;
      },
      get onTriggerLeave() {
        return self2._onTriggerLeave;
      }
    });
  }
  commit(didMove) {
    if (this.needsRebuild) {
      this.unmount();
      this.mount();
      return;
    }
    if (didMove) {
      this.actorHandle?.move(this.matrixWorld);
    }
  }
  onInterpolate = (position, quaternion) => {
    if (this.parent) {
      _m12.compose(position, quaternion, _defaultScale);
      _m22.copy(this.parent.matrixWorld).invert();
      _m32.multiplyMatrices(_m22, _m12);
      _m32.decompose(this.position, this.quaternion, _v13);
    } else {
      this.position.copy(position);
      this.quaternion.copy(quaternion);
    }
  };
  unmount() {
    if (this.actor) {
      this.actorHandle?.destroy();
      this.actorHandle = null;
      this.actor.release();
      this.actor = null;
    }
  }
  addShape(shape) {
    if (!shape) return;
    this.shapes.add(shape);
    if (this.actor) {
      this.actor.attachShape(shape);
    }
  }
  removeShape(shape) {
    if (!shape) return;
    this.shapes.delete(shape);
    if (this.actor) {
      this.actor.detachShape(shape);
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this._type = source._type;
    this._mass = source._mass;
    this._tag = source._tag;
    this._onContactStart = source._onContactStart;
    this._onContactEnd = source._onContactEnd;
    this._onTriggerEnter = source._onTriggerEnter;
    this._onTriggerLeave = source._onTriggerLeave;
    return this;
  }
  get type() {
    return this._type;
  }
  set type(value = defaults17.type) {
    if (!isType2(value)) {
      throw new Error(`[rigidbody] type invalid: ${value}`);
    }
    if (this._type === value) return;
    this._type = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get mass() {
    return this._mass;
  }
  set mass(value = defaults17.mass) {
    if (!isNumber15(value)) {
      throw new Error("[rigidbody] mass not a number");
    }
    if (value < 0) {
      throw new Error("[rigidbody] mass cannot be less than zero");
    }
    this._mass = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get linearDamping() {
    return this._linearDamping;
  }
  set linearDamping(value = defaults17.linearDamping) {
    if (!isNumber15(value)) {
      throw new Error("[rigidbody] linearDamping not a number");
    }
    if (value < 0) {
      throw new Error("[rigidbody] linearDamping cannot be less than zero");
    }
    this._linearDamping = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get angularDamping() {
    return this._angularDamping;
  }
  set angularDamping(value = defaults17.angularDamping) {
    if (!isNumber15(value)) {
      throw new Error("[rigidbody] angularDamping not a number");
    }
    if (value < 0) {
      throw new Error("[rigidbody] angularDamping cannot be less than zero");
    }
    this._angularDamping = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get tag() {
    return this._tag;
  }
  set tag(value = defaults17.tag) {
    if (isNumber15(value)) {
      value = value + "";
    }
    if (value !== null && !isString14(value)) {
      throw new Error("[rigidbody] tag not a string");
    }
    this._tag = value;
  }
  get onContactStart() {
    return this._onContactStart;
  }
  set onContactStart(value = defaults17.onContactStart) {
    if (value !== null && !isFunction5(value)) {
      throw new Error("[rigidbody] onContactStart not a function");
    }
    this._onContactStart = value;
  }
  get onContactEnd() {
    return this._onContactEnd;
  }
  set onContactEnd(value = defaults17.onContactEnd) {
    if (value !== null && !isFunction5(value)) {
      throw new Error("[rigidbody] onContactEnd not a function");
    }
    this._onContactEnd = value;
  }
  get onTriggerEnter() {
    return this._onTriggerEnter;
  }
  set onTriggerEnter(value = defaults17.onTriggerEnter) {
    if (value !== null && !isFunction5(value)) {
      throw new Error("[rigidbody] onTriggerEnter not a function");
    }
    this._onTriggerEnter = value;
  }
  get onTriggerLeave() {
    return this._onTriggerLeave;
  }
  set onTriggerLeave(value = defaults17.onTriggerLeave) {
    if (value !== null && !isFunction5(value)) {
      throw new Error("[rigidbody] onTriggerLeave not a function");
    }
    this._onTriggerLeave = value;
  }
  get sleeping() {
    if (!this.actor) return false;
    return this.actor.isSleeping();
  }
  addForce(force, mode) {
    if (!force?.isVector3) {
      throw new Error("[rigidbody] addForce force must be Vector3");
    }
    mode = getForceMode(mode);
    this.actor?.addForce(force.toPxVec3(), mode, true);
  }
  addForceAtPos(force, pos) {
    if (!force?.isVector3) throw new Error("[rigidbody] addForceAtPos force must be Vector3");
    if (!pos?.isVector3) throw new Error("[rigidbody] addForceAtPos force must be Vector3");
    if (!this.actor) return;
    if (!this._pv1) this._pv1 = new PHYSX.PxVec3();
    if (!this._pv2) this._pv2 = new PHYSX.PxVec3();
    PHYSX.PxRigidBodyExt.prototype.addForceAtPos(
      this.actor,
      force.toPxExtVec3(this._pv1),
      pos.toPxExtVec3(this._pv2),
      PHYSX.PxForceModeEnum.eFORCE,
      true
    );
  }
  addForceAtLocalPos(force, pos) {
    if (!force?.isVector3) throw new Error("[rigidbody] addForceAtLocalPos force must be Vector3");
    if (!pos?.isVector3) throw new Error("[rigidbody] addForceAtLocalPos force must be Vector3");
    if (!this.actor) return;
    if (!this._pv1) this._pv1 = new PHYSX.PxVec3();
    if (!this._pv2) this._pv2 = new PHYSX.PxVec3();
    PHYSX.PxRigidBodyExt.prototype.addForceAtLocalPos(
      this.actor,
      force.toPxExtVec3(this._pv1),
      pos.toPxExtVec3(this._pv2),
      PHYSX.PxForceModeEnum.eFORCE,
      true
    );
  }
  addTorque(torque, mode) {
    if (!torque?.isVector3) {
      throw new Error("[rigidbody] addForce torque must be Vector3");
    }
    this.actor?.addTorque(torque.toPxVec3(), PHYSX.PxForceModeEnum.eFORCE, true);
  }
  getPosition(vec3) {
    if (!vec3) vec3 = this.tempVec3;
    if (!this.actor) return vec3.set(0, 0, 0);
    const pose = this.actor.getGlobalPose();
    vec3.copy(pose.p);
    return vec3;
  }
  setPosition(vec3) {
    if (!this.actor) return;
    const pose = this.actor.getGlobalPose();
    vec3.toPxTransform(pose);
    this.actor.setGlobalPose(pose);
    this.position.copy(vec3);
  }
  getQuaternion(quat) {
    if (!quat) quat = this.tempQuat;
    if (!this.actor) return quat.set(0, 0, 0);
    const pose = this.actor.getGlobalPose();
    quat.copy(pose.q);
    return quat;
  }
  setQuaternion(quat) {
    if (!this.actor) return;
    const pose = this.actor.getGlobalPose();
    quat.toPxTransform(pose);
    this.actor.setGlobalPose(pose);
    this.quaternion.copy(quat);
  }
  getLinearVelocity(vec3) {
    if (!vec3) vec3 = this.tempVec3;
    if (!this.actor) return vec3.set(0, 0, 0);
    return vec3.fromPxVec3(this.actor.getLinearVelocity());
  }
  setLinearVelocity(vec3) {
    this.actor?.setLinearVelocity?.(vec3.toPxVec3());
  }
  getAngularVelocity(vec3) {
    if (!vec3) vec3 = this.tempVec3;
    if (!this.actor) return vec3.set(0, 0, 0);
    return vec3.fromPxVec3(this.actor.getAngularVelocity());
  }
  setAngularVelocity(vec3) {
    this.actor?.setAngularVelocity?.(vec3.toPxVec3());
  }
  getVelocityAtPos(pos, vec3) {
    if (!pos?.isVector3) throw new Error("[rigidbody] getVelocityAtPos pos must be Vector3");
    if (!this.actor) return vec3.set(0, 0, 0);
    return vec3.copy(PHYSX.PxRigidBodyExt.prototype.getVelocityAtPos(this.actor, pos.toPxVec3()));
  }
  getLocalVelocityAtLocalPos(pos, vec3) {
    if (!pos?.isVector3) throw new Error("[rigidbody] getVelocityAtLocalPos pos must be Vector3");
    if (!this.actor) return vec3.set(0, 0, 0);
    return vec3.copy(PHYSX.PxRigidBodyExt.prototype.getLocalVelocityAtLocalPos(this.actor, pos.toPxVec3()));
  }
  setCenterOfMass(pos) {
    if (!pos?.isVector3) throw new Error("[rigidbody] setCenterOfMass pos must be Vector3");
    this._centerOfMass = pos.clone();
    this.needsRebuild = true;
    this.setDirty();
  }
  setKinematicTarget(position, quaternion) {
    if (this._type !== "kinematic") {
      throw new Error("[rigidbody] setKinematicTarget failed (not kinematic)");
    }
    position.toPxTransform(this._tm);
    quaternion.toPxTransform(this._tm);
    this.actor?.setKinematicTarget(this._tm);
  }
  getProxy() {
    if (!this.proxy) {
      const self2 = this;
      let proxy = {
        get type() {
          return self2.type;
        },
        set type(value) {
          self2.type = value;
        },
        get mass() {
          return self2.mass;
        },
        set mass(value) {
          self2.mass = value;
        },
        set linearDamping(value) {
          self2.linearDamping = value;
        },
        set angularDamping(value) {
          self2.angularDamping = value;
        },
        get tag() {
          return self2.tag;
        },
        set tag(value) {
          self2.tag = value;
        },
        get onContactStart() {
          return self2.onContactStart;
        },
        set onContactStart(value) {
          self2.onContactStart = value;
        },
        get onContactEnd() {
          return self2.onContactEnd;
        },
        set onContactEnd(value) {
          self2.onContactEnd = value;
        },
        get onTriggerEnter() {
          return self2.onTriggerEnter;
        },
        set onTriggerEnter(value) {
          self2.onTriggerEnter = value;
        },
        get onTriggerLeave() {
          return self2.onTriggerLeave;
        },
        set onTriggerLeave(value) {
          self2.onTriggerLeave = value;
        },
        get sleeping() {
          return self2.sleeping;
        },
        addForce(force, mode) {
          self2.addForce(force, mode);
        },
        addForceAtPos(force, pos) {
          self2.addForceAtPos(force, pos);
        },
        addForceAtLocalPos(force, pos) {
          self2.addForceAtLocalPos(force, pos);
        },
        addTorque(torque, mode) {
          self2.addTorque(torque, mode);
        },
        getPosition(vec3) {
          return self2.getPosition(vec3);
        },
        setPosition(vec3) {
          self2.setPosition(vec3);
        },
        getQuaternion(quat) {
          return self2.getQuaternion(quat);
        },
        setQuaternion(quat) {
          self2.setQuaternion(quat);
        },
        getLinearVelocity(vec3) {
          return self2.getLinearVelocity(vec3);
        },
        setLinearVelocity(vec3) {
          self2.setLinearVelocity(vec3);
        },
        getAngularVelocity(vec3) {
          self2.getAngularVelocity(vec3);
        },
        setAngularVelocity(vec3) {
          self2.setAngularVelocity(vec3);
        },
        getVelocityAtPos(pos, vec3) {
          return self2.getVelocityAtPos(pos, vec3);
        },
        getLocalVelocityAtLocalPos(pos, vec3) {
          return self2.getLocalVelocityAtLocalPos(pos, vec3);
        },
        setCenterOfMass(pos) {
          self2.setCenterOfMass(pos);
        },
        setKinematicTarget(position, quaternion) {
          self2.setKinematicTarget(position, quaternion);
        }
      };
      proxy = Object.defineProperties(proxy, Object.getOwnPropertyDescriptors(super.getProxy()));
      this.proxy = proxy;
    }
    return this.proxy;
  }
};
function isType2(value) {
  return types2.includes(value);
}

// src/core/nodes/Collider.js
import { isBoolean as isBoolean13, isNumber as isNumber16 } from "lodash-es";

// src/core/extras/geometryToPxMesh.js
import * as BufferGeometryUtils from "three/examples/jsm/utils/BufferGeometryUtils.js";
var cache = /* @__PURE__ */ new Map();
var PMeshHandle = class {
  constructor(item) {
    this.value = item.pmesh;
    this.item = item;
    this.item.refs++;
    this.released = false;
  }
  release() {
    if (this.released) return;
    this.item.refs--;
    if (this.item.refs === 0) {
      this.item.pmesh.release();
      cache.delete(this.item.id);
    }
    this.released = true;
    this.value = null;
  }
};
function geometryToPxMesh(world2, geometry, convex) {
  const id = `${geometry.uuid}_${convex ? "convex" : "triangles"}`;
  let item = cache.get(id);
  if (item) {
    return new PMeshHandle(item);
  }
  const cookingParams = world2.physics.cookingParams;
  let position = geometry.attributes.position;
  const index = geometry.index;
  if (position.isInterleavedBufferAttribute) {
    position = BufferGeometryUtils.deinterleaveAttribute(position);
    position = new three_exports.BufferAttribute(new Float32Array(position.array), position.itemSize, false);
  }
  const positions = position.array;
  const floatBytes = positions.length * positions.BYTES_PER_ELEMENT;
  const pointsPtr = PHYSX._webidl_malloc(floatBytes);
  PHYSX.HEAPF32.set(positions, pointsPtr >> 2);
  let desc;
  let pmesh;
  if (convex) {
    desc = new PHYSX.PxConvexMeshDesc();
    desc.points.count = positions.length / 3;
    desc.points.stride = 12;
    desc.points.data = pointsPtr;
    desc.flags.raise(PHYSX.PxConvexFlagEnum.eCOMPUTE_CONVEX);
    pmesh = PHYSX.CreateConvexMesh(cookingParams, desc);
  } else {
    desc = new PHYSX.PxTriangleMeshDesc();
    desc.points.count = positions.length / 3;
    desc.points.stride = 12;
    desc.points.data = pointsPtr;
    const indices = index.array;
    const indexBytes = indices.length * indices.BYTES_PER_ELEMENT;
    const indexPtr = PHYSX._webidl_malloc(indexBytes);
    if (indices instanceof Uint16Array) {
      PHYSX.HEAPU16.set(indices, indexPtr >> 1);
      desc.triangles.stride = 6;
      desc.flags.raise(PHYSX.PxTriangleMeshFlagEnum.e16_BIT_INDICES);
    } else {
      PHYSX.HEAPU32.set(indices, indexPtr >> 2);
      desc.triangles.stride = 12;
    }
    desc.triangles.count = indices.length / 3;
    desc.triangles.data = indexPtr;
    try {
      pmesh = PHYSX.CreateTriangleMesh(cookingParams, desc);
    } catch (err) {
      console.error("geometryToPxMesh failed...");
      console.error(err);
    }
    PHYSX._webidl_free(indexPtr);
  }
  PHYSX._webidl_free(pointsPtr);
  PHYSX.destroy(desc);
  if (!pmesh) return null;
  item = { id, pmesh, refs: 0 };
  cache.set(id, item);
  return new PMeshHandle(item);
}

// src/core/nodes/Collider.js
var defaults18 = {
  type: "box",
  width: 1,
  height: 1,
  depth: 1,
  radius: 0.5,
  geometry: null,
  convex: false,
  trigger: false,
  layer: "environment",
  staticFriction: 0.6,
  dynamicFriction: 0.6,
  restitution: 0
};
var _v14 = new Vector3Enhanced();
var _v24 = new Vector3Enhanced();
var _q13 = new three_exports.Quaternion();
var types3 = ["box", "sphere", "geometry"];
var layers2 = ["environment", "prop", "player", "tool"];
var Collider = class extends Node {
  constructor(data = {}) {
    super(data);
    this.name = "collider";
    this.type = data.type;
    this.width = data.width;
    this.height = data.height;
    this.depth = data.depth;
    this.radius = data.radius;
    this.geometry = data.geometry;
    this.convex = data.convex;
    this.trigger = data.trigger;
    this.layer = data.layer;
    this.staticFriction = data.staticFriction;
    this.dynamicFriction = data.dynamicFriction;
    this.restitution = data.restitution;
  }
  mount() {
    let geometry;
    let pmesh;
    if (this._type === "box") {
      geometry = new PHYSX.PxBoxGeometry(this._width / 2, this._height / 2, this._depth / 2);
    } else if (this._type === "sphere") {
      geometry = new PHYSX.PxSphereGeometry(this._radius);
    } else if (this._type === "geometry") {
      const isConvex = this._trigger || this._convex;
      pmesh = geometryToPxMesh(this.ctx.world, this._geometry, isConvex);
      if (!pmesh) return console.error("failed to generate collider pmesh");
      this.matrixWorld.decompose(_v14, _q13, _v24);
      const scale = new PHYSX.PxMeshScale(new PHYSX.PxVec3(_v24.x, _v24.y, _v24.z), new PHYSX.PxQuat(0, 0, 0, 1));
      if (isConvex) {
        geometry = new PHYSX.PxConvexMeshGeometry(pmesh.value, scale);
      } else {
        geometry = new PHYSX.PxTriangleMeshGeometry(pmesh.value, scale);
      }
      PHYSX.destroy(scale);
    }
    const material2 = this.ctx.world.physics.getMaterial(this._staticFriction, this._dynamicFriction, this._restitution);
    const flags = new PHYSX.PxShapeFlags();
    if (this._trigger) {
      flags.raise(PHYSX.PxShapeFlagEnum.eTRIGGER_SHAPE);
    } else {
      flags.raise(PHYSX.PxShapeFlagEnum.eSCENE_QUERY_SHAPE | PHYSX.PxShapeFlagEnum.eSIMULATION_SHAPE);
    }
    const layer = Layers[this._layer];
    let pairFlags = PHYSX.PxPairFlagEnum.eNOTIFY_TOUCH_FOUND | PHYSX.PxPairFlagEnum.eNOTIFY_TOUCH_LOST;
    if (!this._trigger) {
      pairFlags |= PHYSX.PxPairFlagEnum.eNOTIFY_CONTACT_POINTS;
    }
    this.pmesh = pmesh;
    const filterData = new PHYSX.PxFilterData(layer.group, layer.mask, pairFlags, 0);
    try {
      this.shape = this.ctx.world.physics.physics.createShape(geometry, material2, true, flags);
    } catch (err) {
      console.error("[collider] failed to create shape");
      console.error(err);
      if (geometry) {
        PHYSX.destroy(geometry);
      }
      if (this.pmesh) {
        this.pmesh.release();
        this.pmesh = null;
      }
      return;
    }
    this.shape.setQueryFilterData(filterData);
    this.shape.setSimulationFilterData(filterData);
    const position = _v14.copy(this.position).multiply(this.parent.scale);
    const pose = new PHYSX.PxTransform();
    position.toPxTransform(pose);
    this.quaternion.toPxTransform(pose);
    this.shape.setLocalPose(pose);
    this.parent?.addShape?.(this.shape);
    PHYSX.destroy(geometry);
    this.needsRebuild = false;
  }
  commit(didMove) {
    if (this.needsRebuild) {
      this.unmount();
      this.mount();
      return;
    }
    if (didMove) {
    }
  }
  unmount() {
    this.parent?.removeShape?.(this.shape);
    this.shape?.release();
    this.shape = null;
    this.pmesh?.release();
    this.pmesh = null;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this._type = source._type;
    this._width = source._width;
    this._height = source._height;
    this._depth = source._depth;
    this._radius = source._radius;
    this._geometry = source._geometry;
    this._convex = source._convex;
    this._trigger = source._trigger;
    this._layer = source._layer;
    this._staticFriction = source._staticFriction;
    this._dynamicFriction = source._dynamicFriction;
    this._restitution = source._restitution;
    return this;
  }
  get type() {
    return this._type;
  }
  set type(value = defaults18.type) {
    if (!isType3(value)) {
      throw new Error(`[collider] invalid type:`, value);
    }
    this._type = value;
    this.needsRebuild = true;
    this.setDirty();
  }
  get width() {
    return this._width;
  }
  set width(value = defaults18.width) {
    if (!isNumber16(value)) {
      throw new Error("[collider] width not a number");
    }
    this._width = value;
    if (this.shape && this._type === "box") {
      this.needsRebuild = true;
      this.setDirty();
    }
  }
  get height() {
    return this._height;
  }
  set height(value = defaults18.height) {
    if (!isNumber16(value)) {
      throw new Error("[collider] height not a number");
    }
    this._height = value;
    if (this.shape && this._type === "box") {
      this.needsRebuild = true;
      this.setDirty();
    }
  }
  get depth() {
    return this._depth;
  }
  set depth(value = defaults18.depth) {
    if (!isNumber16(value)) {
      throw new Error("[collider] depth not a number");
    }
    this._depth = value;
    if (this.shape && this._type === "box") {
      this.needsRebuild = true;
      this.setDirty();
    }
  }
  setSize(width, height, depth) {
    this.width = width;
    this.height = height;
    this.depth = depth;
  }
  get radius() {
    return this._radius;
  }
  set radius(value = defaults18.radius) {
    if (!isNumber16(value)) {
      throw new Error("[collider] radius not a number");
    }
    this._radius = value;
    if (this.shape && this._type === "sphere") {
      this.needsRebuild = true;
      this.setDirty();
    }
  }
  get geometry() {
    return secureRef({}, () => this._geometry);
  }
  set geometry(value = defaults18.geometry) {
    this._geometry = getRef(value);
    this.needsRebuild = true;
    this.setDirty();
  }
  get convex() {
    return this._convex;
  }
  set convex(value = defaults18.convex) {
    if (!isBoolean13(value)) {
      throw new Error("[collider] convex not a boolean");
    }
    this._convex = value;
    if (this.shape) {
      this.needsRebuild = true;
      this.setDirty();
    }
  }
  get trigger() {
    return this._trigger;
  }
  set trigger(value = defaults18.trigger) {
    if (!isBoolean13(value)) {
      throw new Error("[collider] trigger not a boolean");
    }
    this._trigger = value;
    if (this.shape) {
      this.needsRebuild = true;
      this.setDirty();
    }
  }
  get layer() {
    return this._layer;
  }
  set layer(value = defaults18.layer) {
    if (!isLayer2(value)) {
      throw new Error(`[collider] invalid layer: ${value}`);
    }
    this._layer = value;
    if (this.shape) {
      this.needsRebuild = true;
      this.setDirty();
    }
  }
  get staticFriction() {
    return this._staticFriction;
  }
  set staticFriction(value = defaults18.staticFriction) {
    if (!isNumber16(value)) {
      throw new Error("[collider] staticFriction not a number");
    }
    this._staticFriction = value;
    if (this.shape) {
      this.needsRebuild = true;
      this.setDirty();
    }
  }
  get dynamicFriction() {
    return this._dynamicFriction;
  }
  set dynamicFriction(value = defaults18.dynamicFriction) {
    if (!isNumber16(value)) {
      throw new Error("[collider] dynamicFriction not a number");
    }
    this._dynamicFriction = value;
    if (this.shape) {
      this.needsRebuild = true;
      this.setDirty();
    }
  }
  get restitution() {
    return this._restitution;
  }
  set restitution(value = defaults18.restitution) {
    if (!isNumber16(value)) {
      throw new Error("[collider] restitution not a number");
    }
    this._restitution = value;
    if (this.shape) {
      this.needsRebuild = true;
      this.setDirty();
    }
  }
  setMaterial(staticFriction, dynamicFriction, restitution) {
    this.staticFriction = staticFriction;
    this.dynamicFriction = dynamicFriction;
    this.restitution = restitution;
  }
  requestRebuild() {
    this.needsRebuild = true;
    this.setDirty();
  }
  getProxy() {
    if (!this.proxy) {
      const self2 = this;
      let proxy = {
        get type() {
          return self2.type;
        },
        set type(value) {
          self2.type = value;
        },
        get width() {
          return self2.width;
        },
        set width(value) {
          self2.width = value;
        },
        get height() {
          return self2.height;
        },
        set height(value) {
          self2.height = value;
        },
        get depth() {
          return self2.depth;
        },
        set depth(value) {
          self2.depth = value;
        },
        setSize(width, height, depth) {
          self2.setSize(width, height, depth);
        },
        get radius() {
          return self2.radius;
        },
        set radius(value) {
          self2.radius = value;
        },
        get geometry() {
          return self2.geometry;
        },
        set geometry(value) {
          self2.geometry = value;
        },
        get convex() {
          return self2.convex;
        },
        set convex(value) {
          self2.convex = value;
        },
        get trigger() {
          return self2.trigger;
        },
        set trigger(value) {
          self2.trigger = value;
        },
        get layer() {
          return self2.layer;
        },
        set layer(value) {
          if (value === "player") {
            throw new Error("[collider] layer invalid: player");
          }
          self2.layer = value;
        },
        get staticFriction() {
          return self2.staticFriction;
        },
        set staticFriction(value) {
          self2.staticFriction = value;
        },
        get dynamicFriction() {
          return self2.dynamicFriction;
        },
        set dynamicFriction(value) {
          self2.dynamicFriction = value;
        },
        get restitution() {
          return self2.restitution;
        },
        set restitution(value) {
          self2.restitution = value;
        },
        setMaterial(staticFriction, dynamicFriction, restitution) {
          self2.setMaterial(staticFriction, dynamicFriction, restitution);
        },
        requestRebuild() {
          self2.requestRebuild();
        }
      };
      proxy = Object.defineProperties(proxy, Object.getOwnPropertyDescriptors(super.getProxy()));
      this.proxy = proxy;
    }
    return this.proxy;
  }
};
function isType3(value) {
  return types3.includes(value);
}
function isLayer2(value) {
  return layers2.includes(value);
}

// src/core/nodes/Joint.js
import { isBoolean as isBoolean14, isNumber as isNumber17 } from "lodash-es";

// src/core/extras/bindRotations.js
function bindRotations(quaternion, euler) {
  euler._onChange(() => {
    quaternion.setFromEuler(euler, false);
  });
  quaternion._onChange(() => {
    euler.setFromQuaternion(quaternion, void 0, false);
  });
}

// src/core/nodes/Joint.js
var _q14 = new three_exports.Quaternion();
var _q2 = new three_exports.Quaternion();
var defaults19 = {
  type: "fixed",
  body0: null,
  body1: null,
  breakForce: Infinity,
  breakTorque: Infinity,
  limitY: null,
  limitZ: null,
  limitMin: null,
  limitMax: null,
  limitStiffness: null,
  limitDamping: null,
  collide: false
};
var types4 = ["fixed", "socket", "hinge", "distance"];
var Joint = class extends Node {
  constructor(data = {}) {
    super(data);
    this.name = "joint";
    this.type = data.type || defaults19.type;
    this.body0 = null;
    this.offset0 = new Vector3Enhanced(0, 0, 0);
    this.quaternion0 = new three_exports.Quaternion(0, 0, 0, 1);
    this.rotation0 = new three_exports.Euler(0, 0, 0, "YXZ");
    bindRotations(this.quaternion0, this.rotation0);
    this.body1 = null;
    this.offset1 = new Vector3Enhanced(0, 0, 0);
    this.quaternion1 = new three_exports.Quaternion(0, 0, 0, 1);
    this.rotation1 = new three_exports.Euler(0, 0, 0, "YXZ");
    bindRotations(this.quaternion1, this.rotation1);
    this.breakForce = isNumber17(data.breakForce) ? data.breakForce : defaults19.breakForce;
    this.breakTorque = isNumber17(data.breakTorque) ? data.breakTorque : defaults19.breakTorque;
    this.axis = new Vector3Enhanced(0, 1, 0);
    this.limitY = isNumber17(data.limitY) ? data.limitY : defaults19.limitY;
    this.limitZ = isNumber17(data.limitZ) ? data.limitZ : defaults19.limitZ;
    this.limitMin = isNumber17(data.limitMin) ? data.limitMin : defaults19.limitMin;
    this.limitMax = isNumber17(data.limitMax) ? data.limitMax : defaults19.limitMax;
    this.limitStiffness = isNumber17(data.limitStiffness) ? data.limitStiffness : defaults19.limitStiffness;
    this.limitDamping = isNumber17(data.limitDamping) ? data.limitDamping : defaults19.limitDamping;
    this.collide = isBoolean14(data.collide) ? data.collide : defaults19.collide;
    this.frame0 = new PHYSX.PxTransform(PHYSX.PxIDENTITYEnum.PxIdentity);
    this.frame1 = new PHYSX.PxTransform(PHYSX.PxIDENTITYEnum.PxIdentity);
  }
  mount() {
    const actor0 = this.body0?.actor;
    const actor1 = this.body1?.actor;
    if (!actor0 && !actor1) return;
    const frame0 = this.frame0;
    const frame1 = this.frame1;
    if (this.type === "fixed") {
      this.offset0.toPxTransform(frame0);
      this.offset1.toPxTransform(frame1);
      this.quaternion0.toPxTransform(frame0);
      this.quaternion1.toPxTransform(frame1);
      this.joint = new PHYSX.FixedJointCreate(this.ctx.world.physics.physics, actor0, frame0, actor1, frame1);
    }
    if (this.type === "socket") {
      this.offset0.toPxTransform(frame0);
      this.offset1.toPxTransform(frame1);
      const alignRotation = new three_exports.Quaternion().setFromUnitVectors(new Vector3Enhanced(1, 0, 0), this.axis);
      _q14.copy(this.quaternion0).multiply(alignRotation).toPxTransform(frame0);
      _q2.copy(this.quaternion1).multiply(alignRotation).toPxTransform(frame1);
      this.joint = new PHYSX.SphericalJointCreate(this.ctx.world.physics.physics, actor0, frame0, actor1, frame1);
      if (isNumber17(this.limitY) && isNumber17(this.limitZ)) {
        let spring;
        if (isNumber17(this.limitStiffness) && isNumber17(this.limitDamping)) {
          spring = new PHYSX.PxSpring(this.limitStiffness, this.limitDamping);
        }
        const cone = new PHYSX.PxJointLimitCone(this.limitY * DEG2RAD, this.limitZ * DEG2RAD, spring);
        this.joint.setLimitCone(cone);
        this.joint.setSphericalJointFlag(PHYSX.PxSphericalJointFlagEnum.eLIMIT_ENABLED, true);
        PHYSX.destroy(cone);
        if (spring) PHYSX.destroy(spring);
      }
    }
    if (this.type === "hinge") {
      this.offset0.toPxTransform(frame0);
      this.offset1.toPxTransform(frame1);
      const alignRotation = new three_exports.Quaternion().setFromUnitVectors(new Vector3Enhanced(1, 0, 0), this.axis);
      _q14.copy(this.quaternion0).multiply(alignRotation).toPxTransform(frame0);
      _q2.copy(this.quaternion1).multiply(alignRotation).toPxTransform(frame1);
      this.joint = new PHYSX.RevoluteJointCreate(this.ctx.world.physics.physics, actor0, frame0, actor1, frame1);
      if (isNumber17(this.limitMin) && isNumber17(this.limitMax)) {
        let spring;
        if (isNumber17(this.limitStiffness) && isNumber17(this.limitDamping)) {
          spring = new PHYSX.PxSpring(this.limitStiffness, this.limitDamping);
        }
        const limit = new PHYSX.PxJointAngularLimitPair(this.limitMin * DEG2RAD, this.limitMax * DEG2RAD, spring);
        this.joint.setLimit(limit);
        this.joint.setRevoluteJointFlag(PHYSX.PxRevoluteJointFlagEnum.eLIMIT_ENABLED, true);
        PHYSX.destroy(limit);
        if (spring) PHYSX.destroy(spring);
      }
    }
    if (this.type === "distance") {
      this.offset0.toPxTransform(frame0);
      this.offset1.toPxTransform(frame1);
      this.joint = new PHYSX.DistanceJointCreate(this.ctx.world.physics.physics, actor0, frame0, actor1, frame1);
      this.joint.setMinDistance(this.limitMin);
      this.joint.setMaxDistance(this.limitMax);
      this.joint.setDistanceJointFlag(PHYSX.PxDistanceJointFlagEnum.eMIN_DISTANCE_ENABLED, true);
      this.joint.setDistanceJointFlag(PHYSX.PxDistanceJointFlagEnum.eMAX_DISTANCE_ENABLED, true);
      if (isNumber17(this.limitStiffness) && isNumber17(this.limitDamping)) {
        this.joint.setStiffness(this.limitStiffness);
        this.joint.setDamping(this.limitDamping);
        this.joint.setDistanceJointFlag(PHYSX.PxDistanceJointFlagEnum.eSPRING_ENABLED, true);
      }
    }
    if (this.collide) {
      this.joint.setConstraintFlag(PHYSX.PxConstraintFlagEnum.eCOLLISION_ENABLED, true);
    }
    this.joint.setBreakForce(this.breakForce, this.breakTorque);
    this.needsRebuild = false;
  }
  commit(didMove) {
    if (this.needsRebuild) {
      this.unmount();
      this.mount();
      return;
    }
    if (didMove) {
    }
  }
  unmount() {
    this.joint?.release();
    this.joint = null;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.type = source.type;
    this.body0 = source.body0;
    this.offset0.copy(source.offset0);
    this.quaternion0.copy(source.quaternion0);
    this.body1 = source.body1;
    this.offset1.copy(source.offset1);
    this.quaternion1.copy(source.quaternion1);
    this.breakForce = source.breakForce;
    this.breakTorque = source.breakTorque;
    this.axis.copy(source.axis);
    this.limitY = source.limitY;
    this.limitZ = source.limitZ;
    this.limitMin = source.limitMin;
    this.limitMax = source.limitMax;
    this.limitStiffness = source.limitStiffness;
    this.limitDamping = source.limitDamping;
    this.collide = source.collide;
    return this;
  }
  getProxy() {
    if (!this.proxy) {
      const self2 = this;
      let proxy = {
        get type() {
          return self2.type;
        },
        set type(value) {
          if (self2.value === value) return;
          if (!types4.includes(value)) throw new Error("[joint] invalid type:", value);
          self2.type = value;
          self2.needsRebuild = true;
          self2.setDirty();
        },
        get body0() {
          return self2.body0.getProxy();
        },
        set body0(value) {
          if (value) {
            self2.ctx.world._allowRefs = true;
            self2.body0 = value?._ref;
            self2.ctx.world._allowRefs = false;
          } else {
            self2.body0 = null;
          }
          self2.needsRebuild = true;
          self2.setDirty();
        },
        get offset0() {
          return self2.offset0;
        },
        get quaternion0() {
          return self2.quaternion0;
        },
        get rotation0() {
          return self2.rotation0;
        },
        get body1() {
          return self2.body1.getProxy();
        },
        set body1(value) {
          if (value) {
            self2.ctx.world._allowRefs = true;
            self2.body1 = value?._ref;
            self2.ctx.world._allowRefs = false;
          } else {
            self2.body1 = null;
          }
          self2.needsRebuild = true;
          self2.setDirty();
        },
        get offset1() {
          return self2.offset1;
        },
        get quaternion1() {
          return self2.quaternion1;
        },
        get rotation1() {
          return self2.rotation1;
        },
        get breakForce() {
          return self2.breakForce;
        },
        set breakForce(value) {
          self2.breakForce = isNumber17(value) ? value : defaults19.breakForce;
          self2.needsRebuild = true;
          self2.setDirty();
        },
        get breakTorque() {
          return self2.breakTorque;
        },
        set breakTorque(value) {
          self2.breakTorque = isNumber17(value) ? value : defaults19.breakTorque;
          self2.needsRebuild = true;
          self2.setDirty();
        },
        get limitY() {
          return self2.limitY;
        },
        set limitY(value) {
          self2.limitY = value;
          self2.needsRebuild = true;
          self2.setDirty();
        },
        get axis() {
          return self2.axis;
        },
        get limitZ() {
          return self2.limitZ;
        },
        set limitZ(value) {
          self2.limitZ = value;
          self2.needsRebuild = true;
          self2.setDirty();
        },
        get limitMin() {
          return self2.limitMin;
        },
        set limitMin(value) {
          self2.limitMin = value;
          self2.needsRebuild = true;
          self2.setDirty();
        },
        get limitMax() {
          return self2.limitMax;
        },
        set limitMax(value) {
          self2.limitMax = value;
          self2.needsRebuild = true;
          self2.setDirty();
        },
        get limitStiffness() {
          return self2.limitStiffness;
        },
        set limitStiffness(value) {
          self2.limitStiffness = value;
          self2.needsRebuild = true;
          self2.setDirty();
        },
        get limitDamping() {
          return self2.limitDamping;
        },
        set limitDamping(value) {
          self2.limitDamping = value;
          self2.needsRebuild = true;
          self2.setDirty();
        },
        get collide() {
          return self2.collide;
        },
        set collide(value) {
          self2.collide = value;
          self2.needsRebuild = true;
          self2.setDirty();
        }
      };
      proxy = Object.defineProperties(proxy, Object.getOwnPropertyDescriptors(super.getProxy()));
      this.proxy = proxy;
    }
    return this.proxy;
  }
};

// src/core/extras/createNode.js
function createNode(name2, data) {
  const Node2 = nodes_exports[name2];
  if (!Node2) console.error("unknown node:", name2);
  const node = new Node2(data);
  return node;
}

// src/core/extras/LerpVector3.js
import * as THREE4 from "three";
var LerpVector3 = class {
  constructor(value, rate) {
    this.value = value;
    this.rate = rate;
    this.previous = new THREE4.Vector3().copy(this.value);
    this.current = new THREE4.Vector3().copy(this.value);
    this.time = 0;
    this.snapToken = null;
  }
  push(value, snapToken = null) {
    if (this.snapToken !== snapToken) {
      this.snapToken = snapToken;
      this.previous.copy(value);
      this.current.copy(value);
      this.value.copy(value);
    } else {
      this.previous.copy(this.current);
      this.current.copy(value);
    }
    this.time = 0;
  }
  pushArray(value, snapToken = null) {
    if (this.snapToken !== snapToken) {
      this.snapToken = snapToken;
      this.previous.fromArray(value);
      this.current.fromArray(value);
      this.value.fromArray(value);
    } else {
      this.previous.copy(this.current);
      this.current.fromArray(value);
    }
    this.time = 0;
  }
  update(delta) {
    this.time += delta;
    let alpha = this.time / this.rate;
    if (alpha > 1) alpha = 1;
    this.value.lerpVectors(this.previous, this.current, alpha);
    return this;
  }
  snap() {
    this.previous.copy(this.current);
    this.value.copy(this.current);
    this.time = 0;
  }
  clear() {
    this.previous.copy(this.value);
    this.current.copy(this.value);
    this.time = 0;
  }
};

// src/core/extras/LerpQuaternion.js
import * as THREE5 from "three";
var LerpQuaternion = class {
  constructor(value, rate) {
    this.value = value;
    this.rate = rate;
    this.previous = new THREE5.Quaternion().copy(this.value);
    this.current = new THREE5.Quaternion().copy(this.value);
    this.time = 0;
    this.snapToken = null;
  }
  push(value, snapToken = null) {
    if (this.snapToken !== snapToken) {
      this.snapToken = snapToken;
      this.previous.copy(value);
      this.current.copy(value);
      this.value.copy(value);
    } else {
      this.previous.copy(this.current);
      this.current.copy(value);
    }
    this.time = 0;
  }
  pushArray(value, snapToken = null) {
    if (this.snapToken !== snapToken) {
      this.snapToken = snapToken;
      this.previous.fromArray(value);
      this.current.fromArray(value);
      this.value.fromArray(value);
    } else {
      this.previous.copy(this.current);
      this.current.fromArray(value);
    }
    this.time = 0;
  }
  update(delta) {
    this.time += delta;
    let alpha = this.time / this.rate;
    if (alpha > 1) alpha = 1;
    this.value.slerpQuaternions(this.previous, this.current, alpha);
    return this;
  }
  snap() {
    this.previous.copy(this.current);
    this.value.copy(this.current);
    this.time = 0;
  }
  clear() {
    this.previous.copy(this.value);
    this.current.copy(this.value);
    this.time = 0;
  }
};

// src/core/extras/createPlayerProxy.js
var HEALTH_MAX = 100;
function createPlayerProxy(entity, player) {
  const world2 = player.world;
  const position = new Vector3Enhanced();
  const rotation = new three_exports.Euler();
  const quaternion = new three_exports.Quaternion();
  let activeEffectConfig = null;
  return {
    get networkId() {
      return player.data.owner;
    },
    get id() {
      return player.data.id;
    },
    get userId() {
      return player.data.userId;
    },
    get local() {
      return player.data.id === world2.network.id;
    },
    get admin() {
      return hasRole(player.data.roles, "admin");
    },
    get isAdmin() {
      return hasRole(player.data.roles, "admin");
    },
    get name() {
      return player.data.name;
    },
    get health() {
      return player.data.health;
    },
    get position() {
      return position.copy(player.base.position);
    },
    get rotation() {
      return rotation.copy(player.base.rotation);
    },
    get quaternion() {
      return quaternion.copy(player.base.quaternion);
    },
    get height() {
      return player.avatar?.getHeight();
    },
    get headToHeight() {
      return player.avatar?.getHeadToHeight();
    },
    get destroyed() {
      return !!player.destroyed;
    },
    teleport(position2, rotationY) {
      if (player.data.owner === world2.network.id) {
        world2.network.enqueue("onPlayerTeleport", { position: position2.toArray(), rotationY });
      } else if (world2.network.isClient) {
        world2.network.send("playerTeleport", { networkId: player.data.owner, position: position2.toArray(), rotationY });
      } else {
        world2.network.sendTo(player.data.owner, "playerTeleport", { position: position2.toArray(), rotationY });
      }
    },
    getBoneTransform(boneName) {
      return player.avatar?.getBoneTransform?.(boneName);
    },
    setSessionAvatar(url) {
      const avatar = url;
      if (player.data.owner === world2.network.id) {
        world2.network.enqueue("onPlayerSessionAvatar", { avatar });
      } else if (world2.network.isClient) {
        world2.network.send("playerSessionAvatar", { networkId: player.data.owner, avatar });
      } else {
        world2.network.sendTo(player.data.owner, "playerSessionAvatar", { avatar });
      }
    },
    damage(amount) {
      const health = clamp(player.data.health - amount, 0, HEALTH_MAX);
      if (player.data.health === health) return;
      if (world2.network.isServer) {
        world2.network.send("entityModified", { id: player.data.id, health });
      }
      player.modify({ health });
    },
    heal(amount = HEALTH_MAX) {
      const health = clamp(player.data.health + amount, 0, HEALTH_MAX);
      if (player.data.health === health) return;
      if (world2.network.isServer) {
        world2.network.send("entityModified", { id: player.data.id, health });
      }
      player.modify({ health });
    },
    hasEffect() {
      return !!player.data.effect;
    },
    applyEffect(opts) {
      if (!opts) return;
      const effect = {};
      if (opts.anchor) effect.anchorId = opts.anchor.anchorId;
      if (opts.emote) effect.emote = opts.emote;
      if (opts.snare) effect.snare = opts.snare;
      if (opts.freeze) effect.freeze = opts.freeze;
      if (opts.turn) effect.turn = opts.turn;
      if (opts.duration) effect.duration = opts.duration;
      if (opts.cancellable) {
        effect.cancellable = opts.cancellable;
        delete effect.freeze;
      }
      const config3 = {
        effect,
        onEnd: () => {
          if (activeEffectConfig !== config3) return;
          activeEffectConfig = null;
          player.setEffect(null);
          opts.onEnd?.();
        }
      };
      activeEffectConfig = config3;
      player.setEffect(config3.effect, config3.onEnd);
      if (world2.network.isServer) {
        world2.network.send("entityModified", { id: player.data.id, ef: config3.effect });
      }
      return {
        get active() {
          return activeEffectConfig === config3;
        },
        cancel: () => {
          config3.onEnd();
        }
      };
    },
    cancelEffect() {
      activeEffectConfig?.onEnd();
    },
    push(force) {
      force = force.toArray();
      if (player.data.owner === world2.network.id) {
        player.push(force);
      } else if (world2.network.isClient) {
        world2.network.send("playerPush", { networkId: player.data.owner, force });
      } else {
        world2.network.sendTo(player.data.owner, "playerPush", { force });
      }
    },
    screenshare(targetId) {
      if (!targetId) {
        return console.error(`screenshare has invalid targetId: ${targetId}`);
      }
      if (player.data.owner !== world2.network.id) {
        return console.error("screenshare can only be called on local player");
      }
      world2.livekit.setScreenShareTarget(targetId);
    }
  };
}

// src/core/entities/App.js
var hotEventNames = ["fixedUpdate", "update", "lateUpdate"];
var Modes = {
  ACTIVE: "active",
  MOVING: "moving",
  LOADING: "loading",
  CRASHED: "crashed"
};
var App = class extends Entity {
  constructor(world2, data, local) {
    super(world2, data, local);
    this.isApp = true;
    this.n = 0;
    this.worldNodes = /* @__PURE__ */ new Set();
    this.hotEvents = 0;
    this.worldListeners = /* @__PURE__ */ new Map();
    this.listeners = {};
    this.eventQueue = [];
    this.snaps = [];
    this.root = createNode("group");
    this.fields = [];
    this.target = null;
    this.projectLimit = Infinity;
    this.keepActive = false;
    this.playerProxies = /* @__PURE__ */ new Map();
    this.hitResultsPool = [];
    this.hitResults = [];
    this.deadHook = { dead: false };
    this.build();
  }
  createNode(name2, data) {
    const node = createNode(name2, data);
    return node;
  }
  async build(crashed) {
    this.building = true;
    const n6 = ++this.n;
    const blueprint = this.world.blueprints.get(this.data.blueprint);
    if (blueprint.disabled) {
      this.unbuild();
      this.blueprint = blueprint;
      this.building = false;
      return;
    }
    let root;
    let script;
    if (this.data.uploader && this.data.uploader !== this.world.network.id) {
      root = createNode("mesh");
      root.type = "box";
      root.width = 1;
      root.height = 1;
      root.depth = 1;
    } else {
      try {
        const type = blueprint.model.endsWith("vrm") ? "avatar" : "model";
        let glb = this.world.loader.get(type, blueprint.model);
        if (!glb) glb = await this.world.loader.load(type, blueprint.model);
        root = glb.toNodes();
      } catch (err) {
        console.error(err);
        crashed = true;
      }
      if (blueprint.script) {
        try {
          script = this.world.loader.get("script", blueprint.script);
          if (!script) script = await this.world.loader.load("script", blueprint.script);
        } catch (err) {
          console.error(err);
          crashed = true;
        }
      }
    }
    if (crashed) {
      let glb = this.world.loader.get("model", "asset://crash-block.glb");
      if (!glb) glb = await this.world.loader.load("model", "asset://crash-block.glb");
      root = glb.toNodes();
    }
    if (this.n !== n6) return;
    this.unbuild();
    this.mode = Modes.ACTIVE;
    if (this.data.mover) this.mode = Modes.MOVING;
    if (this.data.uploader && this.data.uploader !== this.world.network.id) this.mode = Modes.LOADING;
    this.blueprint = blueprint;
    this.root = root;
    this.root.position.fromArray(this.data.position);
    this.root.quaternion.fromArray(this.data.quaternion);
    this.root.scale.fromArray(this.data.scale);
    this.root.activate({ world: this.world, entity: this, moving: !!this.data.mover });
    const runScript = this.mode === Modes.ACTIVE && script && !crashed || this.mode === Modes.MOVING && this.keepActive;
    if (runScript) {
      this.abortController = new AbortController();
      this.script = script;
      this.keepActive = false;
      try {
        this.script.exec(this.getWorldProxy(), this.getAppProxy(), this.fetch, blueprint.props, this.setTimeout);
      } catch (err) {
        console.error("script crashed");
        console.error(err);
        return this.crash();
      }
    }
    if (this.mode === Modes.MOVING) {
      this.world.setHot(this, true);
      this.snaps = [];
      this.root.traverse((node) => {
        if (node.name === "snap") {
          this.snaps.push(node.worldPosition);
        }
      });
    }
    this.networkPos = new LerpVector3(root.position, this.world.networkRate);
    this.networkQuat = new LerpQuaternion(root.quaternion, this.world.networkRate);
    this.networkSca = new LerpVector3(root.scale, this.world.networkRate);
    while (this.eventQueue.length) {
      const event = this.eventQueue[0];
      if (event.version > this.blueprint.version) break;
      this.eventQueue.shift();
      this.emit(event.name, event.data, event.networkId);
    }
    this.building = false;
  }
  unbuild() {
    this.emit("destroy");
    this.control?.release();
    this.control = null;
    this.playerProxies.forEach((player) => {
      player.cancelEffect();
    });
    this.root?.deactivate();
    for (const node of this.worldNodes) {
      node.deactivate();
    }
    this.worldNodes.clear();
    this.clearEventListeners();
    this.hotEvents = 0;
    this.world.setHot(this, false);
    this.abortController?.abort();
    this.abortController = null;
    this.deadHook.dead = true;
    this.deadHook = { dead: false };
    this.onFields?.([]);
  }
  fixedUpdate(delta) {
    if (this.mode === Modes.ACTIVE && this.script) {
      try {
        this.emit("fixedUpdate", delta);
      } catch (err) {
        console.error("script fixedUpdate crashed", this);
        console.error(err);
        this.crash();
        return;
      }
    }
  }
  update(delta) {
    if (this.data.mover && this.data.mover !== this.world.network.id) {
      this.networkPos.update(delta);
      this.networkQuat.update(delta);
      this.networkSca.update(delta);
    }
    if (this.mode === Modes.ACTIVE && this.script) {
      try {
        this.emit("update", delta);
      } catch (err) {
        console.error("script update() crashed", this);
        console.error(err);
        this.crash();
        return;
      }
    }
  }
  lateUpdate(delta) {
    if (this.mode === Modes.ACTIVE && this.script) {
      try {
        this.emit("lateUpdate", delta);
      } catch (err) {
        console.error("script lateUpdate() crashed", this);
        console.error(err);
        this.crash();
        return;
      }
    }
  }
  onUploaded() {
    this.data.uploader = null;
    this.world.network.send("entityModified", { id: this.data.id, uploader: null });
  }
  modify(data) {
    let rebuild;
    if (data.hasOwnProperty("blueprint")) {
      this.data.blueprint = data.blueprint;
      rebuild = true;
    }
    if (data.hasOwnProperty("uploader")) {
      this.data.uploader = data.uploader;
      rebuild = true;
    }
    if (data.hasOwnProperty("mover")) {
      this.data.mover = data.mover;
      rebuild = true;
    }
    if (data.hasOwnProperty("position")) {
      this.data.position = data.position;
      if (this.data.mover) {
        this.networkPos.pushArray(data.position);
      } else {
        rebuild = true;
      }
    }
    if (data.hasOwnProperty("quaternion")) {
      this.data.quaternion = data.quaternion;
      if (this.data.mover) {
        this.networkQuat.pushArray(data.quaternion);
      } else {
        rebuild = true;
      }
    }
    if (data.hasOwnProperty("scale")) {
      this.data.scale = data.scale;
      if (this.data.mover) {
        this.networkSca.pushArray(data.scale);
      } else {
        rebuild = true;
      }
    }
    if (data.hasOwnProperty("pinned")) {
      this.data.pinned = data.pinned;
    }
    if (data.hasOwnProperty("state")) {
      this.data.state = data.state;
      rebuild = true;
    }
    if (rebuild) {
      this.build();
    }
  }
  crash() {
    this.build(true);
  }
  destroy(local) {
    if (this.destroyed) return;
    this.destroyed = true;
    this.unbuild();
    this.world.entities.remove(this.data.id);
    if (local) {
      this.world.network.send("entityRemoved", this.data.id);
    }
  }
  on(name2, callback) {
    if (!this.listeners[name2]) {
      this.listeners[name2] = /* @__PURE__ */ new Set();
    }
    if (this.listeners[name2].has(callback)) return;
    this.listeners[name2].add(callback);
    if (hotEventNames.includes(name2)) {
      this.hotEvents++;
      this.world.setHot(this, this.hotEvents > 0);
    }
  }
  off(name2, callback) {
    if (!this.listeners[name2]) return;
    if (!this.listeners[name2].has(callback)) return;
    this.listeners[name2].delete(callback);
    if (hotEventNames.includes(name2)) {
      this.hotEvents--;
      this.world.setHot(this, this.hotEvents > 0);
    }
  }
  emit(name2, a1, a22) {
    if (!this.listeners[name2]) return;
    for (const callback of this.listeners[name2]) {
      callback(a1, a22);
    }
  }
  onWorldEvent(name2, callback) {
    this.worldListeners.set(callback, name2);
    this.world.events.on(name2, callback);
  }
  offWorldEvent(name2, callback) {
    this.worldListeners.delete(callback);
    this.world.events.off(name2, callback);
  }
  clearEventListeners() {
    this.listeners = {};
    for (const [callback, name2] of this.worldListeners) {
      this.world.events.off(name2, callback);
    }
    this.worldListeners.clear();
  }
  onEvent(version4, name2, data, networkId) {
    if (this.building || version4 > this.blueprint.version) {
      this.eventQueue.push({ version: version4, name: name2, data, networkId });
    } else {
      this.emit(name2, data, networkId);
    }
  }
  fetch = async (url, options = {}) => {
    try {
      const resp = await fetch(url, {
        ...options,
        signal: this.abortController.signal
      });
      const secureResp = {
        ok: resp.ok,
        status: resp.status,
        statusText: resp.statusText,
        headers: Object.fromEntries(resp.headers.entries()),
        json: async () => await resp.json(),
        text: async () => await resp.text(),
        blob: async () => await resp.blob(),
        arrayBuffer: async () => await resp.arrayBuffer()
      };
      return secureResp;
    } catch (err) {
      console.error(err);
    }
  };
  setTimeout = (fn, ms) => {
    const hook = this.getDeadHook();
    const timerId = setTimeout(() => {
      if (hook.dead) return;
      fn();
    }, ms);
    return timerId;
  };
  getDeadHook = () => {
    return this.deadHook;
  };
  getNodes() {
    if (!this.blueprint) return;
    const type = this.blueprint.model.endsWith("vrm") ? "avatar" : "model";
    let glb = this.world.loader.get(type, this.blueprint.model);
    if (!glb) return;
    return glb.toNodes();
  }
  getPlayerProxy(playerId) {
    if (playerId === void 0) playerId = this.world.entities.player?.data.id;
    let proxy = this.playerProxies.get(playerId);
    if (!proxy || proxy.destroyed) {
      const player = this.world.entities.getPlayer(playerId);
      if (!player) return null;
      proxy = createPlayerProxy(this, player);
      this.playerProxies.set(playerId, proxy);
    }
    return proxy;
  }
  getWorldProxy() {
    if (!this.worldProxy) {
      const entity = this;
      const getters = this.world.apps.worldGetters;
      const setters = this.world.apps.worldSetters;
      const methods = this.world.apps.worldMethods;
      this.worldProxy = new Proxy(
        {},
        {
          get: (target, prop) => {
            if (prop in getters) {
              return getters[prop](entity);
            }
            if (prop in methods) {
              const method = methods[prop];
              return (...args) => {
                return method(entity, ...args);
              };
            }
            return void 0;
          },
          set: (target, prop, value) => {
            if (prop in setters) {
              setters[prop](entity, value);
              return true;
            }
            return true;
          }
        }
      );
    }
    return this.worldProxy;
  }
  getAppProxy() {
    if (!this.appProxy) {
      const entity = this;
      const getters = this.world.apps.appGetters;
      const setters = this.world.apps.appSetters;
      const methods = this.world.apps.appMethods;
      this.appProxy = new Proxy(
        {},
        {
          get: (target, prop) => {
            if (prop in getters) {
              return getters[prop](entity);
            }
            if (prop in methods) {
              const method = methods[prop];
              return (...args) => {
                return method(entity, ...args);
              };
            }
            return entity.root.getProxy()[prop];
          },
          set: (target, prop, value) => {
            if (prop in setters) {
              setters[prop](entity, value);
              return true;
            }
            if (prop in entity.root.getProxy()) {
              entity.root.getProxy()[prop] = value;
              return true;
            }
            return true;
          }
        }
      );
    }
    return this.appProxy;
  }
};

// src/core/extras/simpleCamLerp.js
var BACKWARD = new Vector3Enhanced(0, 0, 1);
var v15 = new Vector3Enhanced();
var sweepGeometry;
var smoothing = 20;
function simpleCamLerp(world2, camera, target, delta) {
  const alpha = 1 - Math.exp(-smoothing * delta);
  camera.quaternion.slerp(target.quaternion, alpha);
  camera.position.copy(target.position);
  if (!sweepGeometry) sweepGeometry = new PHYSX.PxSphereGeometry(0.2);
  const origin = camera.position;
  const direction = v15.copy(BACKWARD).applyQuaternion(camera.quaternion);
  const layerMask = Layers.camera.mask;
  const hit = world2.physics.sweep(sweepGeometry, origin, direction, 200, layerMask);
  let distance = target.zoom;
  if (hit && hit.distance < distance) {
    camera.zoom = hit.distance;
  } else {
    const alpha2 = 6 * delta;
    camera.zoom += (distance - camera.zoom) * alpha2;
  }
}

// src/core/extras/playerEmotes.js
var Emotes = {
  IDLE: "asset://emote-idle.glb",
  WALK: "asset://emote-walk.glb",
  RUN: "asset://emote-run.glb",
  FLOAT: "asset://emote-float.glb",
  FALL: "asset://emote-fall.glb",
  FLIP: "asset://emote-flip.glb",
  TALK: "asset://emote-talk.glb"
};
var emoteUrls = [Emotes.IDLE, Emotes.WALK, Emotes.RUN, Emotes.FLOAT, Emotes.FALL, Emotes.FLIP, Emotes.TALK];

// src/core/entities/PlayerLocal.js
import { isNumber as isNumber19 } from "lodash-es";
var UP = new Vector3Enhanced(0, 1, 0);
var DOWN = new Vector3Enhanced(0, -1, 0);
var FORWARD2 = new Vector3Enhanced(0, 0, -1);
var BACKWARD2 = new Vector3Enhanced(0, 0, 1);
var SCALE_IDENTITY = new Vector3Enhanced(1, 1, 1);
var POINTER_LOOK_SPEED = 0.1;
var PAN_LOOK_SPEED = 0.4;
var ZOOM_SPEED = 2;
var MIN_ZOOM = 2;
var MAX_ZOOM = 8;
var STICK_MAX_DISTANCE = 50;
var DEFAULT_CAM_HEIGHT = 1.2;
var v16 = new Vector3Enhanced();
var v24 = new Vector3Enhanced();
var v32 = new Vector3Enhanced();
var v42 = new Vector3Enhanced();
var v52 = new Vector3Enhanced();
var v62 = new Vector3Enhanced();
var e12 = new three_exports.Euler(0, 0, 0, "YXZ");
var q14 = new three_exports.Quaternion();
var q22 = new three_exports.Quaternion();
var q3 = new three_exports.Quaternion();
var q4 = new three_exports.Quaternion();
var m13 = new three_exports.Matrix4();
var m2 = new three_exports.Matrix4();
var m3 = new three_exports.Matrix4();
var PlayerLocal = class extends Entity {
  constructor(world2, data, local) {
    super(world2, data, local);
    this.isPlayer = true;
    this.init();
  }
  async init() {
    if (this.world.loader?.preloader) {
      await this.world.loader.preloader;
    }
    this.mass = 1;
    this.gravity = 20;
    this.effectiveGravity = this.gravity * this.mass;
    this.jumpHeight = 1.5;
    this.capsuleRadius = 0.3;
    this.capsuleHeight = 1.6;
    this.grounded = false;
    this.groundAngle = 0;
    this.groundNormal = new Vector3Enhanced().copy(UP);
    this.groundSweepRadius = this.capsuleRadius - 0.01;
    this.groundSweepGeometry = new PHYSX.PxSphereGeometry(this.groundSweepRadius);
    this.pushForce = null;
    this.pushForceInit = false;
    this.slipping = false;
    this.jumped = false;
    this.jumping = false;
    this.justLeftGround = false;
    this.fallTimer = 0;
    this.falling = false;
    this.moveDir = new Vector3Enhanced();
    this.moving = false;
    this.lastJumpAt = 0;
    this.flying = false;
    this.flyForce = 100;
    this.flyDrag = 300;
    this.flyDir = new Vector3Enhanced();
    this.platform = {
      actor: null,
      prevTransform: new three_exports.Matrix4()
    };
    this.speaking = false;
    this.lastSendAt = 0;
    this.base = createNode("group");
    this.base.position.fromArray(this.data.position);
    this.base.quaternion.fromArray(this.data.quaternion);
    this.aura = createNode("group");
    this.nametag = createNode("nametag", { label: "", health: this.data.health, active: false });
    this.aura.add(this.nametag);
    this.bubble = createNode("ui", {
      id: "bubble",
      // space: 'screen',
      width: 300,
      height: 512,
      // size: 0.01,
      pivot: "bottom-center",
      // pivot: 'top-left',
      billboard: "full",
      scaler: [3, 30],
      justifyContent: "flex-end",
      alignItems: "center",
      active: false
    });
    this.bubbleBox = createNode("uiview", {
      backgroundColor: "rgba(0, 0, 0, 0.8)",
      borderRadius: 10,
      padding: 10
    });
    this.bubbleText = createNode("uitext", {
      color: "white",
      fontWeight: 100,
      lineHeight: 1.4,
      fontSize: 16
    });
    this.bubble.add(this.bubbleBox);
    this.bubbleBox.add(this.bubbleText);
    this.aura.add(this.bubble);
    this.aura.activate({ world: this.world, entity: this });
    this.base.activate({ world: this.world, entity: this });
    this.camHeight = DEFAULT_CAM_HEIGHT;
    this.applyAvatar();
    this.cam = {};
    this.cam.position = new Vector3Enhanced().copy(this.base.position);
    this.cam.position.y += this.camHeight;
    this.cam.quaternion = new three_exports.Quaternion();
    this.cam.rotation = new three_exports.Euler(0, 0, 0, "YXZ");
    bindRotations(this.cam.quaternion, this.cam.rotation);
    this.cam.quaternion.copy(this.base.quaternion);
    this.cam.rotation.x += -15 * DEG2RAD;
    this.cam.zoom = 2;
    this.initCapsule();
    this.initControl();
    this.world.setHot(this, true);
  }
  getAvatarUrl() {
    return this.data.sessionAvatar || this.data.avatar || "asset://avatar.vrm";
  }
  applyAvatar() {
    if (!this.world.loader) return;
    const avatarUrl = this.getAvatarUrl();
    if (this.avatarUrl === avatarUrl) return;
    this.world.loader.load("avatar", avatarUrl).then((src) => {
      if (this.avatar) this.avatar.deactivate();
      this.avatar = src.toNodes().get("avatar");
      this.base.add(this.avatar);
      this.nametag.position.y = this.avatar.getHeadToHeight() + 0.2;
      this.bubble.position.y = this.avatar.getHeadToHeight() + 0.2;
      if (!this.bubble.active) {
        this.nametag.active = true;
      }
      this.avatarUrl = avatarUrl;
      this.camHeight = this.avatar.height * 0.95;
    }).catch((err) => {
      console.error(err);
    });
  }
  initCapsule() {
    const radius = this.capsuleRadius;
    const height = this.capsuleHeight;
    const halfHeight = (height - radius - radius) / 2;
    const geometry = new PHYSX.PxCapsuleGeometry(radius, halfHeight);
    this.material = this.world.physics.physics.createMaterial(0, 0, 0);
    const flags = new PHYSX.PxShapeFlags(PHYSX.PxShapeFlagEnum.eSCENE_QUERY_SHAPE | PHYSX.PxShapeFlagEnum.eSIMULATION_SHAPE);
    const shape = this.world.physics.physics.createShape(geometry, this.material, true, flags);
    const localPose = new PHYSX.PxTransform(PHYSX.PxIDENTITYEnum.PxIdentity);
    q14.set(0, 0, 0).setFromAxisAngle(BACKWARD2, Math.PI / 2);
    q14.toPxTransform(localPose);
    v16.set(0, halfHeight + radius, 0);
    v16.toPxTransform(localPose);
    shape.setLocalPose(localPose);
    const filterData = new PHYSX.PxFilterData(
      Layers.player.group,
      Layers.player.mask,
      PHYSX.PxPairFlagEnum.eNOTIFY_TOUCH_FOUND | PHYSX.PxPairFlagEnum.eNOTIFY_TOUCH_LOST | PHYSX.PxPairFlagEnum.eNOTIFY_CONTACT_POINTS | PHYSX.PxPairFlagEnum.eDETECT_CCD_CONTACT | PHYSX.PxPairFlagEnum.eSOLVE_CONTACT | PHYSX.PxPairFlagEnum.eDETECT_DISCRETE_CONTACT,
      0
    );
    shape.setContactOffset(0.08);
    shape.setQueryFilterData(filterData);
    shape.setSimulationFilterData(filterData);
    const transform = new PHYSX.PxTransform(PHYSX.PxIDENTITYEnum.PxIdentity);
    v16.copy(this.base.position).toPxTransform(transform);
    q14.set(0, 0, 0, 1).toPxTransform(transform);
    this.capsule = this.world.physics.physics.createRigidDynamic(transform);
    this.capsule.setMass(this.mass);
    this.capsule.setRigidBodyFlag(PHYSX.PxRigidBodyFlagEnum.eENABLE_CCD, true);
    this.capsule.setRigidDynamicLockFlag(PHYSX.PxRigidDynamicLockFlagEnum.eLOCK_ANGULAR_X, true);
    this.capsule.setRigidDynamicLockFlag(PHYSX.PxRigidDynamicLockFlagEnum.eLOCK_ANGULAR_Z, true);
    this.capsule.setActorFlag(PHYSX.PxActorFlagEnum.eDISABLE_GRAVITY, true);
    this.capsule.attachShape(shape);
    let shape2;
    {
    }
    this.capsuleHandle = this.world.physics.addActor(this.capsule, {
      tag: null,
      playerId: this.data.id,
      onInterpolate: (position) => {
        this.base.position.copy(position);
      }
    });
  }
  initControl() {
    this.control = this.world.controls.bind({
      priority: ControlPriorities.PLAYER,
      onTouch: (touch) => {
        if (!this.stick && touch.position.x < this.control.screen.width / 2) {
          this.stick = {
            center: touch.position.clone(),
            touch
          };
        } else if (!this.pan) {
          this.pan = touch;
        }
      },
      onTouchEnd: (touch) => {
        if (this.stick?.touch === touch) {
          this.stick = null;
        }
        if (this.pan === touch) {
          this.pan = null;
        }
      }
    });
    if (!this.control.camera) return;
    this.control.camera.write = true;
    this.control.camera.position.copy(this.cam.position);
    this.control.camera.quaternion.copy(this.cam.quaternion);
    this.control.camera.zoom = this.cam.zoom;
  }
  toggleFlying() {
    const canFly = this.world.settings.public || hasRole(this.data.roles, "admin");
    if (!canFly) return;
    this.flying = !this.flying;
    if (this.flying) {
      const velocity = this.capsule.getLinearVelocity();
      velocity.y = 0;
      this.capsule.setLinearVelocity(velocity);
    } else {
    }
    this.lastJumpAt = -999;
  }
  getAnchorMatrix() {
    if (this.data.effect?.anchorId) {
      return this.world.anchors.get(this.data.effect.anchorId);
    }
    return null;
  }
  fixedUpdate(delta) {
    const freeze = this.data.effect?.freeze;
    const anchor = this.getAnchorMatrix();
    const snare = this.data.effect?.snare || 0;
    if (anchor && !this.capsuleDisabled) {
      this.capsule.setActorFlag(PHYSX.PxActorFlagEnum.eDISABLE_SIMULATION, true);
      this.capsuleDisabled = true;
    }
    if (!anchor && this.capsuleDisabled) {
      this.capsule.setActorFlag(PHYSX.PxActorFlagEnum.eDISABLE_SIMULATION, false);
      this.capsuleDisabled = false;
    }
    if (anchor) {
    } else if (!this.flying) {
      if (this.grounded) {
        const pose = this.capsule.getGlobalPose();
        const origin = v16.copy(pose.p);
        origin.y += 0.2;
        const hitMask = Layers.environment.group | Layers.prop.group;
        const hit = this.world.physics.raycast(origin, DOWN, 2, hitMask);
        let actor = hit?.handle?.actor || null;
        if (this.platform.actor !== actor) {
          this.platform.actor = actor;
          if (actor) {
            const platformPose = this.platform.actor.getGlobalPose();
            v16.copy(platformPose.p);
            q14.copy(platformPose.q);
            this.platform.prevTransform.compose(v16, q14, SCALE_IDENTITY);
          }
        }
        if (this.platform.actor) {
          const currTransform = m13;
          const platformPose = this.platform.actor.getGlobalPose();
          v16.copy(platformPose.p);
          q14.copy(platformPose.q);
          currTransform.compose(v16, q14, SCALE_IDENTITY);
          const deltaTransform = m2.multiplyMatrices(currTransform, this.platform.prevTransform.clone().invert());
          const deltaPosition = v24;
          const deltaQuaternion = q22;
          const deltaScale = v32;
          deltaTransform.decompose(deltaPosition, deltaQuaternion, deltaScale);
          const playerPose = this.capsule.getGlobalPose();
          v42.copy(playerPose.p);
          q3.copy(playerPose.q);
          const playerTransform = m3;
          playerTransform.compose(v42, q3, SCALE_IDENTITY);
          playerTransform.premultiply(deltaTransform);
          const newPosition = v52;
          const newQuaternion = q4;
          playerTransform.decompose(newPosition, newQuaternion, v62);
          const newPose = this.capsule.getGlobalPose();
          newPosition.toPxTransform(newPose);
          this.capsule.setGlobalPose(newPose);
          e12.setFromQuaternion(deltaQuaternion).reorder("YXZ");
          e12.x = 0;
          e12.z = 0;
          q14.setFromEuler(e12);
          this.base.quaternion.multiply(q14);
          this.base.updateTransform();
          this.platform.prevTransform.copy(currTransform);
        }
      } else {
        this.platform.actor = null;
      }
      let sweepHit;
      {
        const geometry = this.groundSweepGeometry;
        const pose = this.capsule.getGlobalPose();
        const origin = v16.copy(
          pose.p
          /*this.ghost.position*/
        );
        origin.y += this.groundSweepRadius + 0.12;
        const direction = DOWN;
        const maxDistance = 0.12 + 0.1;
        const hitMask = Layers.environment.group | Layers.prop.group;
        sweepHit = this.world.physics.sweep(geometry, origin, direction, maxDistance, hitMask);
      }
      if (sweepHit) {
        this.justLeftGround = false;
        this.grounded = true;
        this.groundNormal.copy(sweepHit.normal);
        this.groundAngle = UP.angleTo(this.groundNormal) * RAD2DEG;
      } else {
        this.justLeftGround = !!this.grounded;
        this.grounded = false;
        this.groundNormal.copy(UP);
        this.groundAngle = 0;
      }
      if (this.grounded && this.groundAngle > 60) {
        this.justLeftGround = false;
        this.grounded = false;
        this.groundNormal.copy(UP);
        this.groundAngle = 0;
        this.slipping = true;
      } else {
        this.slipping = false;
      }
      if (this.grounded) {
        if (this.materialMax !== true) {
          this.material.setFrictionCombineMode(PHYSX.PxCombineModeEnum.eMAX);
          this.material.setRestitutionCombineMode(PHYSX.PxCombineModeEnum.eMAX);
          this.materialMax = true;
        }
      } else {
        if (this.materialMax !== false) {
          this.material.setFrictionCombineMode(PHYSX.PxCombineModeEnum.eMIN);
          this.material.setRestitutionCombineMode(PHYSX.PxCombineModeEnum.eMIN);
          this.materialMax = false;
        }
      }
      if (this.jumped && !this.grounded) {
        this.jumped = false;
        this.jumping = true;
      }
      if (!this.grounded && this.capsule.getLinearVelocity().y < 0) {
        this.fallTimer += delta;
      } else {
        this.fallTimer = 0;
      }
      if (this.fallTimer > 0.1 && !this.falling) {
        this.jumping = false;
        this.airJumping = false;
        this.falling = true;
        this.fallStartY = this.base.position.y;
      }
      if (this.falling) {
        this.fallDistance = this.fallStartY - this.base.position.y;
      }
      if (this.falling && this.grounded) {
        this.falling = false;
      }
      if (this.jumping && this.grounded) {
        this.jumping = false;
      }
      if (this.airJumped && this.grounded) {
        this.airJumped = false;
        this.airJumping = false;
      }
      if (this.grounded) {
        if (this.platform.actor) {
          const isStatic = this.platform.actor instanceof PHYSX.PxRigidStatic;
          const isKinematic = this.platform.actor.getRigidBodyFlags?.().isSet(PHYSX.PxRigidBodyFlagEnum.eKINEMATIC);
          if (!isKinematic && !isStatic) {
            const amount = -9.81 * 0.2;
            const force = v16.set(0, amount, 0);
            PHYSX.PxRigidBodyExt.prototype.addForceAtPos(
              this.platform.actor,
              force.toPxVec3(),
              this.capsule.getGlobalPose().p,
              PHYSX.PxForceModeEnum.eFORCE,
              true
            );
          }
        }
      } else {
        const force = v16.set(0, -this.effectiveGravity, 0);
        this.capsule.addForce(force.toPxVec3(), PHYSX.PxForceModeEnum.eFORCE, true);
      }
      const velocity = v16.copy(this.capsule.getLinearVelocity());
      const dragCoeff = 10 * delta;
      let perpComponent = v24.copy(this.groundNormal).multiplyScalar(velocity.dot(this.groundNormal));
      let parallelComponent = v32.copy(velocity).sub(perpComponent);
      parallelComponent.multiplyScalar(1 - dragCoeff);
      velocity.copy(parallelComponent.add(perpComponent));
      if (this.grounded && !this.jumping) {
        const projectedLength = velocity.dot(this.groundNormal);
        const projectedVector = v24.copy(this.groundNormal).multiplyScalar(projectedLength);
        velocity.sub(projectedVector);
      }
      if (this.justLeftGround && !this.jumping) {
        velocity.y = -5;
      }
      if (this.slipping) {
        velocity.y -= 0.5;
      }
      if (this.pushForce) {
        if (!this.pushForceInit) {
          this.pushForceInit = true;
          if (this.pushForce.y) {
            this.jumped = true;
            this.jumping = false;
            this.falling = false;
            this.airJumped = false;
            this.airJumping = false;
          }
        }
        velocity.add(this.pushForce);
        const drag = 20;
        const decayFactor = 1 - drag * delta;
        if (decayFactor < 0) {
          this.pushForce.set(0, 0, 0);
        } else {
          this.pushForce.multiplyScalar(Math.max(decayFactor, 0));
        }
        if (this.pushForce.length() < 0.01) {
          this.pushForce = null;
        }
      }
      this.capsule.setLinearVelocity(velocity.toPxVec3());
      if (this.moving) {
        let moveSpeed = (this.running ? 8 : 4) * this.mass;
        moveSpeed *= 1 - snare;
        const slopeRotation = q14.setFromUnitVectors(UP, this.groundNormal);
        const moveForce = v16.copy(this.moveDir).multiplyScalar(moveSpeed * 10).applyQuaternion(slopeRotation);
        this.capsule.addForce(moveForce.toPxVec3(), PHYSX.PxForceModeEnum.eFORCE, true);
      }
      const shouldJump = this.grounded && !this.jumping && this.jumpDown && !this.data.effect?.snare && !this.data.effect?.freeze;
      const shouldAirJump = !this.grounded && !this.airJumped && this.jumpPressed && !this.world.builder.enabled;
      if (shouldJump || shouldAirJump) {
        let jumpVelocity = Math.sqrt(2 * this.effectiveGravity * this.jumpHeight);
        jumpVelocity = jumpVelocity * (1 / Math.sqrt(this.mass));
        const velocity2 = this.capsule.getLinearVelocity();
        velocity2.y = jumpVelocity;
        this.capsule.setLinearVelocity(velocity2);
        if (shouldJump) {
          this.jumped = true;
        }
        if (shouldAirJump) {
          this.falling = false;
          this.fallTimer = 0;
          this.jumping = true;
          this.airJumped = true;
          this.airJumping = true;
        }
      }
    } else {
      if (this.moving || this.jumpDown || this.control.keyC.down) {
        const flySpeed = this.flyForce * (this.running ? 2 : 1);
        const force = v16.copy(this.flyDir).multiplyScalar(flySpeed);
        if (this.jumpDown) {
          force.y = flySpeed;
        } else if (this.control.keyC.down) {
          force.y = -flySpeed;
        }
        this.capsule.addForce(force.toPxVec3(), PHYSX.PxForceModeEnum.eFORCE, true);
      }
      const velocity = v24.copy(this.capsule.getLinearVelocity());
      const dragForce = v32.copy(velocity).multiplyScalar(-this.flyDrag * delta);
      this.capsule.addForce(dragForce.toPxVec3(), PHYSX.PxForceModeEnum.eFORCE, true);
      const zeroAngular = v42.set(0, 0, 0);
      this.capsule.setAngularVelocity(zeroAngular.toPxVec3());
      if (!this.world.builder.enabled) {
        this.toggleFlying();
      }
    }
    if (this.jumpPressed && this.world.builder.enabled) {
      if (this.world.time - this.lastJumpAt < 0.4) {
        this.toggleFlying();
      }
      this.lastJumpAt = this.world.time;
    }
    this.jumpPressed = false;
  }
  update(delta) {
    const isXR = this.world.xr?.session;
    const freeze = this.data.effect?.freeze;
    const anchor = this.getAnchorMatrix();
    if (isXR) {
      this.cam.rotation.set(0, 0, 0);
    } else if (this.control.pointer.locked) {
      this.cam.rotation.x += -this.control.pointer.delta.y * POINTER_LOOK_SPEED * delta;
      this.cam.rotation.y += -this.control.pointer.delta.x * POINTER_LOOK_SPEED * delta;
      this.cam.rotation.z = 0;
    } else if (this.pan) {
      this.cam.rotation.x += -this.pan.delta.y * PAN_LOOK_SPEED * delta;
      this.cam.rotation.y += -this.pan.delta.x * PAN_LOOK_SPEED * delta;
      this.cam.rotation.z = 0;
    }
    if (!isXR) {
      this.cam.rotation.x = clamp(this.cam.rotation.x, -89 * DEG2RAD, 89 * DEG2RAD);
    }
    if (!isXR) {
      this.cam.zoom += -this.control.scrollDelta.value * ZOOM_SPEED * delta;
      this.cam.zoom = clamp(this.cam.zoom, MIN_ZOOM, MAX_ZOOM);
    }
    this.jumpDown = isXR ? this.control.xrRightBtn1.down : this.control.space.down || this.control.touchA.down;
    if (isXR ? this.control.xrRightBtn1.pressed : this.control.space.pressed || this.control.touchA.pressed) {
      this.jumpPressed = true;
    }
    this.moveDir.set(0, 0, 0);
    if (isXR) {
      this.moveDir.x = this.control.xrLeftStick.value.x;
      this.moveDir.z = this.control.xrLeftStick.value.z;
    } else if (this.stick) {
      const touchX = this.stick.touch.position.x;
      const touchY = this.stick.touch.position.y;
      const centerX = this.stick.center.x;
      const centerY = this.stick.center.y;
      const dx = centerX - touchX;
      const dy = centerY - touchY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      if (distance > STICK_MAX_DISTANCE) {
        this.stick.center.x = touchX + STICK_MAX_DISTANCE * dx / distance;
        this.stick.center.y = touchY + STICK_MAX_DISTANCE * dy / distance;
      }
      const stickX = (touchX - this.stick.center.x) / STICK_MAX_DISTANCE;
      const stickY = (touchY - this.stick.center.y) / STICK_MAX_DISTANCE;
      this.moveDir.x = stickX;
      this.moveDir.z = stickY;
    } else {
      if (this.control.keyW.down || this.control.arrowUp.down) this.moveDir.z -= 1;
      if (this.control.keyS.down || this.control.arrowDown.down) this.moveDir.z += 1;
      if (this.control.keyA.down || this.control.arrowLeft.down) this.moveDir.x -= 1;
      if (this.control.keyD.down || this.control.arrowRight.down) this.moveDir.x += 1;
    }
    this.moving = this.moveDir.length() > 0;
    if (this.data.effect?.cancellable && (this.moving || this.jumpDown)) {
      this.setEffect(null);
    }
    if (freeze || anchor) {
      this.moveDir.set(0, 0, 0);
      this.moving = false;
    }
    if (this.stick || isXR) {
      this.running = this.moving && this.moveDir.length() > 0.5;
    } else {
      this.running = this.moving && (this.control.shiftLeft.down || this.control.shiftRight.down);
    }
    this.moveDir.normalize();
    if (isXR) {
      this.flyDir.copy(this.moveDir);
      this.flyDir.applyQuaternion(this.world.xr.camera.quaternion);
    } else {
      this.flyDir.copy(this.moveDir);
      this.flyDir.applyQuaternion(this.cam.quaternion);
    }
    if (isXR) {
      e12.copy(this.world.xr.camera.rotation).reorder("YXZ");
      const yQuaternion = q14.setFromAxisAngle(UP, e12.y);
      this.moveDir.applyQuaternion(yQuaternion);
    } else {
      const yQuaternion = q14.setFromAxisAngle(UP, this.cam.rotation.y);
      this.moveDir.applyQuaternion(yQuaternion);
    }
    if (this.data.effect?.turn) {
      let cameraY = 0;
      if (isXR) {
        e12.copy(this.world.xr.camera.rotation).reorder("YXZ");
        cameraY = e12.y;
      } else {
        cameraY = this.cam.rotation.y;
      }
      e12.set(0, cameraY, 0);
      q14.setFromEuler(e12);
      const alpha = 1 - Math.pow(1e-8, delta);
      this.base.quaternion.slerp(q14, alpha);
    } else if (this.moving) {
      const alpha = 1 - Math.pow(1e-8, delta);
      q14.setFromUnitVectors(FORWARD2, this.moveDir);
      this.base.quaternion.slerp(q14, alpha);
    }
    let emote;
    if (this.data.effect?.emote) {
      emote = this.data.effect.emote;
    } else if (this.flying) {
      emote = Emotes.FLOAT;
    } else if (this.airJumping) {
      emote = Emotes.FLIP;
    } else if (this.jumping) {
      emote = Emotes.FLOAT;
    } else if (this.falling) {
      emote = this.fallDistance > 1.6 ? Emotes.FALL : Emotes.FLOAT;
    } else if (this.moving) {
      emote = this.running ? Emotes.RUN : Emotes.WALK;
    } else if (this.speaking) {
      emote = Emotes.TALK;
    }
    if (!emote) emote = Emotes.IDLE;
    let emoteChanged;
    if (this.emote !== emote) {
      this.emote = emote;
      emoteChanged = true;
    }
    this.avatar?.setEmote(this.emote);
    this.lastSendAt += delta;
    if (this.lastSendAt >= this.world.networkRate) {
      if (!this.lastState) {
        this.lastState = {
          id: this.data.id,
          p: this.base.position.clone(),
          q: this.base.quaternion.clone(),
          e: this.emote
        };
      }
      const data = {
        id: this.data.id
      };
      let hasChanges;
      if (!this.lastState.p.equals(this.base.position)) {
        data.p = this.base.position.toArray();
        this.lastState.p.copy(this.base.position);
        hasChanges = true;
      }
      if (!this.lastState.q.equals(this.base.quaternion)) {
        data.q = this.base.quaternion.toArray();
        this.lastState.q.copy(this.base.quaternion);
        hasChanges = true;
      }
      if (this.lastState.e !== this.emote) {
        data.e = this.emote;
        this.lastState.e = this.emote;
        hasChanges = true;
      }
      if (hasChanges) {
        this.world.network.send("entityModified", data);
      }
      this.lastSendAt = 0;
    }
    if (this.data.effect?.duration) {
      this.data.effect.duration -= delta;
      if (this.data.effect.duration <= 0) {
        this.setEffect(null);
      }
    }
  }
  lateUpdate(delta) {
    const isXR = this.world.xr?.session;
    const anchor = this.getAnchorMatrix();
    if (anchor) {
      this.base.position.setFromMatrixPosition(anchor);
      this.base.quaternion.setFromRotationMatrix(anchor);
      const pose = this.capsule.getGlobalPose();
      this.base.position.toPxTransform(pose);
      this.capsuleHandle.snap(pose);
    }
    this.cam.position.copy(this.base.position);
    if (isXR) {
    } else {
      this.cam.position.y += this.camHeight;
      const forward = v16.copy(FORWARD2).applyQuaternion(this.cam.quaternion);
      const right = v24.crossVectors(forward, UP).normalize();
      this.cam.position.add(right.multiplyScalar(0.3));
    }
    if (this.world.xr?.session) {
      this.control.camera.position.copy(this.cam.position);
      this.control.camera.quaternion.copy(this.cam.quaternion);
    } else if (this.cam && this.control.camera) {
      simpleCamLerp(this.world, this.control.camera, this.cam, delta);
    }
    if (this.avatar) {
      const matrix = this.avatar.getBoneTransform("head");
      if (matrix) this.aura.position.setFromMatrixPosition(matrix);
    }
  }
  teleport({ position, rotationY }) {
    position = position.isVector3 ? position : new Vector3Enhanced().fromArray(position);
    const hasRotation = isNumber19(rotationY);
    const pose = this.capsule.getGlobalPose();
    position.toPxTransform(pose);
    this.capsuleHandle.snap(pose);
    this.base.position.copy(position);
    if (hasRotation) this.base.rotation.y = rotationY;
    this.world.network.send("entityModified", {
      id: this.data.id,
      p: this.base.position.toArray(),
      q: this.base.quaternion.toArray(),
      t: true
    });
    this.cam.position.copy(this.base.position);
    this.cam.position.y += this.camHeight;
    if (hasRotation) this.cam.rotation.y = rotationY;
    this.control.camera.position.copy(this.cam.position);
    this.control.camera.quaternion.copy(this.cam.quaternion);
  }
  setEffect(effect, onEnd) {
    if (this.data.effect === effect) return;
    if (this.data.effect) {
      this.data.effect = null;
      this.onEffectEnd?.();
      this.onEffectEnd = null;
    }
    this.data.effect = effect;
    this.onEffectEnd = onEnd;
    this.world.network.send("entityModified", {
      id: this.data.id,
      ef: effect
    });
  }
  setSpeaking(speaking) {
    if (this.speaking === speaking) return;
    this.speaking = speaking;
  }
  push(force) {
    force = v16.fromArray(force);
    if (this.pushForce) {
      this.pushForce.add(force);
    } else {
      this.pushForce = force.clone();
      this.pushForceInit = false;
    }
  }
  setSessionAvatar(avatar) {
    this.data.sessionAvatar = avatar;
    this.applyAvatar();
    this.world.network.send("entityModified", {
      id: this.data.id,
      sessionAvatar: avatar
    });
  }
  chat(msg) {
    this.nametag.active = false;
    this.bubbleText.value = msg;
    this.bubble.active = true;
    clearTimeout(this.chatTimer);
    this.chatTimer = setTimeout(() => {
      this.bubble.active = false;
      this.nametag.active = true;
    }, 5e3);
  }
  modify(data) {
    let avatarChanged;
    let changed;
    if (data.hasOwnProperty("name")) {
      this.data.name = data.name;
      changed = true;
    }
    if (data.hasOwnProperty("health")) {
      this.data.health = data.health;
      this.nametag.health = data.health;
      this.world.events.emit("health", { playerId: this.data.id, health: data.health });
      console.log("modify", data.health);
    }
    if (data.hasOwnProperty("avatar")) {
      this.data.avatar = data.avatar;
      avatarChanged = true;
      changed = true;
    }
    if (data.hasOwnProperty("sessionAvatar")) {
      this.data.sessionAvatar = data.sessionAvatar;
      avatarChanged = true;
    }
    if (data.hasOwnProperty("ef")) {
      if (this.data.effect) {
        this.data.effect = null;
        this.onEffectEnd?.();
        this.onEffectEnd = null;
      }
      this.data.effect = data.ef;
    }
    if (data.hasOwnProperty("roles")) {
      this.data.roles = data.roles;
      changed = true;
    }
    if (avatarChanged) {
      this.applyAvatar();
    }
    if (changed) {
      this.world.emit("player", this);
    }
  }
};

// src/core/entities/PlayerRemote.js
var capsuleGeometry;
{
  const radius = 0.3;
  const inner = 1.2;
  const height = radius + inner + radius;
  capsuleGeometry = new three_exports.CapsuleGeometry(radius, inner);
  capsuleGeometry.translate(0, height / 2, 0);
}
var PlayerRemote = class extends Entity {
  constructor(world2, data, local) {
    super(world2, data, local);
    this.isPlayer = true;
    this.init();
  }
  async init() {
    this.base = createNode("group");
    this.base.position.fromArray(this.data.position);
    this.base.quaternion.fromArray(this.data.quaternion);
    this.body = createNode("rigidbody", { type: "kinematic" });
    this.body.active = this.data.effect?.anchorId ? false : true;
    this.base.add(this.body);
    this.collider = createNode("collider", {
      type: "geometry",
      convex: true,
      geometry: capsuleGeometry,
      layer: "player"
    });
    this.body.add(this.collider);
    this.aura = createNode("group");
    this.nametag = createNode("nametag", { label: this.data.name, health: this.data.health, active: false });
    this.aura.add(this.nametag);
    this.bubble = createNode("ui", {
      width: 300,
      height: 512,
      pivot: "bottom-center",
      billboard: "full",
      scaler: [3, 30],
      justifyContent: "flex-end",
      alignItems: "center",
      active: false
    });
    this.bubbleBox = createNode("uiview", {
      backgroundColor: "rgba(0, 0, 0, 0.8)",
      borderRadius: 10,
      padding: 10
    });
    this.bubbleText = createNode("uitext", {
      color: "white",
      fontWeight: 100,
      lineHeight: 1.4,
      fontSize: 16
    });
    this.bubble.add(this.bubbleBox);
    this.bubbleBox.add(this.bubbleText);
    this.aura.add(this.bubble);
    this.aura.activate({ world: this.world, entity: this });
    this.base.activate({ world: this.world, entity: this });
    this.applyAvatar();
    this.position = new LerpVector3(this.base.position, this.world.networkRate);
    this.quaternion = new LerpQuaternion(this.base.quaternion, this.world.networkRate);
    this.teleport = 0;
    this.world.setHot(this, true);
  }
  applyAvatar() {
    if (!this.world.loader) return;
    const avatarUrl = this.data.sessionAvatar || this.data.avatar || "asset://avatar.vrm";
    if (this.avatarUrl === avatarUrl) return;
    this.world.loader.load("avatar", avatarUrl).then((src) => {
      if (this.avatar) this.avatar.deactivate();
      this.avatar = src.toNodes().get("avatar");
      this.base.add(this.avatar);
      this.nametag.position.y = this.avatar.getHeadToHeight() + 0.2;
      this.bubble.position.y = this.avatar.getHeadToHeight() + 0.2;
      if (!this.bubble.active) {
        this.nametag.active = true;
      }
      this.avatarUrl = avatarUrl;
    });
  }
  getAnchorMatrix() {
    if (this.data.effect?.anchorId) {
      return this.world.anchors.get(this.data.effect.anchorId);
    }
  }
  update(delta) {
    const anchor = this.getAnchorMatrix();
    if (!anchor) {
      this.position.update(delta);
      this.quaternion.update(delta);
    }
    this.avatar?.setEmote(this.data.emote);
  }
  lateUpdate(delta) {
    const anchor = this.getAnchorMatrix();
    if (anchor) {
      this.position.snap();
      this.quaternion.snap();
      this.base.position.setFromMatrixPosition(anchor);
      this.base.quaternion.setFromRotationMatrix(anchor);
      this.base.clean();
    }
    if (this.avatar) {
      const matrix = this.avatar.getBoneTransform("head");
      if (matrix) {
        this.aura.position.setFromMatrixPosition(matrix);
      }
    }
  }
  setEffect(effect, onEnd) {
    if (this.data.effect) {
      this.data.effect = null;
      this.onEffectEnd?.();
      this.onEffectEnd = null;
    }
    this.data.effect = effect;
    this.onEffectEnd = onEnd;
    this.body.active = effect?.anchorId ? false : true;
  }
  setSpeaking(speaking) {
    if (this.speaking === speaking) return;
    this.speaking = speaking;
    const name2 = this.data.name;
    this.nametag.label = speaking ? `\xBB ${name2} \xAB` : name2;
  }
  modify(data) {
    let avatarChanged;
    if (data.hasOwnProperty("t")) {
      this.teleport++;
    }
    if (data.hasOwnProperty("p")) {
      this.data.position = data.p;
      this.position.pushArray(data.p, this.teleport);
    }
    if (data.hasOwnProperty("q")) {
      this.data.quaternion = data.q;
      this.quaternion.pushArray(data.q, this.teleport);
    }
    if (data.hasOwnProperty("e")) {
      this.data.emote = data.e;
    }
    if (data.hasOwnProperty("ef")) {
      this.setEffect(data.ef);
    }
    if (data.hasOwnProperty("name")) {
      this.data.name = data.name;
      this.nametag.label = data.name;
    }
    if (data.hasOwnProperty("health")) {
      this.data.health = data.health;
      this.nametag.health = data.health;
      this.world.events.emit("health", { playerId: this.data.id, health: data.health });
    }
    if (data.hasOwnProperty("avatar")) {
      this.data.avatar = data.avatar;
      avatarChanged = true;
    }
    if (data.hasOwnProperty("sessionAvatar")) {
      this.data.sessionAvatar = data.sessionAvatar;
      avatarChanged = true;
    }
    if (data.hasOwnProperty("roles")) {
      this.data.roles = data.roles;
    }
    if (avatarChanged) {
      this.applyAvatar();
    }
  }
  chat(msg) {
    this.nametag.active = false;
    this.bubbleText.value = msg;
    this.bubble.active = true;
    clearTimeout(this.chatTimer);
    this.chatTimer = setTimeout(() => {
      this.bubble.active = false;
      this.nametag.active = true;
    }, 5e3);
  }
  destroy(local) {
    if (this.destroyed) return;
    this.destroyed = true;
    clearTimeout(this.chatTimer);
    this.base.deactivate();
    this.avatar = null;
    this.world.setHot(this, false);
    this.world.events.emit("leave", { playerId: this.data.id });
    this.aura.deactivate();
    this.aura = null;
    this.world.entities.remove(this.data.id);
    if (local) {
      this.world.network.send("entityRemoved", this.data.id);
    }
  }
};

// src/core/systems/Entities.js
var Types = {
  app: App,
  playerLocal: PlayerLocal,
  playerRemote: PlayerRemote
};
var Entities = class extends System {
  constructor(world2) {
    super(world2);
    this.items = /* @__PURE__ */ new Map();
    this.players = /* @__PURE__ */ new Map();
    this.hot = /* @__PURE__ */ new Set();
    this.removed = [];
  }
  get(id) {
    return this.items.get(id);
  }
  getPlayer(entityId) {
    return this.players.get(entityId);
  }
  add(data, local) {
    let Entity2;
    if (data.type === "player") {
      Entity2 = Types[data.owner === this.world.network.id ? "playerLocal" : "playerRemote"];
    } else {
      Entity2 = Types[data.type];
    }
    const entity = new Entity2(this.world, data, local);
    this.items.set(entity.data.id, entity);
    if (data.type === "player") {
      this.players.set(entity.data.id, entity);
      if (this.world.network.isClient && data.owner !== this.world.network.id) {
        this.world.events.emit("enter", { playerId: entity.data.id });
      }
    }
    if (data.owner === this.world.network.id) {
      this.player = entity;
      this.world.emit("player", entity);
    }
    return entity;
  }
  remove(id) {
    const entity = this.items.get(id);
    if (!entity) console.warn(`tried to remove entity that did not exist: ${id}`);
    if (entity.isPlayer) this.players.delete(entity.data.id);
    entity.destroy();
    this.items.delete(id);
    this.removed.push(id);
  }
  setHot(entity, hot) {
    if (hot) {
      this.hot.add(entity);
    } else {
      this.hot.delete(entity);
    }
  }
  fixedUpdate(delta) {
    for (const entity of this.hot) {
      entity.fixedUpdate(delta);
    }
  }
  update(delta) {
    for (const entity of this.hot) {
      entity.update(delta);
    }
  }
  lateUpdate(delta) {
    for (const entity of this.hot) {
      entity.lateUpdate(delta);
    }
  }
  serialize() {
    const data = [];
    this.items.forEach((entity) => {
      data.push(entity.serialize());
    });
    return data;
  }
  deserialize(datas) {
    for (const data of datas) {
      this.add(data);
    }
  }
};

// src/core/extras/extendThreePhysX.js
function extendThreePhysX() {
  if (!PHYSX) throw new Error("PHYSX not initialised");
  if (Vector3Enhanced.prototype.fromPxVec3) return;
  const _pxVec3 = new PHYSX.PxVec3();
  const _pxExtVec3 = new PHYSX.PxExtendedVec3();
  const pos = new Vector3Enhanced();
  const qua = new three_exports.Quaternion();
  const sca = new Vector3Enhanced();
  Vector3Enhanced.prototype.fromPxVec3 = function(pxVec3) {
    this.x = pxVec3.x;
    this.y = pxVec3.y;
    this.z = pxVec3.z;
    return this;
  };
  Vector3Enhanced.prototype.toPxVec3 = function(pxVec3 = _pxVec3) {
    pxVec3.x = this.x;
    pxVec3.y = this.y;
    pxVec3.z = this.z;
    return pxVec3;
  };
  Vector3Enhanced.prototype.toPxExtVec3 = function(pxExtVec3 = _pxExtVec3) {
    pxExtVec3.x = this.x;
    pxExtVec3.y = this.y;
    pxExtVec3.z = this.z;
    return pxExtVec3;
  };
  Vector3Enhanced.prototype.toPxTransform = function(pxTransform) {
    pxTransform.p.x = this.x;
    pxTransform.p.y = this.y;
    pxTransform.p.z = this.z;
  };
  three_exports.Quaternion.prototype.toPxTransform = function(pxTransform) {
    pxTransform.q.x = this.x;
    pxTransform.q.y = this.y;
    pxTransform.q.z = this.z;
    pxTransform.q.w = this.w;
  };
  three_exports.Matrix4.prototype.toPxTransform = function(pxTransform) {
    this.decompose(pos, qua, sca);
    pxTransform.p.x = pos.x;
    pxTransform.p.y = pos.y;
    pxTransform.p.z = pos.z;
    pxTransform.q.x = qua.x;
    pxTransform.q.y = qua.y;
    pxTransform.q.z = qua.z;
    pxTransform.q.w = qua.w;
  };
}

// src/core/systems/Physics.js
var _raycastHit = {
  actor: null,
  point: new Vector3Enhanced(),
  normal: new Vector3Enhanced(),
  distance: null
};
var _sweepHit = {
  actor: null,
  point: new Vector3Enhanced(),
  normal: new Vector3Enhanced(),
  distance: null
};
var overlapHitPool = [];
var overlapHits = [];
var Physics = class extends System {
  constructor(world2) {
    super(world2);
    this.scene = null;
  }
  async init({ loadPhysX: loadPhysX2 }) {
    const info = await loadPhysX2();
    this.version = info.version;
    this.allocator = info.allocator;
    this.errorCb = info.errorCb;
    this.foundation = info.foundation;
    extendThreePhysX();
    this.tolerances = new PHYSX.PxTolerancesScale();
    this.cookingParams = new PHYSX.PxCookingParams(this.tolerances);
    this.physics = PHYSX.CreatePhysics(this.version, this.foundation, this.tolerances);
    this.defaultMaterial = this.physics.createMaterial(0.2, 0.2, 0.2);
    this.callbackQueue = [];
    this.getContactCallback = createPool(() => {
      const contactPool = [];
      const contacts = [];
      let idx = 0;
      return {
        start: false,
        fn0: null,
        event0: {
          tag: null,
          playerId: null,
          contacts
        },
        fn1: null,
        event1: {
          tag: null,
          playerId: null,
          contacts
        },
        addContact(position, normal, impulse) {
          if (!contactPool[idx]) {
            contactPool[idx] = {
              position: new Vector3Enhanced(),
              normal: new Vector3Enhanced(),
              impulse: new Vector3Enhanced()
            };
          }
          const contact = contactPool[idx];
          contact.position.copy(position);
          contact.normal.copy(normal);
          contact.impulse.copy(impulse);
          contacts.push(contact);
          idx++;
        },
        init(start) {
          this.start = start;
          this.fn0 = null;
          this.fn1 = null;
          contacts.length = 0;
          idx = 0;
          return this;
        },
        exec() {
          if (this.fn0) {
            try {
              this.fn0(this.event0);
            } catch (err) {
              console.error(err);
            }
          }
          if (this.fn1) {
            try {
              this.fn1(this.event1);
            } catch (err) {
              console.error(err);
            }
          }
          this.release();
        }
      };
    });
    this.contactCallbacks = [];
    this.queueContactCallback = (cb) => {
      this.contactCallbacks.push(cb);
    };
    this.processContactCallbacks = () => {
      for (const cb of this.contactCallbacks) {
        cb.exec();
      }
      this.contactCallbacks.length = 0;
    };
    const contactPoints = new PHYSX.PxArray_PxContactPairPoint(64);
    const simulationEventCallback = new PHYSX.PxSimulationEventCallbackImpl();
    simulationEventCallback.onContact = (pairHeader, pairs, count) => {
      pairHeader = PHYSX.wrapPointer(pairHeader, PHYSX.PxContactPairHeader);
      const handle0 = this.handles.get(pairHeader.get_actors(0)?.ptr);
      const handle1 = this.handles.get(pairHeader.get_actors(1)?.ptr);
      if (!handle0 || !handle1) return;
      for (let i5 = 0; i5 < count; i5++) {
        const pair = PHYSX.NativeArrayHelpers.prototype.getContactPairAt(pairs, i5);
        if (pair.events.isSet(PHYSX.PxPairFlagEnum.eNOTIFY_TOUCH_FOUND)) {
          const contactCallback = this.getContactCallback().init(true);
          this.contactCallbacks.push(contactCallback);
          const pxContactPoints = pair.extractContacts(contactPoints.begin(), 64);
          if (pxContactPoints > 0) {
            for (let j4 = 0; j4 < pxContactPoints; j4++) {
              const contact = contactPoints.get(j4);
              contactCallback.addContact(contact.position, contact.normal, contact.impulse);
            }
          }
          if (!handle0.contactedHandles.has(handle1)) {
            if (handle0.onContactStart) {
              contactCallback.fn0 = handle0.onContactStart;
              contactCallback.event0.tag = handle1.tag;
              contactCallback.event0.playerId = handle1.playerId;
            }
            handle0.contactedHandles.add(handle1);
          }
          if (!handle1.contactedHandles.has(handle0)) {
            if (handle1.onContactStart) {
              contactCallback.fn1 = handle1.onContactStart;
              contactCallback.event1.tag = handle0.tag;
              contactCallback.event1.playerId = handle0.playerId;
            }
            handle1.contactedHandles.add(handle0);
          }
        } else if (pair.events.isSet(PHYSX.PxPairFlagEnum.eNOTIFY_TOUCH_LOST)) {
          const contactCallback = this.getContactCallback().init(false);
          this.contactCallbacks.push(contactCallback);
          if (handle0.contactedHandles.has(handle1)) {
            if (handle0.onContactEnd) {
              contactCallback.fn0 = handle0.onContactEnd;
              contactCallback.event0.tag = handle1.tag;
              contactCallback.event0.playerId = handle1.playerId;
            }
            handle0.contactedHandles.delete(handle1);
          }
          if (handle1.contactedHandles.has(handle0)) {
            if (handle1.onContactEnd) {
              contactCallback.fn1 = handle1.onContactEnd;
              contactCallback.event1.tag = handle0.tag;
              contactCallback.event1.playerId = handle0.playerId;
            }
            handle1.contactedHandles.delete(handle0);
          }
        }
      }
    };
    this.getTriggerCallback = createPool(() => {
      return {
        fn: null,
        event: {
          tag: null,
          playerId: null
        },
        exec() {
          try {
            this.fn(this.event);
          } catch (err) {
            console.error(err);
          }
          this.release();
        }
      };
    });
    this.triggerCallbacks = [];
    this.queueTriggerCallback = (cb) => {
      this.triggerCallbacks.push(cb);
    };
    this.processTriggerCallbacks = () => {
      for (const cb of this.triggerCallbacks) {
        cb.exec();
      }
      this.triggerCallbacks.length = 0;
    };
    simulationEventCallback.onTrigger = (pairs, count) => {
      pairs = PHYSX.wrapPointer(pairs, PHYSX.PxTriggerPair);
      for (let i5 = 0; i5 < count; i5++) {
        const pair = PHYSX.NativeArrayHelpers.prototype.getTriggerPairAt(pairs, i5);
        if (pair.flags.isSet(PHYSX.PxTriggerPairFlagEnum.eREMOVED_SHAPE_TRIGGER) || pair.flags.isSet(PHYSX.PxTriggerPairFlagEnum.eREMOVED_SHAPE_OTHER)) {
          continue;
        }
        const triggerHandle = this.handles.get(pair.triggerShape.getActor().ptr);
        const otherHandle = this.handles.get(pair.otherShape.getActor().ptr);
        if (!triggerHandle || !otherHandle) continue;
        if (pair.status === PHYSX.PxPairFlagEnum.eNOTIFY_TOUCH_FOUND) {
          if (!otherHandle.triggeredHandles.has(triggerHandle)) {
            if (triggerHandle.onTriggerEnter) {
              const cb = this.getTriggerCallback();
              cb.fn = triggerHandle.onTriggerEnter;
              cb.event.tag = otherHandle.tag;
              cb.event.playerId = otherHandle.playerId;
              this.triggerCallbacks.push(cb);
            }
            otherHandle.triggeredHandles.add(triggerHandle);
          }
        } else if (pair.status === PHYSX.PxPairFlagEnum.eNOTIFY_TOUCH_LOST) {
          if (otherHandle.triggeredHandles.has(triggerHandle)) {
            if (triggerHandle.onTriggerLeave) {
              const cb = this.getTriggerCallback();
              cb.fn = triggerHandle.onTriggerLeave;
              cb.event.tag = otherHandle.tag;
              cb.event.playerId = otherHandle.playerId;
              this.triggerCallbacks.push(cb);
            }
            otherHandle.triggeredHandles.delete(triggerHandle);
          }
        }
      }
    };
    simulationEventCallback.onConstraintBreak = (...args) => {
      console.error("TODO: onContraintBreak", ...args);
    };
    const sceneDesc = new PHYSX.PxSceneDesc(this.tolerances);
    sceneDesc.gravity = new PHYSX.PxVec3(0, -9.81, 0);
    sceneDesc.cpuDispatcher = PHYSX.DefaultCpuDispatcherCreate(0);
    sceneDesc.filterShader = PHYSX.DefaultFilterShader();
    sceneDesc.flags.raise(PHYSX.PxSceneFlagEnum.eENABLE_CCD, true);
    sceneDesc.flags.raise(PHYSX.PxSceneFlagEnum.eENABLE_ACTIVE_ACTORS, true);
    sceneDesc.solverType = PHYSX.PxSolverTypeEnum.eTGS;
    sceneDesc.simulationEventCallback = simulationEventCallback;
    sceneDesc.broadPhaseType = PHYSX.PxBroadPhaseTypeEnum.eGPU;
    this.scene = this.physics.createScene(sceneDesc);
    this.handles = /* @__PURE__ */ new Map();
    this.active = /* @__PURE__ */ new Set();
    this.materials = {};
    this.raycastResult = new PHYSX.PxRaycastResult();
    this.sweepPose = new PHYSX.PxTransform(PHYSX.PxIDENTITYEnum.PxIdentity);
    this.sweepResult = new PHYSX.PxSweepResult();
    this.overlapPose = new PHYSX.PxTransform(PHYSX.PxIDENTITYEnum.PxIdentity);
    this.overlapResult = new PHYSX.PxOverlapResult();
    this.queryFilterData = new PHYSX.PxQueryFilterData();
    this._pv1 = new PHYSX.PxVec3();
    this._pv2 = new PHYSX.PxVec3();
    this.transform = new PHYSX.PxTransform(PHYSX.PxIDENTITYEnum.PxIdentity);
    this.setupControllerManager();
  }
  setupControllerManager() {
    this.controllerManager = PHYSX.PxTopLevelFunctions.prototype.CreateControllerManager(this.scene);
    this.controllerFilters = new PHYSX.PxControllerFilters();
    this.controllerFilters.mFilterData = new PHYSX.PxFilterData(Layers.player.group, Layers.player.mask, 0, 0);
    const filterCallback = new PHYSX.PxQueryFilterCallbackImpl();
    filterCallback.simplePreFilter = (filterDataPtr, shapePtr, actor) => {
      const filterData = PHYSX.wrapPointer(filterDataPtr, PHYSX.PxFilterData);
      const shape = PHYSX.wrapPointer(shapePtr, PHYSX.PxShape);
      const shapeFilterData = shape.getQueryFilterData();
      if (filterData.word0 & shapeFilterData.word1 && shapeFilterData.word0 & filterData.word1) {
        return PHYSX.PxQueryHitType.eBLOCK;
      }
      return PHYSX.PxQueryHitType.eNONE;
    };
    this.controllerFilters.mFilterCallback = filterCallback;
    const cctFilterCallback = new PHYSX.PxControllerFilterCallbackImpl();
    cctFilterCallback.filter = (aPtr, bPtr) => {
      return true;
    };
    this.controllerFilters.mCCTFilterCallback = cctFilterCallback;
  }
  start() {
    const size = 1e3;
    const geometry = new PHYSX.PxBoxGeometry(size / 2, 1 / 2, size / 2);
    const material2 = this.physics.createMaterial(0.6, 0.6, 0);
    const flags = new PHYSX.PxShapeFlags(PHYSX.PxShapeFlagEnum.eSCENE_QUERY_SHAPE | PHYSX.PxShapeFlagEnum.eSIMULATION_SHAPE);
    const shape = this.physics.createShape(geometry, material2, true, flags);
    const layer = Layers.environment;
    const filterData = new PHYSX.PxFilterData(layer.group, layer.mask, 0, 0);
    shape.setQueryFilterData(filterData);
    shape.setSimulationFilterData(filterData);
    const transform = new PHYSX.PxTransform(PHYSX.PxIDENTITYEnum.PxIdentity);
    transform.p.y = -0.5;
    const body = this.physics.createRigidStatic(transform);
    body.attachShape(shape);
    this.scene.addActor(body);
  }
  addActor(actor, handle) {
    handle.actor = actor;
    handle.contactedHandles = /* @__PURE__ */ new Set();
    handle.triggeredHandles = /* @__PURE__ */ new Set();
    if (handle.onInterpolate) {
      handle.interpolation = {
        prev: {
          position: new Vector3Enhanced(),
          quaternion: new three_exports.Quaternion()
        },
        next: {
          position: new Vector3Enhanced(),
          quaternion: new three_exports.Quaternion()
        },
        curr: {
          position: new Vector3Enhanced(),
          quaternion: new three_exports.Quaternion()
        }
      };
      const pose = actor.getGlobalPose();
      handle.interpolation.prev.position.copy(pose.p);
      handle.interpolation.prev.quaternion.copy(pose.q);
      handle.interpolation.next.position.copy(pose.p);
      handle.interpolation.next.quaternion.copy(pose.q);
      handle.interpolation.curr.position.copy(pose.p);
      handle.interpolation.curr.quaternion.copy(pose.q);
    }
    this.handles.set(actor.ptr, handle);
    if (!handle.controller) {
      this.scene.addActor(actor);
    }
    return {
      move: (matrix) => {
        if (this.ignoreSetGlobalPose) {
          const isDynamic = !actor.getRigidBodyFlags?.().isSet(PHYSX.PxRigidBodyFlagEnum.eKINEMATIC);
          if (isDynamic) return;
          return;
        }
        matrix.toPxTransform(this.transform);
        actor.setGlobalPose(this.transform);
      },
      snap: (pose) => {
        actor.setGlobalPose(pose);
        handle.interpolation.prev.position.copy(pose.p);
        handle.interpolation.prev.quaternion.copy(pose.q);
        handle.interpolation.next.position.copy(pose.p);
        handle.interpolation.next.quaternion.copy(pose.q);
        handle.interpolation.curr.position.copy(pose.p);
        handle.interpolation.curr.quaternion.copy(pose.q);
        handle.interpolation.skip = true;
      },
      destroy: () => {
        if (handle.contactedHandles.size) {
          const cb = this.getContactCallback().init(false);
          for (const otherHandle of handle.contactedHandles) {
            if (otherHandle.onContactEnd) {
              cb.fn0 = otherHandle.onContactEnd;
              cb.event0.tag = handle.tag;
              cb.event0.playerId = handle.playerId;
              cb.exec();
            }
            otherHandle.contactedHandles.delete(handle);
          }
        }
        if (handle.triggeredHandles.size) {
          const cb = this.getTriggerCallback();
          for (const triggerHandle of handle.triggeredHandles) {
            if (triggerHandle.onTriggerLeave) {
              cb.fn = triggerHandle.onTriggerLeave;
              cb.event.tag = handle.tag;
              cb.event.playerId = handle.playerId;
              cb.exec();
            }
          }
        }
        if (!handle.controller) {
          this.scene.removeActor(actor);
        }
        this.handles.delete(actor.ptr);
      }
    };
  }
  preFixedUpdate(willFixedUpdate) {
    if (willFixedUpdate) {
      this.active.clear();
    }
  }
  postFixedUpdate(delta) {
    this.scene.simulate(delta);
    this.scene.fetchResults(true);
    this.processContactCallbacks();
    this.processTriggerCallbacks();
    const activeActors = PHYSX.SupportFunctions.prototype.PxScene_getActiveActors(this.scene);
    const size = activeActors.size();
    for (let i5 = 0; i5 < size; i5++) {
      const actorPtr = activeActors.get(i5).ptr;
      const handle = this.handles.get(actorPtr);
      if (!handle) {
        continue;
      }
      const lerp = handle.interpolation;
      if (!lerp) continue;
      lerp.prev.position.copy(lerp.next.position);
      lerp.prev.quaternion.copy(lerp.next.quaternion);
      const pose = handle.actor.getGlobalPose();
      lerp.next.position.copy(pose.p);
      lerp.next.quaternion.copy(pose.q);
      this.active.add(handle);
    }
  }
  preUpdate(alpha) {
    for (const handle of this.active) {
      const lerp = handle.interpolation;
      if (lerp.skip) {
        lerp.skip = false;
        continue;
      }
      lerp.curr.position.lerpVectors(lerp.prev.position, lerp.next.position, alpha);
      lerp.curr.quaternion.slerpQuaternions(lerp.prev.quaternion, lerp.next.quaternion, alpha);
      handle.onInterpolate(lerp.curr.position, lerp.curr.quaternion);
    }
    this.ignoreSetGlobalPose = true;
    this.world.stage.clean();
    this.ignoreSetGlobalPose = false;
  }
  raycast(origin, direction, maxDistance = Infinity, layerMask) {
    origin = origin.toPxVec3(this._pv1);
    direction = direction.toPxVec3(this._pv2);
    this.queryFilterData.data.word0 = layerMask;
    this.queryFilterData.data.word1 = 0;
    const didHit = this.scene.raycast(
      origin,
      direction,
      maxDistance,
      this.raycastResult,
      PHYSX.PxHitFlagEnum.eNORMAL,
      this.queryFilterData
    );
    if (didHit) {
      const numHits = this.raycastResult.getNbAnyHits();
      let hit;
      for (let n6 = 0; n6 < numHits; n6++) {
        const nHit = this.raycastResult.getAnyHit(n6);
        if (!hit || hit.distance > nHit.distance) {
          hit = nHit;
        }
      }
      _raycastHit.handle = this.handles.get(hit.actor.ptr);
      _raycastHit.point.set(hit.position.x, hit.position.y, hit.position.z);
      _raycastHit.normal.set(hit.normal.x, hit.normal.y, hit.normal.z);
      _raycastHit.distance = hit.distance;
      return _raycastHit;
    }
  }
  sweep(geometry, origin, direction, maxDistance, layerMask) {
    origin.toPxVec3(this.sweepPose.p);
    direction = direction.toPxVec3(this._pv2);
    this.queryFilterData.data.word0 = layerMask;
    this.queryFilterData.data.word1 = 0;
    const didHit = this.scene.sweep(
      geometry,
      this.sweepPose,
      direction,
      maxDistance,
      this.sweepResult,
      PHYSX.PxHitFlagEnum.eDEFAULT,
      this.queryFilterData
    );
    if (didHit) {
      const numHits = this.sweepResult.getNbAnyHits();
      let hit;
      for (let n6 = 0; n6 < numHits; n6++) {
        const nHit = this.sweepResult.getAnyHit(n6);
        if (!hit || hit.distance > nHit.distance) {
          hit = nHit;
        }
      }
      _sweepHit.actor = hit.actor;
      _sweepHit.point.set(hit.position.x, hit.position.y, hit.position.z);
      _sweepHit.normal.set(hit.normal.x, hit.normal.y, hit.normal.z);
      _sweepHit.distance = hit.distance;
      return _sweepHit;
    }
  }
  // overlap(geometry, origin, layerMask) {
  //   origin.toPxVec3(this.overlapPose.p)
  //   this.queryFilterData.data.word0 = layerMask
  //   this.queryFilterData.data.word1 = 0
  //   const didHit = this.scene.overlap(geometry, this.overlapPose, this.overlapResult, this.queryFilterData)
  //   if (didHit) {
  //     // const hit = this.overlapResult.getAnyHit(0)
  //     _overlapHit.actor = hit.actor
  //     return _overlapHit
  //   }
  //   // TODO: this.overlapResult.destroy() on this.destroy()
  // }
  overlapSphere(radius, origin, layerMask) {
    origin.toPxVec3(this.overlapPose.p);
    const geometry = getSphereGeometry(radius);
    this.queryFilterData.data.word0 = layerMask;
    this.queryFilterData.data.word1 = 0;
    const didHit = this.scene.overlap(geometry, this.overlapPose, this.overlapResult, this.queryFilterData);
    if (!didHit) return [];
    overlapHits.length = 0;
    const numHits = this.overlapResult.getNbAnyHits();
    for (let n6 = 0; n6 < numHits; n6++) {
      const nHit = this.overlapResult.getAnyHit(n6);
      const hit = getOrCreateOverlapHit(n6);
      hit.actor = nHit.actor;
      hit.handle = this.handles.get(nHit.actor.ptr);
      overlapHits.push(hit);
    }
    return overlapHits;
  }
  getMaterial(staticFriction, dynamicFriction, restitution) {
    const id = `${staticFriction}${dynamicFriction}${restitution}`;
    let material2 = this.materials[id];
    if (!material2) {
      material2 = this.physics.createMaterial(staticFriction, dynamicFriction, restitution);
      this.materials[id] = material2;
    }
    return material2;
  }
};
function createPool(factory) {
  const pool = [];
  return () => {
    if (pool.length) {
      return pool.pop();
    }
    const item = factory();
    item.release = () => pool.push(item);
    return item;
  };
}
var spheres2 = /* @__PURE__ */ new Map();
function getSphereGeometry(radius) {
  let sphere = spheres2.get(radius);
  if (!sphere) {
    sphere = new PHYSX.PxSphereGeometry(radius);
    spheres2.set(radius, sphere);
  }
  return sphere;
}
function getOrCreateOverlapHit(idx) {
  let hit = overlapHitPool[idx];
  if (!hit) {
    hit = {
      actor: null,
      handle: null,
      proxy: {
        get tag() {
          return hit.handle?.tag || null;
        },
        get playerId() {
          return hit.handle?.playerId || null;
        }
      }
    };
    overlapHitPool.push(hit);
  }
  return hit;
}

// src/core/systems/Stage.js
import { isNumber as isNumber20 } from "lodash-es";

// src/core/extras/LooseOctree.js
import { isBoolean as isBoolean15 } from "lodash-es";
var _v15 = new Vector3Enhanced();
var _v25 = new Vector3Enhanced();
var _q15 = new three_exports.Quaternion();
var _m13 = new three_exports.Matrix4();
var _intersects = [];
var _mesh = new three_exports.Mesh();
var MIN_RADIUS = 0.2;
var LooseOctree = class {
  constructor({ scene, center, size }) {
    this.scene = scene;
    this.root = new LooseOctreeNode(this, null, center, size);
    this.helper = null;
  }
  insert(item) {
    if (!item.sphere) item.sphere = new three_exports.Sphere();
    if (!item.geometry.boundingSphere) item.geometry.computeBoundingSphere();
    item.sphere.copy(item.geometry.boundingSphere).applyMatrix4(item.matrix);
    if (item.sphere.radius < MIN_RADIUS) item.sphere.radius = MIN_RADIUS;
    let added = this.root.insert(item);
    if (!added) {
      while (!this.root.canContain(item)) {
        this.expand();
      }
      added = this.root.insert(item);
    }
    return added;
  }
  move(item) {
    if (!item._node) {
      return;
    }
    item.sphere.copy(item.geometry.boundingSphere).applyMatrix4(item.matrix);
    if (item._node.canContain(item)) {
      return;
    }
    const prevNode = item._node;
    this.remove(item);
    const added = this.insert(item);
    if (!added) {
      console.error("octree item moved but was not re-added. did it move outside octree bounds?");
    }
    prevNode.checkCollapse();
  }
  remove(item) {
    item._node?.remove(item);
  }
  expand() {
    let prevRoot;
    let size;
    let center;
    prevRoot = this.root;
    size = prevRoot.size * 2;
    center = new Vector3Enhanced(
      prevRoot.center.x + prevRoot.size,
      prevRoot.center.y + prevRoot.size,
      prevRoot.center.z + prevRoot.size
    );
    const first = new LooseOctreeNode(this, null, center, size);
    first.subdivide();
    first.children[0].destroy();
    first.children[0] = prevRoot;
    prevRoot.parent = first;
    this.root = first;
    this.root.count = prevRoot.count;
    prevRoot = this.root;
    size = prevRoot.size * 2;
    center = new Vector3Enhanced(
      prevRoot.center.x - prevRoot.size,
      prevRoot.center.y - prevRoot.size,
      prevRoot.center.z - prevRoot.size
    );
    const second = new LooseOctreeNode(this, null, center, size);
    second.subdivide();
    second.children[7].destroy();
    second.children[7] = prevRoot;
    prevRoot.parent = second;
    this.root = second;
    this.root.count = prevRoot.count;
  }
  raycast(raycaster, intersects = []) {
    this.root.raycast(raycaster, intersects);
    intersects.sort(sortAscending);
    return intersects;
  }
  // spherecast(sphere, intersects = []) {
  //   // console.time('spherecast')
  //   this.root.spherecast(sphere, intersects)
  //   intersects.sort(sortAscending)
  //   // console.timeEnd('spherecast')
  //   // console.log('octree.spherecast', intersects)
  //   return intersects
  // }
  // prune() {
  //   console.time('prune')
  //   this.pruneCount = 0
  //   this.root.prune()
  //   console.timeEnd('prune')
  //   console.log('pruned:', this.pruneCount)
  // }
  toggleHelper(enabled) {
    enabled = isBoolean15(enabled) ? enabled : !this.helper;
    if (enabled && !this.helper) {
      this.helper = createHelper(this);
      this.helper.init();
    }
    if (!enabled && this.helper) {
      this.helper.destroy();
      this.helper = null;
    }
  }
  getDepth() {
    return this.root.getDepth();
  }
  getCount() {
    return this.root.getCount();
  }
};
var LooseOctreeNode = class _LooseOctreeNode {
  constructor(octree, parent, center, size) {
    this.octree = octree;
    this.parent = parent;
    this.center = center;
    this.size = size;
    this.inner = new three_exports.Box3(
      new Vector3Enhanced(center.x - size, center.y - size, center.z - size),
      new Vector3Enhanced(center.x + size, center.y + size, center.z + size)
    );
    this.outer = new three_exports.Box3(
      new Vector3Enhanced(center.x - size * 2, center.y - size * 2, center.z - size * 2),
      // prettier-ignore
      new Vector3Enhanced(center.x + size * 2, center.y + size * 2, center.z + size * 2)
      // prettier-ignore
    );
    this.items = [];
    this.count = 0;
    this.children = [];
    this.mountHelper();
  }
  insert(item) {
    if (!this.canContain(item)) {
      return false;
    }
    if (this.size / 2 < item.sphere.radius) {
      this.items.push(item);
      item._node = this;
      this.inc(1);
      return true;
    }
    if (!this.children.length) {
      this.subdivide();
    }
    for (const child of this.children) {
      if (child.insert(item)) {
        return true;
      }
    }
    console.error("octree insert fail");
    return false;
  }
  remove(item) {
    const idx = this.items.indexOf(item);
    this.items.splice(idx, 1);
    item._node = null;
    this.dec(1);
  }
  inc(amount) {
    let node = this;
    while (node) {
      node.count += amount;
      node = node.parent;
    }
  }
  dec(amount) {
    let node = this;
    while (node) {
      node.count -= amount;
      node = node.parent;
    }
  }
  canContain(item) {
    return this.size >= item.sphere.radius && this.inner.containsPoint(item.sphere.center);
  }
  checkCollapse() {
    let match;
    let node = this;
    while (node) {
      if (node.count) break;
      if (node.children.length) match = node;
      node = node.parent;
    }
    match?.collapse();
  }
  collapse() {
    for (const child of this.children) {
      child.collapse();
      child.destroy();
    }
    this.children = [];
  }
  subdivide() {
    if (this.children.length) return;
    const halfSize = this.size / 2;
    for (let x5 = 0; x5 < 2; x5++) {
      for (let y7 = 0; y7 < 2; y7++) {
        for (let z4 = 0; z4 < 2; z4++) {
          const center = new Vector3Enhanced(
            this.center.x + halfSize * (2 * x5 - 1),
            this.center.y + halfSize * (2 * y7 - 1),
            this.center.z + halfSize * (2 * z4 - 1)
          );
          const child = new _LooseOctreeNode(this.octree, this, center, halfSize);
          this.children.push(child);
        }
      }
    }
  }
  raycast(raycaster, intersects) {
    if (!raycaster.ray.intersectsBox(this.outer)) {
      return intersects;
    }
    for (const item of this.items) {
      if (raycaster.ray.intersectsSphere(item.sphere)) {
        _mesh.geometry = item.geometry;
        _mesh.material = item.material;
        _mesh.matrixWorld = item.matrix;
        _mesh.raycast(raycaster, _intersects);
        for (let i5 = 0, l5 = _intersects.length; i5 < l5; i5++) {
          const intersect = _intersects[i5];
          intersect.getEntity = item.getEntity;
          intersect.node = item.node;
          intersects.push(intersect);
        }
        _intersects.length = 0;
      }
    }
    for (const child of this.children) {
      child.raycast(raycaster, intersects);
    }
    return intersects;
  }
  // spherecast(sphere, intersects) {
  //   if (!sphere.intersectsBox(this.outer)) {
  //     return intersects
  //   }
  //   for (const item of this.items) {
  //     if (sphere.intersectsSphere(item.sphere)) {
  //       // just sphere-to-sphere is good enough for now
  //       const centerToCenterDistance = sphere.center.distanceTo(
  //         item.sphere.center
  //       )
  //       const overlapDistance =
  //         item.sphere.radius + sphere.radius - centerToCenterDistance
  //       const distance = Math.max(0, overlapDistance)
  //       const intersect = {
  //         distance: distance,
  //         point: null,
  //         object: null,
  //         getEntity: item.getEntity,
  //       }
  //       intersects.push(intersect)
  //       // _mesh.geometry = item.geometry
  //       // _mesh.material = item.material
  //       // _mesh.matrixWorld = item.matrix
  //       // _mesh.raycast(raycaster, _intersects)
  //       // for (let i = 0, l = _intersects.length; i < l; i++) {
  //       //   const intersect = _intersects[i]
  //       //   intersect.getEntity = item.getEntity
  //       //   intersects.push(intersect)
  //       // }
  //       // _intersects.length = 0
  //     }
  //   }
  //   for (const child of this.children) {
  //     child.spherecast(sphere, intersects)
  //   }
  //   return intersects
  // }
  // prune() {
  //   let empty = true
  //   for (const child of this.children) {
  //     const canPrune = !child.items.length && child.prune()
  //     if (!canPrune) {
  //       empty = false
  //     }
  //   }
  //   if (empty) {
  //     for (const child of this.children) {
  //       this.octree.helper?.remove(child)
  //     }
  //     this.children.length = 0
  //     this.octree.pruneCount++
  //   }
  //   return empty
  // }
  getDepth() {
    if (this.children.length === 0) {
      return 1;
    }
    return 1 + Math.max(...this.children.map((child) => child.getDepth()));
  }
  getCount() {
    let count = 1;
    for (const child of this.children) {
      count += child.getCount();
    }
    return count;
  }
  mountHelper() {
    this.octree.helper?.insert(this);
  }
  unmountHelper() {
    this.octree.helper?.remove(this);
  }
  destroy() {
    this.unmountHelper();
  }
};
function sortAscending(a5, b6) {
  return a5.distance - b6.distance;
}
function createHelper(octree) {
  const boxes2 = new three_exports.BoxGeometry(1, 1, 1);
  const edges = new three_exports.EdgesGeometry(boxes2);
  const geometry = new three_exports.InstancedBufferGeometry().copy(edges);
  const iMatrix = new three_exports.InstancedBufferAttribute(new Float32Array(1e6 * 16), 16);
  iMatrix.setUsage(three_exports.DynamicDrawUsage);
  geometry.setAttribute("iMatrix", iMatrix);
  const offset = new three_exports.InstancedBufferAttribute(new Float32Array(1e5 * 3), 3);
  geometry.setAttribute("offset", offset);
  const scale = new three_exports.InstancedBufferAttribute(new Float32Array(1e5 * 3), 3);
  geometry.setAttribute("scale", scale);
  geometry.instanceCount = 0;
  const material2 = new three_exports.LineBasicMaterial({
    color: "red",
    onBeforeCompile: (shader) => {
      shader.vertexShader = shader.vertexShader.replace(
        "#include <common>",
        `
        attribute mat4 iMatrix;
        #include <common>
        `
      );
      shader.vertexShader = shader.vertexShader.replace(
        "#include <begin_vertex>",
        `
        #include <begin_vertex>
        transformed = (iMatrix * vec4(position, 1.0)).xyz;
        `
      );
    }
  });
  const mesh = new three_exports.LineSegments(geometry, material2);
  mesh.frustumCulled = false;
  const items = [];
  function insert(node) {
    const idx = mesh.geometry.instanceCount;
    mesh.geometry.instanceCount++;
    const position = _v15.copy(node.center);
    const quaternion = _q15.set(0, 0, 0, 1);
    const scale2 = _v25.setScalar(node.size * 2);
    const matrix = new three_exports.Matrix4().compose(position, quaternion, scale2);
    iMatrix.set(matrix.elements, idx * 16);
    iMatrix.needsUpdate = true;
    node._helperItem = { idx, matrix };
    items.push(node._helperItem);
  }
  function remove(node) {
    const item = node._helperItem;
    const last = items[items.length - 1];
    const isOnly = items.length === 1;
    const isLast = item === last;
    if (isOnly) {
      items.length = 0;
      mesh.geometry.instanceCount = 0;
    } else if (isLast) {
      items.pop();
      mesh.geometry.instanceCount--;
    } else {
      if (!last) {
        console.log(
          "wtf",
          item,
          items.indexOf(item),
          last,
          items.length,
          // items[items.length - 1]
          mesh.geometry.instanceCount,
          items
        );
        throw new Error("wtf");
      }
      iMatrix.set(last.matrix.elements, item.idx * 16);
      last.idx = item.idx;
      items[item.idx] = last;
      items.pop();
      mesh.geometry.instanceCount--;
    }
    iMatrix.needsUpdate = true;
  }
  function traverse(node, callback) {
    callback(node);
    for (const child of node.children) {
      traverse(child, callback);
    }
  }
  function destroy() {
    octree.scene.remove(mesh);
  }
  function init() {
    traverse(octree.root, (node) => {
      node.mountHelper();
    });
  }
  octree.scene.add(mesh);
  return {
    init,
    insert,
    remove,
    destroy
  };
}

// src/core/systems/Stage.js
var vec2 = new three_exports.Vector2();
var Stage = class extends System {
  constructor(world2) {
    super(world2);
    this.scene = new three_exports.Scene();
    this.models = /* @__PURE__ */ new Map();
    this.octree = new LooseOctree({
      scene: this.scene,
      center: new Vector3Enhanced(0, 0, 0),
      size: 10
    });
    this.defaultMaterial = null;
    this.raycaster = new three_exports.Raycaster();
    this.raycaster.firstHitOnly = true;
    this.raycastHits = [];
    this.maskNone = new three_exports.Layers();
    this.maskNone.enableAll();
    this.dirtyNodes = /* @__PURE__ */ new Set();
  }
  init({ viewport }) {
    this.viewport = viewport;
    this.scene.add(this.world.rig);
  }
  update(delta) {
    this.models.forEach((model) => model.clean());
  }
  postUpdate() {
    this.clean();
  }
  postLateUpdate() {
    this.clean();
  }
  getDefaultMaterial() {
    if (!this.defaultMaterial) {
      this.defaultMaterial = this.createMaterial();
    }
    return this.defaultMaterial;
  }
  clean() {
    for (const node of this.dirtyNodes) {
      node.clean();
    }
    this.dirtyNodes.clear();
  }
  insert(options) {
    if (options.linked) {
      return this.insertLinked(options);
    } else {
      return this.insertSingle(options);
    }
  }
  insertLinked({ geometry, material: material2, castShadow, receiveShadow, node, matrix }) {
    const id = `${geometry.uuid}/${material2.uuid}/${castShadow}/${receiveShadow}`;
    if (!this.models.has(id)) {
      const model = new Model(this, geometry, material2, castShadow, receiveShadow);
      this.models.set(id, model);
    }
    return this.models.get(id).create(node, matrix);
  }
  insertSingle({ geometry, material: material2, castShadow, receiveShadow, node, matrix }) {
    material2 = this.createMaterial({ raw: material2 });
    const mesh = new three_exports.Mesh(geometry, material2.raw);
    mesh.castShadow = castShadow;
    mesh.receiveShadow = receiveShadow;
    mesh.matrixWorld.copy(matrix);
    mesh.matrixAutoUpdate = false;
    mesh.matrixWorldAutoUpdate = false;
    const sItem = {
      matrix,
      geometry,
      material: material2.raw,
      getEntity: () => node.ctx.entity,
      node
    };
    this.scene.add(mesh);
    this.octree.insert(sItem);
    return {
      material: material2.proxy,
      move: (matrix2) => {
        mesh.matrixWorld.copy(matrix2);
        this.octree.move(sItem);
      },
      destroy: () => {
        this.scene.remove(mesh);
        this.octree.remove(sItem);
      }
    };
  }
  createMaterial(options = {}) {
    const self2 = this;
    const material2 = {};
    let raw;
    if (options.raw) {
      raw = options.raw.clone();
      raw.onBeforeCompile = options.raw.onBeforeCompile;
    } else if (options.unlit) {
      raw = new three_exports.MeshBasicMaterial({
        color: options.color || "white"
      });
    } else {
      raw = new three_exports.MeshStandardMaterial({
        color: options.color || "white",
        metalness: isNumber20(options.metalness) ? options.metalness : 0,
        roughness: isNumber20(options.roughness) ? options.roughness : 1
      });
    }
    raw.shadowSide = three_exports.BackSide;
    const textures = [];
    if (raw.map) {
      raw.map = raw.map.clone();
      textures.push(raw.map);
    }
    if (raw.emissiveMap) {
      raw.emissiveMap = raw.emissiveMap.clone();
      textures.push(raw.emissiveMap);
    }
    if (raw.normalMap) {
      raw.normalMap = raw.normalMap.clone();
      textures.push(raw.normalMap);
    }
    if (raw.bumpMap) {
      raw.bumpMap = raw.bumpMap.clone();
      textures.push(raw.bumpMap);
    }
    if (raw.roughnessMap) {
      raw.roughnessMap = raw.roughnessMap.clone();
      textures.push(raw.roughnessMap);
    }
    if (raw.metalnessMap) {
      raw.metalnessMap = raw.metalnessMap.clone();
      textures.push(raw.metalnessMap);
    }
    this.world.setupMaterial(raw);
    const proxy = {
      get id() {
        return raw.uuid;
      },
      get textureX() {
        return textures[0]?.offset.x;
      },
      set textureX(val) {
        for (const tex of textures) {
          tex.offset.x = val;
        }
        raw.needsUpdate = true;
      },
      get textureY() {
        return textures[0]?.offset.y;
      },
      set textureY(val) {
        for (const tex of textures) {
          tex.offset.y = val;
        }
        raw.needsUpdate = true;
      },
      get color() {
        return raw.color;
      },
      set color(val) {
        if (typeof val !== "string") {
          throw new Error('[material] color must be a string (e.g. "red", "#ff0000", "rgb(255,0,0)")');
        }
        raw.color.set(val);
        raw.needsUpdate = true;
      },
      get emissiveIntensity() {
        return raw.emissiveIntensity;
      },
      set emissiveIntensity(value) {
        if (!isNumber20(value)) {
          throw new Error("[material] emissiveIntensity not a number");
        }
        raw.emissiveIntensity = value;
        raw.needsUpdate = true;
      },
      get fog() {
        return raw.fog;
      },
      set fog(value) {
        raw.fog = value;
        raw.needsUpdate = true;
      },
      // TODO: not yet
      // clone() {
      //   return self.createMaterial(options).proxy
      // },
      get _ref() {
        if (world._allowMaterial) return material2;
      }
    };
    material2.raw = raw;
    material2.proxy = proxy;
    return material2;
  }
  raycastPointer(position, layers3 = this.maskNone, min = 0, max = Infinity) {
    if (!this.viewport) throw new Error("no viewport");
    const rect = this.viewport.getBoundingClientRect();
    vec2.x = (position.x - rect.left) / rect.width * 2 - 1;
    vec2.y = -((position.y - rect.top) / rect.height) * 2 + 1;
    this.raycaster.setFromCamera(vec2, this.world.camera);
    this.raycaster.layers = layers3;
    this.raycaster.near = min;
    this.raycaster.far = max;
    this.raycastHits.length = 0;
    this.octree.raycast(this.raycaster, this.raycastHits);
    return this.raycastHits;
  }
  raycastReticle(layers3 = this.maskNone, min = 0, max = Infinity) {
    if (!this.viewport) throw new Error("no viewport");
    vec2.x = 0;
    vec2.y = 0;
    this.raycaster.setFromCamera(vec2, this.world.camera);
    this.raycaster.layers = layers3;
    this.raycaster.near = min;
    this.raycaster.far = max;
    this.raycastHits.length = 0;
    this.octree.raycast(this.raycaster, this.raycastHits);
    return this.raycastHits;
  }
};
var Model = class {
  constructor(stage, geometry, material2, castShadow, receiveShadow) {
    material2 = stage.createMaterial({ raw: material2 });
    this.stage = stage;
    this.geometry = geometry;
    this.material = material2;
    this.castShadow = castShadow;
    this.receiveShadow = receiveShadow;
    if (!this.geometry.boundsTree) this.geometry.computeBoundsTree();
    this.iMesh = new three_exports.InstancedMesh(this.geometry, this.material.raw, 10);
    this.iMesh.castShadow = this.castShadow;
    this.iMesh.receiveShadow = this.receiveShadow;
    this.iMesh.matrixAutoUpdate = false;
    this.iMesh.matrixWorldAutoUpdate = false;
    this.iMesh.frustumCulled = false;
    this.iMesh.getEntity = this.getEntity.bind(this);
    this.items = [];
    this.dirty = true;
  }
  create(node, matrix) {
    const item = {
      idx: this.items.length,
      node,
      matrix
      // octree
    };
    this.items.push(item);
    this.iMesh.setMatrixAt(item.idx, item.matrix);
    this.dirty = true;
    const sItem = {
      matrix,
      geometry: this.geometry,
      material: this.material.raw,
      getEntity: () => this.items[item.idx]?.node.ctx.entity,
      node
    };
    this.stage.octree.insert(sItem);
    return {
      material: this.material.proxy,
      move: (matrix2) => {
        this.move(item, matrix2);
        this.stage.octree.move(sItem);
      },
      destroy: () => {
        this.destroy(item);
        this.stage.octree.remove(sItem);
      }
    };
  }
  move(item, matrix) {
    item.matrix.copy(matrix);
    this.iMesh.setMatrixAt(item.idx, matrix);
    this.dirty = true;
  }
  destroy(item) {
    const last = this.items[this.items.length - 1];
    const isOnly = this.items.length === 1;
    const isLast = item === last;
    if (isOnly) {
      this.items = [];
      this.dirty = true;
    } else if (isLast) {
      this.items.pop();
      this.dirty = true;
    } else {
      this.iMesh.setMatrixAt(item.idx, last.matrix);
      last.idx = item.idx;
      this.items[item.idx] = last;
      this.items.pop();
      this.dirty = true;
    }
  }
  clean() {
    if (!this.dirty) return;
    const size = this.iMesh.instanceMatrix.array.length / 16;
    const count = this.items.length;
    if (size < this.items.length) {
      const newSize = count + 100;
      this.iMesh.resize(newSize);
      for (let i5 = size; i5 < count; i5++) {
        this.iMesh.setMatrixAt(i5, this.items[i5].matrix);
      }
    }
    this.iMesh.count = count;
    if (this.iMesh.parent && !count) {
      this.stage.scene.remove(this.iMesh);
      this.dirty = false;
      return;
    }
    if (!this.iMesh.parent && count) {
      this.stage.scene.add(this.iMesh);
    }
    this.iMesh.instanceMatrix.needsUpdate = true;
    this.dirty = false;
  }
  getEntity(instanceId) {
    console.warn("TODO: remove if you dont ever see this");
    return this.items[instanceId]?.node.ctx.entity;
  }
  getTriangles() {
    const geometry = this.geometry;
    if (geometry.index !== null) {
      return geometry.index.count / 3;
    } else {
      return geometry.attributes.position.count / 3;
    }
  }
};

// src/core/extras/Curve.js
var ids = 0;
var arr1 = [];
var Curve = class _Curve {
  constructor() {
    this.keyframes = [];
  }
  deserialize(data) {
    if (!data) return this;
    this.data = data;
    this.keyframes = data.split("|").map((kData) => {
      return new Keyframe().deserialize(kData);
    });
    this.sort();
    return this;
  }
  serialize() {
    return this.keyframes.map((keyframe) => {
      return keyframe.serialize();
    }).join("|");
  }
  add(opts) {
    const keyframe = new Keyframe().set(opts);
    const foundIndex = this.keyframes.findIndex((k5) => k5.time === keyframe.time);
    if (foundIndex === -1) {
      this.keyframes.push(keyframe);
    } else {
      this.keyframes[foundIndex] = keyframe;
    }
    this.sort();
    return this;
  }
  remove(keyframeId) {
    const idx = this.keyframes.findIndex((keyframe) => keyframe.id === keyframeId);
    if (idx !== -1) this.keyframes.splice(idx, 1);
  }
  removeAtTime(time) {
    const idx = this.keyframes.findIndex((keyframe) => keyframe.time === time);
    if (idx !== -1) this.keyframes.splice(idx, 1);
  }
  getClosest(t6) {
    t6 = Math.max(0, Math.min(1, t6));
    let lo = -1;
    let hi = this.keyframes.length;
    while (hi - lo > 1) {
      let mid = Math.round((lo + hi) / 2);
      if (this.keyframes[mid].time <= t6) lo = mid;
      else hi = mid;
    }
    if (this.keyframes[lo].time === t6) hi = lo;
    if (lo === hi) {
      if (lo === 0) hi++;
      else lo--;
    }
    arr1[0] = lo;
    arr1[1] = hi;
    return arr1;
  }
  evaluate(time) {
    if (time <= this.keyframes[0].time) {
      return this.keyframes[0].value;
    }
    if (time >= this.keyframes[this.keyframes.length - 1].time) {
      return this.keyframes[this.keyframes.length - 1].value;
    }
    for (let i5 = 0; i5 < this.keyframes.length - 1; i5++) {
      if (time >= this.keyframes[i5].time && time <= this.keyframes[i5 + 1].time) {
        const t6 = (time - this.keyframes[i5].time) / (this.keyframes[i5 + 1].time - this.keyframes[i5].time);
        const p0 = this.keyframes[i5].value;
        const p1 = this.keyframes[i5 + 1].value;
        const m0 = this.keyframes[i5].outTangent * (this.keyframes[i5 + 1].time - this.keyframes[i5].time);
        const m14 = this.keyframes[i5 + 1].inTangent * (this.keyframes[i5 + 1].time - this.keyframes[i5].time);
        const t22 = t6 * t6;
        const t32 = t22 * t6;
        const h00 = 2 * t32 - 3 * t22 + 1;
        const h10 = t32 - 2 * t22 + t6;
        const h01 = -2 * t32 + 3 * t22;
        const h11 = t32 - t22;
        return h00 * p0 + h10 * m0 + h01 * p1 + h11 * m14;
      }
    }
  }
  // evaluate(time) {
  //   if (time <= this.keyframes[0].time) {
  //     return this.keyframes[0].value
  //   }
  //   if (time >= this.keyframes[this.keyframes.length - 1].time) {
  //     return this.keyframes[this.keyframes.length - 1].value
  //   }
  //   for (let i = 0; i < this.keyframes.length - 1; i++) {
  //     // prettier-ignore
  //     if (time >= this.keyframes[i].time && time <= this.keyframes[i + 1].time) {
  //       const t = (time - this.keyframes[i].time) / (this.keyframes[i + 1].time - this.keyframes[i].time) // prettier-ignore
  //       const p0 = this.keyframes[i].value
  //       const p1 = this.keyframes[i + 1].value
  //       const m0 = this.keyframes[i].outMagnitude * (this.keyframes[i + 1].time - this.keyframes[i].time) // prettier-ignore
  //       const m1 = this.keyframes[i + 1].inMagnitude * (this.keyframes[i + 1].time - this.keyframes[i].time) // prettier-ignore
  //       const t2 = t * t
  //       const t3 = t2 * t
  //       const a = 2 * t3 - 3 * t2 + 1
  //       const b = t3 - 2 * t2 + t
  //       const c = -2 * t3 + 3 * t2
  //       const d = t3 - t2
  //       return a * p0 + b * m0 + c * p1 + d * m1
  //     }
  //   }
  // }
  //   evaluate(t) {
  //     const keyframes = this.keyframes
  //     const n = keyframes.length
  //     const lo = this.getClosest(t)[0]
  //     let i0 = lo
  //     let i1 = i0 + 1
  //     if (i0 > n - 1) throw new Error('Out of bounds')
  //     if (i0 === n - 1) i1 = i0
  //     let scale = keyframes[i1].time - keyframes[i0].time
  //     t = (t - keyframes[i0].time) / scale
  //     let t2 = t * t
  //     let it = 1 - t
  //     let it2 = it * it
  //     let tt = 2 * t
  //     let h00 = (1 + tt) * it2
  //     let h10 = t * it2
  //     let h01 = t2 * (3 - tt)
  //     let h11 = t2 * (t - 1)
  //     const x =
  //       h00 * keyframes[i0].time +
  //       h10 * keyframes[i0].outTangent * scale +
  //       h01 * keyframes[i1].time +
  //       h11 * keyframes[i1].inTangent * scale
  //     const y =
  //       h00 * keyframes[i0].value +
  //       h10 * keyframes[i0].outTangent * scale +
  //       h01 * keyframes[i1].value +
  //       h11 * keyframes[i1].inTangent * scale
  //     return y
  //   }
  ogEvaluate(t6) {
    return this.hermite(t6, this.keyframes).y;
  }
  hermite(t6, keyframes) {
    const n6 = keyframes.length;
    const [lo, hi] = this.getClosest(t6);
    var i0 = lo;
    var i1 = i0 + 1;
    if (i0 > n6 - 1) throw new Error("Out of bounds");
    if (i0 === n6 - 1) i1 = i0;
    var scale = keyframes[i1].time - keyframes[i0].time;
    t6 = (t6 - keyframes[i0].time) / scale;
    var t22 = t6 * t6;
    var it = 1 - t6;
    var it2 = it * it;
    var tt2 = 2 * t6;
    var h00 = (1 + tt2) * it2;
    var h10 = t6 * it2;
    var h01 = t22 * (3 - tt2);
    var h11 = t22 * (t6 - 1);
    const x5 = h00 * keyframes[i0].time + h10 * keyframes[i0].outTangent * scale + h01 * keyframes[i1].time + h11 * keyframes[i1].inTangent * scale;
    const y7 = h00 * keyframes[i0].value + h10 * keyframes[i0].outTangent * scale + h01 * keyframes[i1].value + h11 * keyframes[i1].inTangent * scale;
    return { x: x5, y: y7 };
  }
  sort() {
    this.keyframes.sort((a5, b6) => a5.time - b6.time);
    this.firstKeyframe = this.keyframes[0];
    this.lastKeyframe = this.keyframes[this.keyframes.length - 1];
  }
  move(keyframe, time, value, boundFirstLast) {
    const keyIndex = this.keyframes.indexOf(keyframe);
    if (keyIndex <= 0 || keyIndex >= this.keyframes.length - 1) {
      if (!boundFirstLast) {
        keyframe.value = value;
      }
      return;
    }
    keyframe.value = value;
    keyframe.time = Math.max(1e-3, Math.min(time, 0.999));
    this.sort();
  }
  clone() {
    return new _Curve().deserialize(this.serialize());
  }
};
var Keyframe = class {
  constructor() {
    this.id = ++ids;
    this.time = 0;
    this.value = 0;
    this.inTangent = 0;
    this.outTangent = 0;
    this.inMagnitude = -0.1;
    this.outMagnitude = 0.1;
  }
  set({ time, value, inTangent, outTangent }) {
    this.time = clamp(time, 0, 1);
    this.value = value || 0;
    this.inTangent = inTangent || 0;
    this.outTangent = outTangent || 0;
    return this;
  }
  deserialize(data) {
    const [time, value, inTangent, outTangent] = data.split(",");
    this.time = parseFloat(time) || 0;
    this.value = parseFloat(value) || 0;
    this.inTangent = parseFloat(inTangent) || 0;
    this.outTangent = parseFloat(outTangent) || 0;
    this.id = ++ids;
    this.inMagnitude = -0.1;
    this.outMagnitude = 0.1;
    return this;
  }
  serialize() {
    return [
      numToString(this.time),
      numToString(this.value),
      numToString(this.inTangent),
      numToString(this.outTangent)
    ].join(",");
  }
  getHandles() {
    return { in: this.getInHandle(), out: this.getOutHandle() };
  }
  getInHandle() {
    return {
      x: this.time + this.inMagnitude,
      y: this.value + this.inMagnitude * this.inTangent
    };
  }
  getOutHandle() {
    return {
      x: this.time + this.outMagnitude,
      y: this.value + this.outMagnitude * this.outTangent
    };
  }
  setTangentsFromHandles(tangents) {
    this.setInTangentFromHandle(tangents.in.x, tangents.in.y);
    this.setOutTangentFromHandle(tangents.out.x, tangents.out.y);
  }
  setInTangentFromHandle(x5, y7) {
    if (x5 >= this.time) return;
    this.inMagnitude = x5 - this.time;
    this.inTangent = (y7 - this.value) / this.inMagnitude;
  }
  setOutTangentFromHandle(x5, y7) {
    if (x5 <= this.time) return;
    this.outMagnitude = x5 - this.time;
    this.outTangent = (y7 - this.value) / this.outMagnitude;
  }
};
function numToString(num2) {
  if (Number.isInteger(num2)) return num2.toString();
  return num2.toFixed(3);
}

// src/core/extras/prng.js
var DEFAULT_SEED = 14930496103936265e4;
var REGISTER_LENGTH = 31;
var FLUSH_TIMES = 20;
function prng(seed) {
  const generator = new PRNG(seed);
  return (min, max, dp = 0) => {
    if (max === void 0) {
      max = min;
      min = 0;
    }
    if (min > max) [min, max] = [max, min];
    if (dp > 0) {
      const scale = 10 ** dp;
      const intMin = Math.ceil(min * scale);
      const intMax = Math.floor(max * scale);
      const rndInt = generator.rand(intMin, intMax);
      return rndInt / scale;
    }
    return generator.rand(min, max);
  };
}
var PRNG = class {
  constructor(seed) {
    this.lfsr = new LFSR(REGISTER_LENGTH, seed || DEFAULT_SEED);
    this.lfsr.seq(FLUSH_TIMES * REGISTER_LENGTH);
  }
  rand(min, max) {
    if (!max) {
      max = min;
      min = 0;
    }
    if (min > max) {
      let t6 = max;
      max = min;
      min = t6;
    }
    let offset = min;
    let bits = ~~this._log2(max - offset) + 1;
    let random;
    do {
      random = this.lfsr.seq(bits);
    } while (random > max - offset);
    return random + offset;
  }
  _log2(n6) {
    return Math.log(n6) / Math.LN2;
  }
};
var TAPS = {
  2: [2, 1],
  // 3
  3: [3, 2],
  // 7
  4: [4, 3],
  // 15
  5: [5, 3],
  // 31
  6: [6, 5],
  // 63
  7: [7, 6],
  // 127
  8: [8, 6, 5, 4],
  // 255
  9: [9, 5],
  // 511
  10: [10, 7],
  // 1023
  11: [11, 9],
  // 2027
  12: [12, 11, 10, 4],
  // 4095
  13: [13, 12, 11, 8],
  // 8191
  14: [14, 13, 12, 2],
  // 16383
  15: [15, 14],
  // 32767
  16: [16, 14, 13, 11],
  // 65535
  17: [17, 14],
  // 131071
  18: [18, 11],
  // 262143
  19: [19, 18, 17, 14],
  // 524287
  20: [20, 17],
  21: [21, 19],
  22: [22, 21],
  23: [23, 18],
  24: [24, 23, 22, 17],
  25: [25, 22],
  26: [26, 6, 2, 1],
  27: [27, 5, 2, 1],
  28: [28, 25],
  29: [29, 27],
  30: [30, 6, 4, 1],
  31: [31, 28]
  // Out of javascript integer range
  // 32: [32, 22, 2, 1],
  // 33: [33, 20],
  // 34: [34, 27, 2, 1],
  // 35: [35, 33],
  // 36: [36, 25],
  // 37: [37, 5, 4, 3, 2, 1],
  // 38: [38, 6, 5, 1],
  // 39: [39, 35],
  // 40: [40, 38, 21, 19],
  // 41: [41, 38],
  // 42: [42, 41, 20, 19],
  // 43: [43, 42, 38, 37],
  // 44: [44, 43, 18, 17],
  // 45: [45, 44, 42, 41],
  // 46: [46, 45, 26, 25],
  // 47: [47, 42],
  // 48: [48, 47, 21, 20],
  // 49: [49, 40],
  // 50: [50, 49, 24, 23],
  // 51: [51, 50, 36, 35],
  // 52: [52, 49],
  // 53: [53, 52, 38, 37],
  // 54: [54, 53, 18, 17],
  // 55: [55, 31],
  // 56: [56, 55, 35, 34],
  // 57: [57, 50],
  // 58: [58, 39],
  // 59: [59, 58, 38, 37],
  // 60: [60, 59],
  // 61: [61, 60, 46, 45],
  // 62: [62, 61, 6, 5],
  // 63: [63, 62],
  // 64: [64, 63, 61, 60]
};
var DEFAULT_LENGTH = 31;
var LFSR = class _LFSR {
  constructor(n6, seed) {
    this.n = n6 || DEFAULT_LENGTH;
    this.taps = TAPS[this.n];
    seed = seed || this._defaultSeed(this.n);
    const mask = parseInt(Array(this.n + 1).join("1"), 2);
    this.register = seed & mask;
  }
  shift() {
    let tapsNum = this.taps.length;
    let i5;
    let bit = this.register >> this.n - this.taps[0];
    for (let i6 = 1; i6 < tapsNum; i6++) {
      bit = bit ^ this.register >> this.n - this.taps[i6];
    }
    bit = bit & 1;
    this.register = this.register >> 1 | bit << this.n - 1;
    return bit & 1;
  }
  seq(n6) {
    let seq = 0;
    for (let i5 = 0; i5 < n6; i5++) {
      seq = seq << 1 | this.shift();
    }
    return seq;
  }
  seqString(n6) {
    let seq = "";
    for (let i5 = 0; i5 < n6; i5++) {
      seq += this.shift();
    }
    return seq;
  }
  maxSeqLen() {
    let initialState = this.register;
    let counter = 0;
    do {
      this.shift();
      counter++;
    } while (initialState != this.register);
    return counter;
  }
  _defaultSeed(n6) {
    if (!n6) throw new Error("n is required");
    let lfsr = new _LFSR(8, 92914);
    return lfsr.seq(n6);
  }
};

// src/core/systems/Scripts.js
var Scripts = class extends System {
  constructor(world2) {
    super(world2);
    this.compartment = new Compartment({
      console: {
        log: (...args) => console.log(...args),
        warn: (...args) => console.warn(...args),
        error: (...args) => console.error(...args),
        time: (...args) => console.time(...args),
        timeEnd: (...args) => console.timeEnd(...args)
      },
      Date: {
        now: () => Date.now()
      },
      URL: {
        createObjectURL: (blob) => URL.createObjectURL(blob)
      },
      Math,
      eval: void 0,
      harden: void 0,
      lockdown: void 0,
      num,
      prng,
      clamp,
      // Layers,
      Object3D: three_exports.Object3D,
      Quaternion: three_exports.Quaternion,
      Vector3: Vector3Enhanced,
      Euler: three_exports.Euler,
      Matrix4: three_exports.Matrix4,
      LerpVector3,
      LerpQuaternion,
      // Material: Material,
      Curve,
      // Gradient: Gradient,
      DEG2RAD,
      RAD2DEG,
      uuid
      // pause: () => this.world.pause(),
    });
  }
  evaluate(code) {
    let value;
    const result = {
      exec: (...args) => {
        if (!value) value = this.compartment.evaluate(wrapRawCode(code));
        return value(...args);
      },
      code
    };
    return result;
  }
};
function wrapRawCode(code) {
  return `
  (function() {
    const shared = {}
    return (world, app, fetch, props, setTimeout) => {
      const config = props // deprecated
      ${code}
    }
  })()
  `;
}

// src/core/World.js
var World = class extends EventEmitter2 {
  constructor() {
    super();
    this.maxDeltaTime = 1 / 30;
    this.fixedDeltaTime = 1 / 50;
    this.frame = 0;
    this.time = 0;
    this.accumulator = 0;
    this.systems = [];
    this.networkRate = 1 / 8;
    this.assetsUrl = null;
    this.hot = /* @__PURE__ */ new Set();
    this.rig = new three_exports.Object3D();
    this.camera = new three_exports.PerspectiveCamera(70, 0, 0.2, 1200);
    this.rig.add(this.camera);
    this.register("settings", Settings);
    this.register("collections", Collections);
    this.register("apps", Apps);
    this.register("anchors", Anchors);
    this.register("events", Events);
    this.register("scripts", Scripts);
    this.register("chat", Chat);
    this.register("blueprints", Blueprints);
    this.register("entities", Entities);
    this.register("physics", Physics);
    this.register("stage", Stage);
  }
  register(key, System2) {
    const system = new System2(this);
    this.systems.push(system);
    this[key] = system;
    return system;
  }
  async init(options) {
    this.storage = options.storage;
    for (const system of this.systems) {
      await system.init(options);
    }
    this.start();
  }
  start() {
    for (const system of this.systems) {
      system.start();
    }
  }
  tick = (time) => {
    this.preTick();
    time /= 1e3;
    let delta = time - this.time;
    if (delta < 0) delta = 0;
    if (delta > this.maxDeltaTime) {
      delta = this.maxDeltaTime;
    }
    this.frame++;
    this.time = time;
    this.accumulator += delta;
    const willFixedStep = this.accumulator >= this.fixedDeltaTime;
    this.preFixedUpdate(willFixedStep);
    while (this.accumulator >= this.fixedDeltaTime) {
      this.fixedUpdate(this.fixedDeltaTime);
      this.postFixedUpdate(this.fixedDeltaTime);
      this.accumulator -= this.fixedDeltaTime;
    }
    const alpha = this.accumulator / this.fixedDeltaTime;
    this.preUpdate(alpha);
    this.update(delta, alpha);
    this.postUpdate(delta);
    this.lateUpdate(delta, alpha);
    this.postLateUpdate(delta);
    this.commit();
    this.postTick();
  };
  preTick() {
    for (const system of this.systems) {
      system.preTick();
    }
  }
  preFixedUpdate(willFixedStep) {
    for (const system of this.systems) {
      system.preFixedUpdate(willFixedStep);
    }
  }
  fixedUpdate(delta) {
    for (const item of this.hot) {
      item.fixedUpdate?.(delta);
    }
    for (const system of this.systems) {
      system.fixedUpdate(delta);
    }
  }
  postFixedUpdate(delta) {
    for (const system of this.systems) {
      system.postFixedUpdate(delta);
    }
  }
  preUpdate(alpha) {
    for (const system of this.systems) {
      system.preUpdate(alpha);
    }
  }
  update(delta) {
    for (const item of this.hot) {
      item.update?.(delta);
    }
    for (const system of this.systems) {
      system.update(delta);
    }
  }
  postUpdate(delta) {
    for (const system of this.systems) {
      system.postUpdate(delta);
    }
  }
  lateUpdate(delta) {
    for (const item of this.hot) {
      item.lateUpdate?.(delta);
    }
    for (const system of this.systems) {
      system.lateUpdate(delta);
    }
  }
  postLateUpdate(delta) {
    for (const item of this.hot) {
      item.postLateUpdate?.(delta);
    }
    for (const system of this.systems) {
      system.postLateUpdate(delta);
    }
  }
  commit() {
    for (const system of this.systems) {
      system.commit();
    }
  }
  postTick() {
    for (const system of this.systems) {
      system.postTick();
    }
  }
  setupMaterial = (material2) => {
    this.environment.csm?.setupMaterial(material2);
  };
  setHot(item, hot) {
    if (hot) {
      this.hot.add(item);
    } else {
      this.hot.delete(item);
    }
  }
  resolveURL(url) {
    if (!url) return url;
    url = url.trim();
    if (url.startsWith("blob")) {
      return url;
    }
    if (url.startsWith("asset://")) {
      if (!this.assetsUrl) console.error("resolveURL: no assetsUrl defined");
      return url.replace("asset:/", this.assetsUrl);
    }
    if (url.match(/^https?:\/\//i)) {
      return url;
    }
    if (url.startsWith("//")) {
      return `https:${url}`;
    }
    if (url.startsWith("/")) {
      return url;
    }
    return `https://${url}`;
  }
  inject(runtime) {
    this.apps.inject(runtime);
  }
  destroy() {
    for (const system of this.systems) {
      system.destroy();
    }
  }
};

// src/core/systems/ClientNetwork.js
import moment3 from "moment";

// src/core/packets.js
import { Packr } from "msgpackr";
var packr = new Packr({ structuredClone: true });
var names = [
  "snapshot",
  "command",
  "chatAdded",
  "chatCleared",
  "blueprintAdded",
  "blueprintModified",
  "entityAdded",
  "entityModified",
  "entityEvent",
  "entityRemoved",
  "playerTeleport",
  "playerPush",
  "playerSessionAvatar",
  "settingsModified",
  "spawnModified",
  "kick",
  "ping",
  "pong"
];
var byName = {};
var byId = {};
var ids2 = -1;
for (const name2 of names) {
  const id = ++ids2;
  const info = {
    id,
    name: name2,
    method: `on${capitalize(name2)}`
    // eg 'connect' -> 'onConnect'
  };
  byName[name2] = info;
  byId[id] = info;
}
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function writePacket(name2, data) {
  const info = byName[name2];
  if (!info) throw new Error(`writePacket failed: ${name2} (name not found)`);
  const packet = packr.pack([info.id, data]);
  return packet;
}
function readPacket(packet) {
  try {
    const [id, data] = packr.unpack(packet);
    const info = byId[id];
    if (!info) throw new Error(`readPacket failed: ${id} (id not found)`);
    return [info.method, data];
  } catch (err) {
    console.error(err);
    return [];
  }
}

// node_modules/@jspm/core/nodelibs/browser/chunk-D3uu3VYh.js
var e$2;
var t$3;
var n$2;
var r$2 = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global;
var o$3 = e$2 = {};
function i$2() {
  throw new Error("setTimeout has not been defined");
}
function u$2() {
  throw new Error("clearTimeout has not been defined");
}
function c$2(e7) {
  if (t$3 === setTimeout) return setTimeout(e7, 0);
  if ((t$3 === i$2 || !t$3) && setTimeout) return t$3 = setTimeout, setTimeout(e7, 0);
  try {
    return t$3(e7, 0);
  } catch (n6) {
    try {
      return t$3.call(null, e7, 0);
    } catch (n7) {
      return t$3.call(this || r$2, e7, 0);
    }
  }
}
!function() {
  try {
    t$3 = "function" == typeof setTimeout ? setTimeout : i$2;
  } catch (e7) {
    t$3 = i$2;
  }
  try {
    n$2 = "function" == typeof clearTimeout ? clearTimeout : u$2;
  } catch (e7) {
    n$2 = u$2;
  }
}();
var l$2;
var s$1 = [];
var f$1 = false;
var a$1 = -1;
function h$1() {
  f$1 && l$2 && (f$1 = false, l$2.length ? s$1 = l$2.concat(s$1) : a$1 = -1, s$1.length && d$1());
}
function d$1() {
  if (!f$1) {
    var e7 = c$2(h$1);
    f$1 = true;
    for (var t6 = s$1.length; t6; ) {
      for (l$2 = s$1, s$1 = []; ++a$1 < t6; ) l$2 && l$2[a$1].run();
      a$1 = -1, t6 = s$1.length;
    }
    l$2 = null, f$1 = false, function(e8) {
      if (n$2 === clearTimeout) return clearTimeout(e8);
      if ((n$2 === u$2 || !n$2) && clearTimeout) return n$2 = clearTimeout, clearTimeout(e8);
      try {
        n$2(e8);
      } catch (t7) {
        try {
          return n$2.call(null, e8);
        } catch (t8) {
          return n$2.call(this || r$2, e8);
        }
      }
    }(e7);
  }
}
function m$1(e7, t6) {
  (this || r$2).fun = e7, (this || r$2).array = t6;
}
function p$1() {
}
o$3.nextTick = function(e7) {
  var t6 = new Array(arguments.length - 1);
  if (arguments.length > 1) for (var n6 = 1; n6 < arguments.length; n6++) t6[n6 - 1] = arguments[n6];
  s$1.push(new m$1(e7, t6)), 1 !== s$1.length || f$1 || c$2(d$1);
}, m$1.prototype.run = function() {
  (this || r$2).fun.apply(null, (this || r$2).array);
}, o$3.title = "browser", o$3.browser = true, o$3.env = {}, o$3.argv = [], o$3.version = "", o$3.versions = {}, o$3.on = p$1, o$3.addListener = p$1, o$3.once = p$1, o$3.off = p$1, o$3.removeListener = p$1, o$3.removeAllListeners = p$1, o$3.emit = p$1, o$3.prependListener = p$1, o$3.prependOnceListener = p$1, o$3.listeners = function(e7) {
  return [];
}, o$3.binding = function(e7) {
  throw new Error("process.binding is not supported");
}, o$3.cwd = function() {
  return "/";
}, o$3.chdir = function(e7) {
  throw new Error("process.chdir is not supported");
}, o$3.umask = function() {
  return 0;
};
var T$1 = e$2;
T$1.addListener;
T$1.argv;
T$1.binding;
T$1.browser;
T$1.chdir;
T$1.cwd;
T$1.emit;
T$1.env;
T$1.listeners;
T$1.nextTick;
T$1.off;
T$1.on;
T$1.once;
T$1.prependListener;
T$1.prependOnceListener;
T$1.removeAllListeners;
T$1.removeListener;
T$1.title;
T$1.umask;
T$1.version;
T$1.versions;
var t = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag;
var e2 = Object.prototype.toString;
var o = function(o5) {
  return !(t && o5 && "object" == typeof o5 && Symbol.toStringTag in o5) && "[object Arguments]" === e2.call(o5);
};
var n2 = function(t6) {
  return !!o(t6) || null !== t6 && "object" == typeof t6 && "number" == typeof t6.length && t6.length >= 0 && "[object Array]" !== e2.call(t6) && "[object Function]" === e2.call(t6.callee);
};
var r = function() {
  return o(arguments);
}();
o.isLegacyArguments = n2;
var l = r ? o : n2;
var t$1 = Object.prototype.toString;
var o$1 = Function.prototype.toString;
var n$1 = /^\s*(?:function)?\*/;
var e$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag;
var r$1 = Object.getPrototypeOf;
var c = function() {
  if (!e$1) return false;
  try {
    return Function("return function*() {}")();
  } catch (t6) {
  }
}();
var u = c ? r$1(c) : {};
var i = function(c5) {
  return "function" == typeof c5 && (!!n$1.test(o$1.call(c5)) || (e$1 ? r$1(c5) === u : "[object GeneratorFunction]" === t$1.call(c5)));
};
var t$2 = "function" == typeof Object.create ? function(t6, e7) {
  e7 && (t6.super_ = e7, t6.prototype = Object.create(e7.prototype, { constructor: { value: t6, enumerable: false, writable: true, configurable: true } }));
} : function(t6, e7) {
  if (e7) {
    t6.super_ = e7;
    var o5 = function() {
    };
    o5.prototype = e7.prototype, t6.prototype = new o5(), t6.prototype.constructor = t6;
  }
};
var i$1 = function(e7) {
  return e7 && "object" == typeof e7 && "function" == typeof e7.copy && "function" == typeof e7.fill && "function" == typeof e7.readUInt8;
};
var o$2 = {};
var u$1 = i$1;
var f = l;
var a = i;
function c$1(e7) {
  return e7.call.bind(e7);
}
var s = "undefined" != typeof BigInt;
var p = "undefined" != typeof Symbol;
var y2 = p && void 0 !== Symbol.toStringTag;
var l$1 = "undefined" != typeof Uint8Array;
var d = "undefined" != typeof ArrayBuffer;
if (l$1 && y2) var g = Object.getPrototypeOf(Uint8Array.prototype), b2 = c$1(Object.getOwnPropertyDescriptor(g, Symbol.toStringTag).get);
var m = c$1(Object.prototype.toString);
var h = c$1(Number.prototype.valueOf);
var j = c$1(String.prototype.valueOf);
var A = c$1(Boolean.prototype.valueOf);
if (s) var w2 = c$1(BigInt.prototype.valueOf);
if (p) var v = c$1(Symbol.prototype.valueOf);
function O2(e7, t6) {
  if ("object" != typeof e7) return false;
  try {
    return t6(e7), true;
  } catch (e8) {
    return false;
  }
}
function S(e7) {
  return l$1 && y2 ? void 0 !== b2(e7) : B2(e7) || k2(e7) || E(e7) || D2(e7) || U2(e7) || P2(e7) || x2(e7) || I(e7) || M(e7) || z(e7) || F2(e7);
}
function B2(e7) {
  return l$1 && y2 ? "Uint8Array" === b2(e7) : "[object Uint8Array]" === m(e7) || u$1(e7) && void 0 !== e7.buffer;
}
function k2(e7) {
  return l$1 && y2 ? "Uint8ClampedArray" === b2(e7) : "[object Uint8ClampedArray]" === m(e7);
}
function E(e7) {
  return l$1 && y2 ? "Uint16Array" === b2(e7) : "[object Uint16Array]" === m(e7);
}
function D2(e7) {
  return l$1 && y2 ? "Uint32Array" === b2(e7) : "[object Uint32Array]" === m(e7);
}
function U2(e7) {
  return l$1 && y2 ? "Int8Array" === b2(e7) : "[object Int8Array]" === m(e7);
}
function P2(e7) {
  return l$1 && y2 ? "Int16Array" === b2(e7) : "[object Int16Array]" === m(e7);
}
function x2(e7) {
  return l$1 && y2 ? "Int32Array" === b2(e7) : "[object Int32Array]" === m(e7);
}
function I(e7) {
  return l$1 && y2 ? "Float32Array" === b2(e7) : "[object Float32Array]" === m(e7);
}
function M(e7) {
  return l$1 && y2 ? "Float64Array" === b2(e7) : "[object Float64Array]" === m(e7);
}
function z(e7) {
  return l$1 && y2 ? "BigInt64Array" === b2(e7) : "[object BigInt64Array]" === m(e7);
}
function F2(e7) {
  return l$1 && y2 ? "BigUint64Array" === b2(e7) : "[object BigUint64Array]" === m(e7);
}
function T2(e7) {
  return "[object Map]" === m(e7);
}
function N(e7) {
  return "[object Set]" === m(e7);
}
function W(e7) {
  return "[object WeakMap]" === m(e7);
}
function $(e7) {
  return "[object WeakSet]" === m(e7);
}
function C(e7) {
  return "[object ArrayBuffer]" === m(e7);
}
function V(e7) {
  return "undefined" != typeof ArrayBuffer && (C.working ? C(e7) : e7 instanceof ArrayBuffer);
}
function G(e7) {
  return "[object DataView]" === m(e7);
}
function R(e7) {
  return "undefined" != typeof DataView && (G.working ? G(e7) : e7 instanceof DataView);
}
function J(e7) {
  return "[object SharedArrayBuffer]" === m(e7);
}
function _(e7) {
  return "undefined" != typeof SharedArrayBuffer && (J.working ? J(e7) : e7 instanceof SharedArrayBuffer);
}
function H2(e7) {
  return O2(e7, h);
}
function Z(e7) {
  return O2(e7, j);
}
function q(e7) {
  return O2(e7, A);
}
function K(e7) {
  return s && O2(e7, w2);
}
function L2(e7) {
  return p && O2(e7, v);
}
o$2.isArgumentsObject = f, o$2.isGeneratorFunction = a, o$2.isPromise = function(e7) {
  return "undefined" != typeof Promise && e7 instanceof Promise || null !== e7 && "object" == typeof e7 && "function" == typeof e7.then && "function" == typeof e7.catch;
}, o$2.isArrayBufferView = function(e7) {
  return d && ArrayBuffer.isView ? ArrayBuffer.isView(e7) : S(e7) || R(e7);
}, o$2.isTypedArray = S, o$2.isUint8Array = B2, o$2.isUint8ClampedArray = k2, o$2.isUint16Array = E, o$2.isUint32Array = D2, o$2.isInt8Array = U2, o$2.isInt16Array = P2, o$2.isInt32Array = x2, o$2.isFloat32Array = I, o$2.isFloat64Array = M, o$2.isBigInt64Array = z, o$2.isBigUint64Array = F2, T2.working = "undefined" != typeof Map && T2(/* @__PURE__ */ new Map()), o$2.isMap = function(e7) {
  return "undefined" != typeof Map && (T2.working ? T2(e7) : e7 instanceof Map);
}, N.working = "undefined" != typeof Set && N(/* @__PURE__ */ new Set()), o$2.isSet = function(e7) {
  return "undefined" != typeof Set && (N.working ? N(e7) : e7 instanceof Set);
}, W.working = "undefined" != typeof WeakMap && W(/* @__PURE__ */ new WeakMap()), o$2.isWeakMap = function(e7) {
  return "undefined" != typeof WeakMap && (W.working ? W(e7) : e7 instanceof WeakMap);
}, $.working = "undefined" != typeof WeakSet && $(/* @__PURE__ */ new WeakSet()), o$2.isWeakSet = function(e7) {
  return $(e7);
}, C.working = "undefined" != typeof ArrayBuffer && C(new ArrayBuffer()), o$2.isArrayBuffer = V, G.working = "undefined" != typeof ArrayBuffer && "undefined" != typeof DataView && G(new DataView(new ArrayBuffer(1), 0, 1)), o$2.isDataView = R, J.working = "undefined" != typeof SharedArrayBuffer && J(new SharedArrayBuffer()), o$2.isSharedArrayBuffer = _, o$2.isAsyncFunction = function(e7) {
  return "[object AsyncFunction]" === m(e7);
}, o$2.isMapIterator = function(e7) {
  return "[object Map Iterator]" === m(e7);
}, o$2.isSetIterator = function(e7) {
  return "[object Set Iterator]" === m(e7);
}, o$2.isGeneratorObject = function(e7) {
  return "[object Generator]" === m(e7);
}, o$2.isWebAssemblyCompiledModule = function(e7) {
  return "[object WebAssembly.Module]" === m(e7);
}, o$2.isNumberObject = H2, o$2.isStringObject = Z, o$2.isBooleanObject = q, o$2.isBigIntObject = K, o$2.isSymbolObject = L2, o$2.isBoxedPrimitive = function(e7) {
  return H2(e7) || Z(e7) || q(e7) || K(e7) || L2(e7);
}, o$2.isAnyArrayBuffer = function(e7) {
  return l$1 && (V(e7) || _(e7));
}, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(e7) {
  Object.defineProperty(o$2, e7, { enumerable: false, value: function() {
    throw new Error(e7 + " is not supported in userland");
  } });
});
var Q = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global;
var X = {};
var Y = T$1;
var ee = Object.getOwnPropertyDescriptors || function(e7) {
  for (var t6 = Object.keys(e7), r6 = {}, n6 = 0; n6 < t6.length; n6++) r6[t6[n6]] = Object.getOwnPropertyDescriptor(e7, t6[n6]);
  return r6;
};
var te = /%[sdj%]/g;
X.format = function(e7) {
  if (!ge(e7)) {
    for (var t6 = [], r6 = 0; r6 < arguments.length; r6++) t6.push(oe(arguments[r6]));
    return t6.join(" ");
  }
  r6 = 1;
  for (var n6 = arguments, i5 = n6.length, o5 = String(e7).replace(te, function(e8) {
    if ("%%" === e8) return "%";
    if (r6 >= i5) return e8;
    switch (e8) {
      case "%s":
        return String(n6[r6++]);
      case "%d":
        return Number(n6[r6++]);
      case "%j":
        try {
          return JSON.stringify(n6[r6++]);
        } catch (e9) {
          return "[Circular]";
        }
      default:
        return e8;
    }
  }), u5 = n6[r6]; r6 < i5; u5 = n6[++r6]) le(u5) || !he(u5) ? o5 += " " + u5 : o5 += " " + oe(u5);
  return o5;
}, X.deprecate = function(e7, t6) {
  if (void 0 !== Y && true === Y.noDeprecation) return e7;
  if (void 0 === Y) return function() {
    return X.deprecate(e7, t6).apply(this || Q, arguments);
  };
  var r6 = false;
  return function() {
    if (!r6) {
      if (Y.throwDeprecation) throw new Error(t6);
      Y.traceDeprecation ? console.trace(t6) : console.error(t6), r6 = true;
    }
    return e7.apply(this || Q, arguments);
  };
};
var re = {};
var ne = /^$/;
if (Y.env.NODE_DEBUG) {
  ie = Y.env.NODE_DEBUG;
  ie = ie.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), ne = new RegExp("^" + ie + "$", "i");
}
var ie;
function oe(e7, t6) {
  var r6 = { seen: [], stylize: fe };
  return arguments.length >= 3 && (r6.depth = arguments[2]), arguments.length >= 4 && (r6.colors = arguments[3]), ye(t6) ? r6.showHidden = t6 : t6 && X._extend(r6, t6), be(r6.showHidden) && (r6.showHidden = false), be(r6.depth) && (r6.depth = 2), be(r6.colors) && (r6.colors = false), be(r6.customInspect) && (r6.customInspect = true), r6.colors && (r6.stylize = ue), ae(r6, e7, r6.depth);
}
function ue(e7, t6) {
  var r6 = oe.styles[t6];
  return r6 ? "\x1B[" + oe.colors[r6][0] + "m" + e7 + "\x1B[" + oe.colors[r6][1] + "m" : e7;
}
function fe(e7, t6) {
  return e7;
}
function ae(e7, t6, r6) {
  if (e7.customInspect && t6 && we(t6.inspect) && t6.inspect !== X.inspect && (!t6.constructor || t6.constructor.prototype !== t6)) {
    var n6 = t6.inspect(r6, e7);
    return ge(n6) || (n6 = ae(e7, n6, r6)), n6;
  }
  var i5 = function(e8, t7) {
    if (be(t7)) return e8.stylize("undefined", "undefined");
    if (ge(t7)) {
      var r7 = "'" + JSON.stringify(t7).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return e8.stylize(r7, "string");
    }
    if (de(t7)) return e8.stylize("" + t7, "number");
    if (ye(t7)) return e8.stylize("" + t7, "boolean");
    if (le(t7)) return e8.stylize("null", "null");
  }(e7, t6);
  if (i5) return i5;
  var o5 = Object.keys(t6), u5 = function(e8) {
    var t7 = {};
    return e8.forEach(function(e9, r7) {
      t7[e9] = true;
    }), t7;
  }(o5);
  if (e7.showHidden && (o5 = Object.getOwnPropertyNames(t6)), Ae(t6) && (o5.indexOf("message") >= 0 || o5.indexOf("description") >= 0)) return ce(t6);
  if (0 === o5.length) {
    if (we(t6)) {
      var f5 = t6.name ? ": " + t6.name : "";
      return e7.stylize("[Function" + f5 + "]", "special");
    }
    if (me(t6)) return e7.stylize(RegExp.prototype.toString.call(t6), "regexp");
    if (je(t6)) return e7.stylize(Date.prototype.toString.call(t6), "date");
    if (Ae(t6)) return ce(t6);
  }
  var a5, c5 = "", s5 = false, p5 = ["{", "}"];
  (pe(t6) && (s5 = true, p5 = ["[", "]"]), we(t6)) && (c5 = " [Function" + (t6.name ? ": " + t6.name : "") + "]");
  return me(t6) && (c5 = " " + RegExp.prototype.toString.call(t6)), je(t6) && (c5 = " " + Date.prototype.toUTCString.call(t6)), Ae(t6) && (c5 = " " + ce(t6)), 0 !== o5.length || s5 && 0 != t6.length ? r6 < 0 ? me(t6) ? e7.stylize(RegExp.prototype.toString.call(t6), "regexp") : e7.stylize("[Object]", "special") : (e7.seen.push(t6), a5 = s5 ? function(e8, t7, r7, n7, i6) {
    for (var o6 = [], u6 = 0, f6 = t7.length; u6 < f6; ++u6) ke(t7, String(u6)) ? o6.push(se(e8, t7, r7, n7, String(u6), true)) : o6.push("");
    return i6.forEach(function(i7) {
      i7.match(/^\d+$/) || o6.push(se(e8, t7, r7, n7, i7, true));
    }), o6;
  }(e7, t6, r6, u5, o5) : o5.map(function(n7) {
    return se(e7, t6, r6, u5, n7, s5);
  }), e7.seen.pop(), function(e8, t7, r7) {
    var n7 = 0;
    if (e8.reduce(function(e9, t8) {
      return n7++, t8.indexOf("\n") >= 0 && n7++, e9 + t8.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0) > 60) return r7[0] + ("" === t7 ? "" : t7 + "\n ") + " " + e8.join(",\n  ") + " " + r7[1];
    return r7[0] + t7 + " " + e8.join(", ") + " " + r7[1];
  }(a5, c5, p5)) : p5[0] + c5 + p5[1];
}
function ce(e7) {
  return "[" + Error.prototype.toString.call(e7) + "]";
}
function se(e7, t6, r6, n6, i5, o5) {
  var u5, f5, a5;
  if ((a5 = Object.getOwnPropertyDescriptor(t6, i5) || { value: t6[i5] }).get ? f5 = a5.set ? e7.stylize("[Getter/Setter]", "special") : e7.stylize("[Getter]", "special") : a5.set && (f5 = e7.stylize("[Setter]", "special")), ke(n6, i5) || (u5 = "[" + i5 + "]"), f5 || (e7.seen.indexOf(a5.value) < 0 ? (f5 = le(r6) ? ae(e7, a5.value, null) : ae(e7, a5.value, r6 - 1)).indexOf("\n") > -1 && (f5 = o5 ? f5.split("\n").map(function(e8) {
    return "  " + e8;
  }).join("\n").substr(2) : "\n" + f5.split("\n").map(function(e8) {
    return "   " + e8;
  }).join("\n")) : f5 = e7.stylize("[Circular]", "special")), be(u5)) {
    if (o5 && i5.match(/^\d+$/)) return f5;
    (u5 = JSON.stringify("" + i5)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (u5 = u5.substr(1, u5.length - 2), u5 = e7.stylize(u5, "name")) : (u5 = u5.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), u5 = e7.stylize(u5, "string"));
  }
  return u5 + ": " + f5;
}
function pe(e7) {
  return Array.isArray(e7);
}
function ye(e7) {
  return "boolean" == typeof e7;
}
function le(e7) {
  return null === e7;
}
function de(e7) {
  return "number" == typeof e7;
}
function ge(e7) {
  return "string" == typeof e7;
}
function be(e7) {
  return void 0 === e7;
}
function me(e7) {
  return he(e7) && "[object RegExp]" === ve(e7);
}
function he(e7) {
  return "object" == typeof e7 && null !== e7;
}
function je(e7) {
  return he(e7) && "[object Date]" === ve(e7);
}
function Ae(e7) {
  return he(e7) && ("[object Error]" === ve(e7) || e7 instanceof Error);
}
function we(e7) {
  return "function" == typeof e7;
}
function ve(e7) {
  return Object.prototype.toString.call(e7);
}
function Oe(e7) {
  return e7 < 10 ? "0" + e7.toString(10) : e7.toString(10);
}
X.debuglog = function(e7) {
  if (e7 = e7.toUpperCase(), !re[e7]) if (ne.test(e7)) {
    var t6 = Y.pid;
    re[e7] = function() {
      var r6 = X.format.apply(X, arguments);
      console.error("%s %d: %s", e7, t6, r6);
    };
  } else re[e7] = function() {
  };
  return re[e7];
}, X.inspect = oe, oe.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, oe.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, X.types = o$2, X.isArray = pe, X.isBoolean = ye, X.isNull = le, X.isNullOrUndefined = function(e7) {
  return null == e7;
}, X.isNumber = de, X.isString = ge, X.isSymbol = function(e7) {
  return "symbol" == typeof e7;
}, X.isUndefined = be, X.isRegExp = me, X.types.isRegExp = me, X.isObject = he, X.isDate = je, X.types.isDate = je, X.isError = Ae, X.types.isNativeError = Ae, X.isFunction = we, X.isPrimitive = function(e7) {
  return null === e7 || "boolean" == typeof e7 || "number" == typeof e7 || "string" == typeof e7 || "symbol" == typeof e7 || void 0 === e7;
}, X.isBuffer = i$1;
var Se = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
function Be() {
  var e7 = /* @__PURE__ */ new Date(), t6 = [Oe(e7.getHours()), Oe(e7.getMinutes()), Oe(e7.getSeconds())].join(":");
  return [e7.getDate(), Se[e7.getMonth()], t6].join(" ");
}
function ke(e7, t6) {
  return Object.prototype.hasOwnProperty.call(e7, t6);
}
X.log = function() {
  console.log("%s - %s", Be(), X.format.apply(X, arguments));
}, X.inherits = t$2, X._extend = function(e7, t6) {
  if (!t6 || !he(t6)) return e7;
  for (var r6 = Object.keys(t6), n6 = r6.length; n6--; ) e7[r6[n6]] = t6[r6[n6]];
  return e7;
};
var Ee = "undefined" != typeof Symbol ? Symbol("util.promisify.custom") : void 0;
function De(e7, t6) {
  if (!e7) {
    var r6 = new Error("Promise was rejected with a falsy value");
    r6.reason = e7, e7 = r6;
  }
  return t6(e7);
}
X.promisify = function(e7) {
  if ("function" != typeof e7) throw new TypeError('The "original" argument must be of type Function');
  if (Ee && e7[Ee]) {
    var t6;
    if ("function" != typeof (t6 = e7[Ee])) throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    return Object.defineProperty(t6, Ee, { value: t6, enumerable: false, writable: false, configurable: true }), t6;
  }
  function t6() {
    for (var t7, r6, n6 = new Promise(function(e8, n7) {
      t7 = e8, r6 = n7;
    }), i5 = [], o5 = 0; o5 < arguments.length; o5++) i5.push(arguments[o5]);
    i5.push(function(e8, n7) {
      e8 ? r6(e8) : t7(n7);
    });
    try {
      e7.apply(this || Q, i5);
    } catch (e8) {
      r6(e8);
    }
    return n6;
  }
  return Object.setPrototypeOf(t6, Object.getPrototypeOf(e7)), Ee && Object.defineProperty(t6, Ee, { value: t6, enumerable: false, writable: false, configurable: true }), Object.defineProperties(t6, ee(e7));
}, X.promisify.custom = Ee, X.callbackify = function(e7) {
  if ("function" != typeof e7) throw new TypeError('The "original" argument must be of type Function');
  function t6() {
    for (var t7 = [], r6 = 0; r6 < arguments.length; r6++) t7.push(arguments[r6]);
    var n6 = t7.pop();
    if ("function" != typeof n6) throw new TypeError("The last argument must be of type Function");
    var i5 = this || Q, o5 = function() {
      return n6.apply(i5, arguments);
    };
    e7.apply(this || Q, t7).then(function(e8) {
      Y.nextTick(o5.bind(null, null, e8));
    }, function(e8) {
      Y.nextTick(De.bind(null, e8, o5));
    });
  }
  return Object.setPrototypeOf(t6, Object.getPrototypeOf(e7)), Object.defineProperties(t6, ee(e7)), t6;
};
X._extend;
X.callbackify;
X.debuglog;
X.deprecate;
X.format;
X.inherits;
X.inspect;
X.isArray;
X.isBoolean;
X.isBuffer;
X.isDate;
X.isError;
X.isFunction;
X.isNull;
X.isNullOrUndefined;
X.isNumber;
X.isObject;
X.isPrimitive;
X.isRegExp;
X.isString;
X.isSymbol;
X.isUndefined;
X.log;
X.promisify;
X._extend;
X.callbackify;
X.debuglog;
X.deprecate;
X.format;
X.inherits;
X.inspect;
X.isArray;
X.isBoolean;
X.isBuffer;
X.isDate;
X.isError;
X.isFunction;
X.isNull;
X.isNullOrUndefined;
X.isNumber;
X.isObject;
X.isPrimitive;
X.isRegExp;
X.isString;
X.isSymbol;
X.isUndefined;
X.log;
var promisify = X.promisify;
X.types;

// node_modules/@jspm/core/nodelibs/browser/chunk-CjPlbOtt.js
function e3(e7, r6) {
  if (null == e7) throw new TypeError("Cannot convert first argument to object");
  for (var t6 = Object(e7), n6 = 1; n6 < arguments.length; n6++) {
    var o5 = arguments[n6];
    if (null != o5) for (var a5 = Object.keys(Object(o5)), l5 = 0, i5 = a5.length; l5 < i5; l5++) {
      var c5 = a5[l5], b6 = Object.getOwnPropertyDescriptor(o5, c5);
      void 0 !== b6 && b6.enumerable && (t6[c5] = o5[c5]);
    }
  }
  return t6;
}
var r2 = { assign: e3, polyfill: function() {
  Object.assign || Object.defineProperty(Object, "assign", { enumerable: false, configurable: true, writable: true, value: e3 });
} };
var t2;
var e$12 = Object.prototype.toString;
var r$12 = function(t6) {
  var r6 = e$12.call(t6), n6 = "[object Arguments]" === r6;
  return n6 || (n6 = "[object Array]" !== r6 && null !== t6 && "object" == typeof t6 && "number" == typeof t6.length && t6.length >= 0 && "[object Function]" === e$12.call(t6.callee)), n6;
};
if (!Object.keys) {
  n6 = Object.prototype.hasOwnProperty, o5 = Object.prototype.toString, c5 = r$12, l5 = Object.prototype.propertyIsEnumerable, i5 = !l5.call({ toString: null }, "toString"), a5 = l5.call(function() {
  }, "prototype"), u5 = ["toString", "toLocaleString", "valueOf", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "constructor"], f5 = function(t6) {
    var e7 = t6.constructor;
    return e7 && e7.prototype === t6;
  }, p5 = { $applicationCache: true, $console: true, $external: true, $frame: true, $frameElement: true, $frames: true, $innerHeight: true, $innerWidth: true, $onmozfullscreenchange: true, $onmozfullscreenerror: true, $outerHeight: true, $outerWidth: true, $pageXOffset: true, $pageYOffset: true, $parent: true, $scrollLeft: true, $scrollTop: true, $scrollX: true, $scrollY: true, $self: true, $webkitIndexedDB: true, $webkitStorageInfo: true, $window: true }, s5 = function() {
    if ("undefined" == typeof window) return false;
    for (var t6 in window) try {
      if (!p5["$" + t6] && n6.call(window, t6) && null !== window[t6] && "object" == typeof window[t6]) try {
        f5(window[t6]);
      } catch (t7) {
        return true;
      }
    } catch (t7) {
      return true;
    }
    return false;
  }();
  t2 = function(t6) {
    var e7 = null !== t6 && "object" == typeof t6, r6 = "[object Function]" === o5.call(t6), l6 = c5(t6), p6 = e7 && "[object String]" === o5.call(t6), y7 = [];
    if (!e7 && !r6 && !l6) throw new TypeError("Object.keys called on a non-object");
    var b6 = a5 && r6;
    if (p6 && t6.length > 0 && !n6.call(t6, 0)) for (var g5 = 0; g5 < t6.length; ++g5) y7.push(String(g5));
    if (l6 && t6.length > 0) for (var h6 = 0; h6 < t6.length; ++h6) y7.push(String(h6));
    else for (var $3 in t6) b6 && "prototype" === $3 || !n6.call(t6, $3) || y7.push(String($3));
    if (i5) for (var j4 = function(t7) {
      if ("undefined" == typeof window || !s5) return f5(t7);
      try {
        return f5(t7);
      } catch (t8) {
        return false;
      }
    }(t6), w5 = 0; w5 < u5.length; ++w5) j4 && "constructor" === u5[w5] || !n6.call(t6, u5[w5]) || y7.push(u5[w5]);
    return y7;
  };
}
var n6;
var o5;
var c5;
var l5;
var i5;
var a5;
var u5;
var f5;
var p5;
var s5;
var y3 = t2;
var b3 = Array.prototype.slice;
var g2 = r$12;
var h2 = Object.keys;
var $2 = h2 ? function(t6) {
  return h2(t6);
} : y3;
var j2 = Object.keys;
$2.shim = function() {
  Object.keys ? function() {
    var t6 = Object.keys(arguments);
    return t6 && t6.length === arguments.length;
  }(1, 2) || (Object.keys = function(t6) {
    return g2(t6) ? j2(b3.call(t6)) : j2(t6);
  }) : Object.keys = $2;
  return Object.keys || $2;
};
var w3 = $2;
var r$22 = w3;
var e$22 = "function" == typeof Symbol && "symbol" == typeof Symbol("foo");
var o$12 = Object.prototype.toString;
var n$12 = Array.prototype.concat;
var a$12 = Object.defineProperty;
var c$12 = a$12 && function() {
  var t6 = {};
  try {
    for (var r6 in a$12(t6, "x", { enumerable: false, value: t6 }), t6) return false;
    return t6.x === t6;
  } catch (t7) {
    return false;
  }
}();
var l$12 = function(t6, r6, e7, n6) {
  var l5;
  (!(r6 in t6) || "function" == typeof (l5 = n6) && "[object Function]" === o$12.call(l5) && n6()) && (c$12 ? a$12(t6, r6, { configurable: true, enumerable: false, value: e7, writable: true }) : t6[r6] = e7);
};
var u$12 = function(t6, o5) {
  var a5 = arguments.length > 2 ? arguments[2] : {}, c5 = r$22(o5);
  e$22 && (c5 = n$12.call(c5, Object.getOwnPropertySymbols(o5)));
  for (var u5 = 0; u5 < c5.length; u5 += 1) l$12(t6, c5[u5], o5[c5[u5]], a5[c5[u5]]);
};
u$12.supportsDescriptors = !!c$12;
var f$12 = u$12;
var t$12 = function() {
  if ("function" != typeof Symbol || "function" != typeof Object.getOwnPropertySymbols) return false;
  if ("symbol" == typeof Symbol.iterator) return true;
  var t6 = {}, e7 = Symbol("test"), r6 = Object(e7);
  if ("string" == typeof e7) return false;
  if ("[object Symbol]" !== Object.prototype.toString.call(e7)) return false;
  if ("[object Symbol]" !== Object.prototype.toString.call(r6)) return false;
  for (e7 in t6[e7] = 42, t6) return false;
  if ("function" == typeof Object.keys && 0 !== Object.keys(t6).length) return false;
  if ("function" == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(t6).length) return false;
  var o5 = Object.getOwnPropertySymbols(t6);
  if (1 !== o5.length || o5[0] !== e7) return false;
  if (!Object.prototype.propertyIsEnumerable.call(t6, e7)) return false;
  if ("function" == typeof Object.getOwnPropertyDescriptor) {
    var n6 = Object.getOwnPropertyDescriptor(t6, e7);
    if (42 !== n6.value || true !== n6.enumerable) return false;
  }
  return true;
};
var f$2 = ("undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : global).Symbol;
var e$3 = t$12;
var l$22 = function() {
  return "function" == typeof f$2 && ("function" == typeof Symbol && ("symbol" == typeof f$2("foo") && ("symbol" == typeof Symbol("bar") && e$3())));
};
var t$22 = "Function.prototype.bind called on incompatible ";
var n$22 = Array.prototype.slice;
var o$22 = Object.prototype.toString;
var r$3 = function(r6) {
  var e7 = this;
  if ("function" != typeof e7 || "[object Function]" !== o$22.call(e7)) throw new TypeError(t$22 + e7);
  for (var p5, i5 = n$22.call(arguments, 1), c5 = function() {
    if (this instanceof p5) {
      var t6 = e7.apply(this, i5.concat(n$22.call(arguments)));
      return Object(t6) === t6 ? t6 : this;
    }
    return e7.apply(r6, i5.concat(n$22.call(arguments)));
  }, a5 = Math.max(0, e7.length - i5.length), l5 = [], u5 = 0; u5 < a5; u5++) l5.push("$" + u5);
  if (p5 = Function("binder", "return function (" + l5.join(",") + "){ return binder.apply(this,arguments); }")(c5), e7.prototype) {
    var y7 = function() {
    };
    y7.prototype = e7.prototype, p5.prototype = new y7(), y7.prototype = null;
  }
  return p5;
};
var e$4 = Function.prototype.bind || r$3;
var o$32 = TypeError;
var t$32 = Object.getOwnPropertyDescriptor;
if (t$32) try {
  t$32({}, "");
} catch (r6) {
  t$32 = null;
}
var n$3 = function() {
  throw new o$32();
};
var y$1 = t$32 ? function() {
  try {
    return arguments.callee, n$3;
  } catch (r6) {
    try {
      return t$32(arguments, "callee").get;
    } catch (r7) {
      return n$3;
    }
  }
}() : n$3;
var a$2 = l$22();
var i$12 = Object.getPrototypeOf || function(r6) {
  return r6.__proto__;
};
var d2 = "undefined" == typeof Uint8Array ? void 0 : i$12(Uint8Array);
var f$3 = { "%Array%": Array, "%ArrayBuffer%": "undefined" == typeof ArrayBuffer ? void 0 : ArrayBuffer, "%ArrayBufferPrototype%": "undefined" == typeof ArrayBuffer ? void 0 : ArrayBuffer.prototype, "%ArrayIteratorPrototype%": a$2 ? i$12([][Symbol.iterator]()) : void 0, "%ArrayPrototype%": Array.prototype, "%ArrayProto_entries%": Array.prototype.entries, "%ArrayProto_forEach%": Array.prototype.forEach, "%ArrayProto_keys%": Array.prototype.keys, "%ArrayProto_values%": Array.prototype.values, "%AsyncFromSyncIteratorPrototype%": void 0, "%AsyncFunction%": void 0, "%AsyncFunctionPrototype%": void 0, "%AsyncGenerator%": void 0, "%AsyncGeneratorFunction%": void 0, "%AsyncGeneratorPrototype%": void 0, "%AsyncIteratorPrototype%": void 0, "%Atomics%": "undefined" == typeof Atomics ? void 0 : Atomics, "%Boolean%": Boolean, "%BooleanPrototype%": Boolean.prototype, "%DataView%": "undefined" == typeof DataView ? void 0 : DataView, "%DataViewPrototype%": "undefined" == typeof DataView ? void 0 : DataView.prototype, "%Date%": Date, "%DatePrototype%": Date.prototype, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%ErrorPrototype%": Error.prototype, "%eval%": eval, "%EvalError%": EvalError, "%EvalErrorPrototype%": EvalError.prototype, "%Float32Array%": "undefined" == typeof Float32Array ? void 0 : Float32Array, "%Float32ArrayPrototype%": "undefined" == typeof Float32Array ? void 0 : Float32Array.prototype, "%Float64Array%": "undefined" == typeof Float64Array ? void 0 : Float64Array, "%Float64ArrayPrototype%": "undefined" == typeof Float64Array ? void 0 : Float64Array.prototype, "%Function%": Function, "%FunctionPrototype%": Function.prototype, "%Generator%": void 0, "%GeneratorFunction%": void 0, "%GeneratorPrototype%": void 0, "%Int8Array%": "undefined" == typeof Int8Array ? void 0 : Int8Array, "%Int8ArrayPrototype%": "undefined" == typeof Int8Array ? void 0 : Int8Array.prototype, "%Int16Array%": "undefined" == typeof Int16Array ? void 0 : Int16Array, "%Int16ArrayPrototype%": "undefined" == typeof Int16Array ? void 0 : Int8Array.prototype, "%Int32Array%": "undefined" == typeof Int32Array ? void 0 : Int32Array, "%Int32ArrayPrototype%": "undefined" == typeof Int32Array ? void 0 : Int32Array.prototype, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": a$2 ? i$12(i$12([][Symbol.iterator]())) : void 0, "%JSON%": "object" == typeof JSON ? JSON : void 0, "%JSONParse%": "object" == typeof JSON ? JSON.parse : void 0, "%Map%": "undefined" == typeof Map ? void 0 : Map, "%MapIteratorPrototype%": "undefined" != typeof Map && a$2 ? i$12((/* @__PURE__ */ new Map())[Symbol.iterator]()) : void 0, "%MapPrototype%": "undefined" == typeof Map ? void 0 : Map.prototype, "%Math%": Math, "%Number%": Number, "%NumberPrototype%": Number.prototype, "%Object%": Object, "%ObjectPrototype%": Object.prototype, "%ObjProto_toString%": Object.prototype.toString, "%ObjProto_valueOf%": Object.prototype.valueOf, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": "undefined" == typeof Promise ? void 0 : Promise, "%PromisePrototype%": "undefined" == typeof Promise ? void 0 : Promise.prototype, "%PromiseProto_then%": "undefined" == typeof Promise ? void 0 : Promise.prototype.then, "%Promise_all%": "undefined" == typeof Promise ? void 0 : Promise.all, "%Promise_reject%": "undefined" == typeof Promise ? void 0 : Promise.reject, "%Promise_resolve%": "undefined" == typeof Promise ? void 0 : Promise.resolve, "%Proxy%": "undefined" == typeof Proxy ? void 0 : Proxy, "%RangeError%": RangeError, "%RangeErrorPrototype%": RangeError.prototype, "%ReferenceError%": ReferenceError, "%ReferenceErrorPrototype%": ReferenceError.prototype, "%Reflect%": "undefined" == typeof Reflect ? void 0 : Reflect, "%RegExp%": RegExp, "%RegExpPrototype%": RegExp.prototype, "%Set%": "undefined" == typeof Set ? void 0 : Set, "%SetIteratorPrototype%": "undefined" != typeof Set && a$2 ? i$12((/* @__PURE__ */ new Set())[Symbol.iterator]()) : void 0, "%SetPrototype%": "undefined" == typeof Set ? void 0 : Set.prototype, "%SharedArrayBuffer%": "undefined" == typeof SharedArrayBuffer ? void 0 : SharedArrayBuffer, "%SharedArrayBufferPrototype%": "undefined" == typeof SharedArrayBuffer ? void 0 : SharedArrayBuffer.prototype, "%String%": String, "%StringIteratorPrototype%": a$2 ? i$12(""[Symbol.iterator]()) : void 0, "%StringPrototype%": String.prototype, "%Symbol%": a$2 ? Symbol : void 0, "%SymbolPrototype%": a$2 ? Symbol.prototype : void 0, "%SyntaxError%": SyntaxError, "%SyntaxErrorPrototype%": SyntaxError.prototype, "%ThrowTypeError%": y$1, "%TypedArray%": d2, "%TypedArrayPrototype%": d2 ? d2.prototype : void 0, "%TypeError%": o$32, "%TypeErrorPrototype%": o$32.prototype, "%Uint8Array%": "undefined" == typeof Uint8Array ? void 0 : Uint8Array, "%Uint8ArrayPrototype%": "undefined" == typeof Uint8Array ? void 0 : Uint8Array.prototype, "%Uint8ClampedArray%": "undefined" == typeof Uint8ClampedArray ? void 0 : Uint8ClampedArray, "%Uint8ClampedArrayPrototype%": "undefined" == typeof Uint8ClampedArray ? void 0 : Uint8ClampedArray.prototype, "%Uint16Array%": "undefined" == typeof Uint16Array ? void 0 : Uint16Array, "%Uint16ArrayPrototype%": "undefined" == typeof Uint16Array ? void 0 : Uint16Array.prototype, "%Uint32Array%": "undefined" == typeof Uint32Array ? void 0 : Uint32Array, "%Uint32ArrayPrototype%": "undefined" == typeof Uint32Array ? void 0 : Uint32Array.prototype, "%URIError%": URIError, "%URIErrorPrototype%": URIError.prototype, "%WeakMap%": "undefined" == typeof WeakMap ? void 0 : WeakMap, "%WeakMapPrototype%": "undefined" == typeof WeakMap ? void 0 : WeakMap.prototype, "%WeakSet%": "undefined" == typeof WeakSet ? void 0 : WeakSet, "%WeakSetPrototype%": "undefined" == typeof WeakSet ? void 0 : WeakSet.prototype };
var u$22 = e$4.call(Function.call, String.prototype.replace);
var A2 = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var l$3 = /\\(\\)?/g;
var v7 = function(r6) {
  var e7 = [];
  return u$22(r6, A2, function(r7, o5, t6, n6) {
    e7[e7.length] = t6 ? u$22(n6, l$3, "$1") : o5 || r7;
  }), e7;
};
var P3 = function(r6, e7) {
  if (!(r6 in f$3)) throw new SyntaxError("intrinsic " + r6 + " does not exist!");
  if (void 0 === f$3[r6] && !e7) throw new o$32("intrinsic " + r6 + " exists, but is not available. Please file an issue!");
  return f$3[r6];
};
var c$22 = function(r6, e7) {
  if (0 === r6.length) throw new TypeError("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && "boolean" != typeof e7) throw new TypeError('"allowMissing" argument must be a boolean');
  for (var n6 = v7(r6), y7 = P3("%" + (n6.length > 0 ? n6[0] : "") + "%", e7), a5 = 1; a5 < n6.length; a5 += 1) if (null != y7) if (t$32 && a5 + 1 >= n6.length) {
    var i5 = t$32(y7, n6[a5]);
    if (!(n6[a5] in y7)) throw new o$32("base intrinsic for " + r6 + " exists, but the property is not available.");
    y7 = i5 ? i5.get || i5.value : y7[n6[a5]];
  } else y7 = y7[n6[a5]];
  return y7;
};
var t$4;
var p$12 = e$4;
var o$4 = c$22("%Function%");
var i$22 = o$4.apply;
var a$3 = o$4.call;
(t$4 = function() {
  return p$12.apply(a$3, arguments);
}).apply = function() {
  return p$12.apply(i$22, arguments);
};
var l$4 = t$4;
var r$4;
var n$4;
var i$3 = function(t6) {
  return t6 != t6;
};
var o$5 = (r$4 = function(t6, e7) {
  return 0 === t6 && 0 === e7 ? 1 / t6 == 1 / e7 : t6 === e7 || !(!i$3(t6) || !i$3(e7));
}, r$4);
var c$3 = (n$4 = function() {
  return "function" == typeof Object.is ? Object.is : o$5;
}, n$4);
var f$4 = f$12;
var u$3 = f$12;
var s$12 = r$4;
var a$4 = n$4;
var l$5 = function() {
  var t6 = c$3();
  return f$4(Object, { is: t6 }, { is: function() {
    return Object.is !== t6;
  } }), t6;
};
var p$2 = l$4(a$4(), Object);
u$3(p$2, { getPolyfill: a$4, implementation: s$12, shim: l$5 });
var m4 = p$2;
N2 = function(r6) {
  return r6 != r6;
};
var N2;
var e$5;
var i$4 = N2;
var n$5 = (e$5 = function() {
  return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a") ? Number.isNaN : i$4;
}, f$12);
var t$5 = e$5;
var u$4 = f$12;
var a$5 = N2;
var m$12 = e$5;
var o$6 = function() {
  var r6 = t$5();
  return n$5(Number, { isNaN: r6 }, { isNaN: function() {
    return Number.isNaN !== r6;
  } }), r6;
};
var s$2 = m$12();
u$4(s$2, { getPolyfill: m$12, implementation: a$5, shim: o$6 });
var f$5 = s$2;
var c$4 = {};
var a$6 = false;
function i$5() {
  if (a$6) return c$4;
  function e7(t6) {
    return (e7 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t7) {
      return typeof t7;
    } : function(t7) {
      return t7 && "function" == typeof Symbol && t7.constructor === Symbol && t7 !== Symbol.prototype ? "symbol" : typeof t7;
    })(t6);
  }
  function n6(t6, n7) {
    return !n7 || "object" !== e7(n7) && "function" != typeof n7 ? function(t7) {
      if (void 0 === t7) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return t7;
    }(t6) : n7;
  }
  function r6(t6) {
    return (r6 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t7) {
      return t7.__proto__ || Object.getPrototypeOf(t7);
    })(t6);
  }
  function o5(t6, e8) {
    return (o5 = Object.setPrototypeOf || function(t7, e9) {
      return t7.__proto__ = e9, t7;
    })(t6, e8);
  }
  a$6 = true;
  var i5, u5, l5 = {};
  function f5(t6, e8, c5) {
    c5 || (c5 = Error);
    var a5 = function(c6) {
      function a6(o6, c7, i6) {
        var u6;
        return !function(t7, e9) {
          if (!(t7 instanceof e9)) throw new TypeError("Cannot call a class as a function");
        }(this, a6), (u6 = n6(this, r6(a6).call(this, function(t7, n7, r7) {
          return "string" == typeof e8 ? e8 : e8(t7, n7, r7);
        }(o6, c7, i6)))).code = t6, u6;
      }
      return !function(t7, e9) {
        if ("function" != typeof e9 && null !== e9) throw new TypeError("Super expression must either be null or a function");
        t7.prototype = Object.create(e9 && e9.prototype, { constructor: { value: t7, writable: true, configurable: true } }), e9 && o5(t7, e9);
      }(a6, c6), a6;
    }(c5);
    l5[t6] = a5;
  }
  function s5(t6, e8) {
    if (Array.isArray(t6)) {
      var n7 = t6.length;
      return t6 = t6.map(function(t7) {
        return String(t7);
      }), n7 > 2 ? "one of ".concat(e8, " ").concat(t6.slice(0, n7 - 1).join(", "), ", or ") + t6[n7 - 1] : 2 === n7 ? "one of ".concat(e8, " ").concat(t6[0], " or ").concat(t6[1]) : "of ".concat(e8, " ").concat(t6[0]);
    }
    return "of ".concat(e8, " ").concat(String(t6));
  }
  return f5("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError), f5("ERR_INVALID_ARG_TYPE", function(t6, n7, r7) {
    var o6, c5, u6;
    if (void 0 === i5 && (i5 = tt()), i5("string" == typeof t6, "'name' must be a string"), "string" == typeof n7 && (c5 = "not ", n7.substr(0, c5.length) === c5) ? (o6 = "must not be", n7 = n7.replace(/^not /, "")) : o6 = "must be", function(t7, e8, n8) {
      return (void 0 === n8 || n8 > t7.length) && (n8 = t7.length), t7.substring(n8 - e8.length, n8) === e8;
    }(t6, " argument")) u6 = "The ".concat(t6, " ").concat(o6, " ").concat(s5(n7, "type"));
    else {
      var l6 = function(t7, e8, n8) {
        return "number" != typeof n8 && (n8 = 0), !(n8 + e8.length > t7.length) && -1 !== t7.indexOf(e8, n8);
      }(t6, ".") ? "property" : "argument";
      u6 = 'The "'.concat(t6, '" ').concat(l6, " ").concat(o6, " ").concat(s5(n7, "type"));
    }
    return u6 += ". Received type ".concat(e7(r7));
  }, TypeError), f5("ERR_INVALID_ARG_VALUE", function(e8, n7) {
    var r7 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "is invalid";
    void 0 === u5 && (u5 = X);
    var o6 = u5.inspect(n7);
    return o6.length > 128 && (o6 = "".concat(o6.slice(0, 128), "...")), "The argument '".concat(e8, "' ").concat(r7, ". Received ").concat(o6);
  }, TypeError), f5("ERR_INVALID_RETURN_VALUE", function(t6, n7, r7) {
    var o6;
    return o6 = r7 && r7.constructor && r7.constructor.name ? "instance of ".concat(r7.constructor.name) : "type ".concat(e7(r7)), "Expected ".concat(t6, ' to be returned from the "').concat(n7, '"') + " function but got ".concat(o6, ".");
  }, TypeError), f5("ERR_MISSING_ARGS", function() {
    for (var t6 = arguments.length, e8 = new Array(t6), n7 = 0; n7 < t6; n7++) e8[n7] = arguments[n7];
    void 0 === i5 && (i5 = tt()), i5(e8.length > 0, "At least one arg needs to be specified");
    var r7 = "The ", o6 = e8.length;
    switch (e8 = e8.map(function(t7) {
      return '"'.concat(t7, '"');
    }), o6) {
      case 1:
        r7 += "".concat(e8[0], " argument");
        break;
      case 2:
        r7 += "".concat(e8[0], " and ").concat(e8[1], " arguments");
        break;
      default:
        r7 += e8.slice(0, o6 - 1).join(", "), r7 += ", and ".concat(e8[o6 - 1], " arguments");
    }
    return "".concat(r7, " must be specified");
  }, TypeError), c$4.codes = l5, c$4;
}
var u$5 = {};
var l$6 = false;
function f$6() {
  if (l$6) return u$5;
  l$6 = true;
  var n6 = T$1;
  function r6(t6, e7, n7) {
    return e7 in t6 ? Object.defineProperty(t6, e7, { value: n7, enumerable: true, configurable: true, writable: true }) : t6[e7] = n7, t6;
  }
  function o5(t6, e7) {
    for (var n7 = 0; n7 < e7.length; n7++) {
      var r7 = e7[n7];
      r7.enumerable = r7.enumerable || false, r7.configurable = true, "value" in r7 && (r7.writable = true), Object.defineProperty(t6, r7.key, r7);
    }
  }
  function c5(t6, e7) {
    return !e7 || "object" !== y7(e7) && "function" != typeof e7 ? a5(t6) : e7;
  }
  function a5(t6) {
    if (void 0 === t6) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return t6;
  }
  function f5(t6) {
    var e7 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
    return (f5 = function(t7) {
      if (null === t7 || (n7 = t7, -1 === Function.toString.call(n7).indexOf("[native code]"))) return t7;
      var n7;
      if ("function" != typeof t7) throw new TypeError("Super expression must either be null or a function");
      if (void 0 !== e7) {
        if (e7.has(t7)) return e7.get(t7);
        e7.set(t7, r7);
      }
      function r7() {
        return p5(t7, arguments, h6(this).constructor);
      }
      return r7.prototype = Object.create(t7.prototype, { constructor: { value: r7, enumerable: false, writable: true, configurable: true } }), g5(r7, t7);
    })(t6);
  }
  function s5() {
    if ("undefined" == typeof Reflect || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if ("function" == typeof Proxy) return true;
    try {
      return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      })), true;
    } catch (t6) {
      return false;
    }
  }
  function p5(t6, e7, n7) {
    return (p5 = s5() ? Reflect.construct : function(t7, e8, n8) {
      var r7 = [null];
      r7.push.apply(r7, e8);
      var o6 = new (Function.bind.apply(t7, r7))();
      return n8 && g5(o6, n8.prototype), o6;
    }).apply(null, arguments);
  }
  function g5(t6, e7) {
    return (g5 = Object.setPrototypeOf || function(t7, e8) {
      return t7.__proto__ = e8, t7;
    })(t6, e7);
  }
  function h6(t6) {
    return (h6 = Object.setPrototypeOf ? Object.getPrototypeOf : function(t7) {
      return t7.__proto__ || Object.getPrototypeOf(t7);
    })(t6);
  }
  function y7(t6) {
    return (y7 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t7) {
      return typeof t7;
    } : function(t7) {
      return t7 && "function" == typeof Symbol && t7.constructor === Symbol && t7 !== Symbol.prototype ? "symbol" : typeof t7;
    })(t6);
  }
  var b6 = X.inspect, v11 = i$5().codes.ERR_INVALID_ARG_TYPE;
  function d5(t6, e7, n7) {
    return (void 0 === n7 || n7 > t6.length) && (n7 = t6.length), t6.substring(n7 - e7.length, n7) === e7;
  }
  var m7 = "", E4 = "", w5 = "", S4 = "", j4 = { deepStrictEqual: "Expected values to be strictly deep-equal:", strictEqual: "Expected values to be strictly equal:", strictEqualObject: 'Expected "actual" to be reference-equal to "expected":', deepEqual: "Expected values to be loosely deep-equal:", equal: "Expected values to be loosely equal:", notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:', notStrictEqual: 'Expected "actual" to be strictly unequal to:', notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":', notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:', notEqual: 'Expected "actual" to be loosely unequal to:', notIdentical: "Values identical but not reference-equal:" };
  function O6(t6) {
    var e7 = Object.keys(t6), n7 = Object.create(Object.getPrototypeOf(t6));
    return e7.forEach(function(e8) {
      n7[e8] = t6[e8];
    }), Object.defineProperty(n7, "message", { value: t6.message }), n7;
  }
  function x5(t6) {
    return b6(t6, { compact: false, customInspect: false, depth: 1e3, maxArrayLength: 1 / 0, showHidden: false, breakLength: 1 / 0, showProxy: false, sorted: true, getters: true });
  }
  function q6(t6, e7, r7) {
    var o6 = "", c6 = "", a6 = 0, i5 = "", u5 = false, l5 = x5(t6), f6 = l5.split("\n"), s6 = x5(e7).split("\n"), p6 = 0, g6 = "";
    if ("strictEqual" === r7 && "object" === y7(t6) && "object" === y7(e7) && null !== t6 && null !== e7 && (r7 = "strictEqualObject"), 1 === f6.length && 1 === s6.length && f6[0] !== s6[0]) {
      var h7 = f6[0].length + s6[0].length;
      if (h7 <= 10) {
        if (!("object" === y7(t6) && null !== t6 || "object" === y7(e7) && null !== e7 || 0 === t6 && 0 === e7)) return "".concat(j4[r7], "\n\n") + "".concat(f6[0], " !== ").concat(s6[0], "\n");
      } else if ("strictEqualObject" !== r7) {
        if (h7 < (n6.stderr && n6.stderr.isTTY ? n6.stderr.columns : 80)) {
          for (; f6[0][p6] === s6[0][p6]; ) p6++;
          p6 > 2 && (g6 = "\n  ".concat(function(t7, e8) {
            if (e8 = Math.floor(e8), 0 == t7.length || 0 == e8) return "";
            var n7 = t7.length * e8;
            for (e8 = Math.floor(Math.log(e8) / Math.log(2)); e8; ) t7 += t7, e8--;
            return t7 += t7.substring(0, n7 - t7.length);
          }(" ", p6), "^"), p6 = 0);
        }
      }
    }
    for (var b7 = f6[f6.length - 1], v20 = s6[s6.length - 1]; b7 === v20 && (p6++ < 2 ? i5 = "\n  ".concat(b7).concat(i5) : o6 = b7, f6.pop(), s6.pop(), 0 !== f6.length && 0 !== s6.length); ) b7 = f6[f6.length - 1], v20 = s6[s6.length - 1];
    var O7 = Math.max(f6.length, s6.length);
    if (0 === O7) {
      var q7 = l5.split("\n");
      if (q7.length > 30) for (q7[26] = "".concat(m7, "...").concat(S4); q7.length > 27; ) q7.pop();
      return "".concat(j4.notIdentical, "\n\n").concat(q7.join("\n"), "\n");
    }
    p6 > 3 && (i5 = "\n".concat(m7, "...").concat(S4).concat(i5), u5 = true), "" !== o6 && (i5 = "\n  ".concat(o6).concat(i5), o6 = "");
    var R5 = 0, A4 = j4[r7] + "\n".concat(E4, "+ actual").concat(S4, " ").concat(w5, "- expected").concat(S4), k5 = " ".concat(m7, "...").concat(S4, " Lines skipped");
    for (p6 = 0; p6 < O7; p6++) {
      var _4 = p6 - a6;
      if (f6.length < p6 + 1) _4 > 1 && p6 > 2 && (_4 > 4 ? (c6 += "\n".concat(m7, "...").concat(S4), u5 = true) : _4 > 3 && (c6 += "\n  ".concat(s6[p6 - 2]), R5++), c6 += "\n  ".concat(s6[p6 - 1]), R5++), a6 = p6, o6 += "\n".concat(w5, "-").concat(S4, " ").concat(s6[p6]), R5++;
      else if (s6.length < p6 + 1) _4 > 1 && p6 > 2 && (_4 > 4 ? (c6 += "\n".concat(m7, "...").concat(S4), u5 = true) : _4 > 3 && (c6 += "\n  ".concat(f6[p6 - 2]), R5++), c6 += "\n  ".concat(f6[p6 - 1]), R5++), a6 = p6, c6 += "\n".concat(E4, "+").concat(S4, " ").concat(f6[p6]), R5++;
      else {
        var T5 = s6[p6], P5 = f6[p6], I4 = P5 !== T5 && (!d5(P5, ",") || P5.slice(0, -1) !== T5);
        I4 && d5(T5, ",") && T5.slice(0, -1) === P5 && (I4 = false, P5 += ","), I4 ? (_4 > 1 && p6 > 2 && (_4 > 4 ? (c6 += "\n".concat(m7, "...").concat(S4), u5 = true) : _4 > 3 && (c6 += "\n  ".concat(f6[p6 - 2]), R5++), c6 += "\n  ".concat(f6[p6 - 1]), R5++), a6 = p6, c6 += "\n".concat(E4, "+").concat(S4, " ").concat(P5), o6 += "\n".concat(w5, "-").concat(S4, " ").concat(T5), R5 += 2) : (c6 += o6, o6 = "", 1 !== _4 && 0 !== p6 || (c6 += "\n  ".concat(P5), R5++));
      }
      if (R5 > 20 && p6 < O7 - 2) return "".concat(A4).concat(k5, "\n").concat(c6, "\n").concat(m7, "...").concat(S4).concat(o6, "\n") + "".concat(m7, "...").concat(S4);
    }
    return "".concat(A4).concat(u5 ? k5 : "", "\n").concat(c6).concat(o6).concat(i5).concat(g6);
  }
  var R4 = function(t6) {
    function e7(t7) {
      var r7;
      if (!function(t8, e8) {
        if (!(t8 instanceof e8)) throw new TypeError("Cannot call a class as a function");
      }(this, e7), "object" !== y7(t7) || null === t7) throw new v11("options", "Object", t7);
      var o6 = t7.message, i6 = t7.operator, u6 = t7.stackStartFn, l5 = t7.actual, f6 = t7.expected, s6 = Error.stackTraceLimit;
      if (Error.stackTraceLimit = 0, null != o6) r7 = c5(this, h6(e7).call(this, String(o6)));
      else if (n6.stderr && n6.stderr.isTTY && (n6.stderr && n6.stderr.getColorDepth && 1 !== n6.stderr.getColorDepth() ? (m7 = "\x1B[34m", E4 = "\x1B[32m", S4 = "\x1B[39m", w5 = "\x1B[31m") : (m7 = "", E4 = "", S4 = "", w5 = "")), "object" === y7(l5) && null !== l5 && "object" === y7(f6) && null !== f6 && "stack" in l5 && l5 instanceof Error && "stack" in f6 && f6 instanceof Error && (l5 = O6(l5), f6 = O6(f6)), "deepStrictEqual" === i6 || "strictEqual" === i6) r7 = c5(this, h6(e7).call(this, q6(l5, f6, i6)));
      else if ("notDeepStrictEqual" === i6 || "notStrictEqual" === i6) {
        var p6 = j4[i6], g6 = x5(l5).split("\n");
        if ("notStrictEqual" === i6 && "object" === y7(l5) && null !== l5 && (p6 = j4.notStrictEqualObject), g6.length > 30) for (g6[26] = "".concat(m7, "...").concat(S4); g6.length > 27; ) g6.pop();
        r7 = 1 === g6.length ? c5(this, h6(e7).call(this, "".concat(p6, " ").concat(g6[0]))) : c5(this, h6(e7).call(this, "".concat(p6, "\n\n").concat(g6.join("\n"), "\n")));
      } else {
        var b7 = x5(l5), d6 = "", R5 = j4[i6];
        "notDeepEqual" === i6 || "notEqual" === i6 ? (b7 = "".concat(j4[i6], "\n\n").concat(b7)).length > 1024 && (b7 = "".concat(b7.slice(0, 1021), "...")) : (d6 = "".concat(x5(f6)), b7.length > 512 && (b7 = "".concat(b7.slice(0, 509), "...")), d6.length > 512 && (d6 = "".concat(d6.slice(0, 509), "...")), "deepEqual" === i6 || "equal" === i6 ? b7 = "".concat(R5, "\n\n").concat(b7, "\n\nshould equal\n\n") : d6 = " ".concat(i6, " ").concat(d6)), r7 = c5(this, h6(e7).call(this, "".concat(b7).concat(d6)));
      }
      return Error.stackTraceLimit = s6, r7.generatedMessage = !o6, Object.defineProperty(a5(r7), "name", { value: "AssertionError [ERR_ASSERTION]", enumerable: false, writable: true, configurable: true }), r7.code = "ERR_ASSERTION", r7.actual = l5, r7.expected = f6, r7.operator = i6, Error.captureStackTrace && Error.captureStackTrace(a5(r7), u6), r7.stack, r7.name = "AssertionError", c5(r7);
    }
    var i5, u5;
    return !function(t7, e8) {
      if ("function" != typeof e8 && null !== e8) throw new TypeError("Super expression must either be null or a function");
      t7.prototype = Object.create(e8 && e8.prototype, { constructor: { value: t7, writable: true, configurable: true } }), e8 && g5(t7, e8);
    }(e7, t6), i5 = e7, (u5 = [{ key: "toString", value: function() {
      return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
    } }, { key: b6.custom, value: function(t7, e8) {
      return b6(this, function(t8) {
        for (var e9 = 1; e9 < arguments.length; e9++) {
          var n7 = null != arguments[e9] ? arguments[e9] : {}, o6 = Object.keys(n7);
          "function" == typeof Object.getOwnPropertySymbols && (o6 = o6.concat(Object.getOwnPropertySymbols(n7).filter(function(t9) {
            return Object.getOwnPropertyDescriptor(n7, t9).enumerable;
          }))), o6.forEach(function(e10) {
            r6(t8, e10, n7[e10]);
          });
        }
        return t8;
      }({}, e8, { customInspect: false, depth: 0 }));
    } }]) && o5(i5.prototype, u5), e7;
  }(f5(Error));
  return u$5 = R4;
}
function s$3(t6, e7) {
  return function(t7) {
    if (Array.isArray(t7)) return t7;
  }(t6) || function(t7, e8) {
    var n6 = [], r6 = true, o5 = false, c5 = void 0;
    try {
      for (var a5, i5 = t7[Symbol.iterator](); !(r6 = (a5 = i5.next()).done) && (n6.push(a5.value), !e8 || n6.length !== e8); r6 = true) ;
    } catch (t8) {
      o5 = true, c5 = t8;
    } finally {
      try {
        r6 || null == i5.return || i5.return();
      } finally {
        if (o5) throw c5;
      }
    }
    return n6;
  }(t6, e7) || function() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }();
}
function p$3(t6) {
  return (p$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t7) {
    return typeof t7;
  } : function(t7) {
    return t7 && "function" == typeof Symbol && t7.constructor === Symbol && t7 !== Symbol.prototype ? "symbol" : typeof t7;
  })(t6);
}
var g$1 = void 0 !== /a/g.flags;
var h$12 = function(t6) {
  var e7 = [];
  return t6.forEach(function(t7) {
    return e7.push(t7);
  }), e7;
};
var y$2 = function(t6) {
  var e7 = [];
  return t6.forEach(function(t7, n6) {
    return e7.push([n6, t7]);
  }), e7;
};
var b$1 = Object.is ? Object.is : m4;
var v$1 = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
  return [];
};
var d$12 = Number.isNaN ? Number.isNaN : f$5;
function m$2(t6) {
  return t6.call.bind(t6);
}
var E2 = m$2(Object.prototype.hasOwnProperty);
var w$1 = m$2(Object.prototype.propertyIsEnumerable);
var S2 = m$2(Object.prototype.toString);
var j$1 = X.types;
var O3 = j$1.isAnyArrayBuffer;
var x3 = j$1.isArrayBufferView;
var q5 = j$1.isDate;
var R2 = j$1.isMap;
var A$1 = j$1.isRegExp;
var k3 = j$1.isSet;
var _2 = j$1.isNativeError;
var T3 = j$1.isBoxedPrimitive;
var P$1 = j$1.isNumberObject;
var I2 = j$1.isStringObject;
var D3 = j$1.isBooleanObject;
var F3 = j$1.isBigIntObject;
var N$1 = j$1.isSymbolObject;
var L3 = j$1.isFloat32Array;
var M2 = j$1.isFloat64Array;
function U3(t6) {
  if (0 === t6.length || t6.length > 10) return true;
  for (var e7 = 0; e7 < t6.length; e7++) {
    var n6 = t6.charCodeAt(e7);
    if (n6 < 48 || n6 > 57) return true;
  }
  return 10 === t6.length && t6 >= Math.pow(2, 32);
}
function G2(t6) {
  return Object.keys(t6).filter(U3).concat(v$1(t6).filter(Object.prototype.propertyIsEnumerable.bind(t6)));
}
function V2(t6, e7) {
  if (t6 === e7) return 0;
  for (var n6 = t6.length, r6 = e7.length, o5 = 0, c5 = Math.min(n6, r6); o5 < c5; ++o5) if (t6[o5] !== e7[o5]) {
    n6 = t6[o5], r6 = e7[o5];
    break;
  }
  return n6 < r6 ? -1 : r6 < n6 ? 1 : 0;
}
function B3(t6, e7, n6, r6) {
  if (t6 === e7) return 0 !== t6 || (!n6 || b$1(t6, e7));
  if (n6) {
    if ("object" !== p$3(t6)) return "number" == typeof t6 && d$12(t6) && d$12(e7);
    if ("object" !== p$3(e7) || null === t6 || null === e7) return false;
    if (Object.getPrototypeOf(t6) !== Object.getPrototypeOf(e7)) return false;
  } else {
    if (null === t6 || "object" !== p$3(t6)) return (null === e7 || "object" !== p$3(e7)) && t6 == e7;
    if (null === e7 || "object" !== p$3(e7)) return false;
  }
  var o5, c5, a5, i5, u5 = S2(t6);
  if (u5 !== S2(e7)) return false;
  if (Array.isArray(t6)) {
    if (t6.length !== e7.length) return false;
    var l5 = G2(t6), f5 = G2(e7);
    return l5.length === f5.length && C2(t6, e7, n6, r6, 1, l5);
  }
  if ("[object Object]" === u5 && (!R2(t6) && R2(e7) || !k3(t6) && k3(e7))) return false;
  if (q5(t6)) {
    if (!q5(e7) || Date.prototype.getTime.call(t6) !== Date.prototype.getTime.call(e7)) return false;
  } else if (A$1(t6)) {
    if (!A$1(e7) || (a5 = t6, i5 = e7, !(g$1 ? a5.source === i5.source && a5.flags === i5.flags : RegExp.prototype.toString.call(a5) === RegExp.prototype.toString.call(i5)))) return false;
  } else if (_2(t6) || t6 instanceof Error) {
    if (t6.message !== e7.message || t6.name !== e7.name) return false;
  } else {
    if (x3(t6)) {
      if (n6 || !L3(t6) && !M2(t6)) {
        if (!function(t7, e8) {
          return t7.byteLength === e8.byteLength && 0 === V2(new Uint8Array(t7.buffer, t7.byteOffset, t7.byteLength), new Uint8Array(e8.buffer, e8.byteOffset, e8.byteLength));
        }(t6, e7)) return false;
      } else if (!function(t7, e8) {
        if (t7.byteLength !== e8.byteLength) return false;
        for (var n7 = 0; n7 < t7.byteLength; n7++) if (t7[n7] !== e8[n7]) return false;
        return true;
      }(t6, e7)) return false;
      var s5 = G2(t6), h6 = G2(e7);
      return s5.length === h6.length && C2(t6, e7, n6, r6, 0, s5);
    }
    if (k3(t6)) return !(!k3(e7) || t6.size !== e7.size) && C2(t6, e7, n6, r6, 2);
    if (R2(t6)) return !(!R2(e7) || t6.size !== e7.size) && C2(t6, e7, n6, r6, 3);
    if (O3(t6)) {
      if (c5 = e7, (o5 = t6).byteLength !== c5.byteLength || 0 !== V2(new Uint8Array(o5), new Uint8Array(c5))) return false;
    } else if (T3(t6) && !function(t7, e8) {
      return P$1(t7) ? P$1(e8) && b$1(Number.prototype.valueOf.call(t7), Number.prototype.valueOf.call(e8)) : I2(t7) ? I2(e8) && String.prototype.valueOf.call(t7) === String.prototype.valueOf.call(e8) : D3(t7) ? D3(e8) && Boolean.prototype.valueOf.call(t7) === Boolean.prototype.valueOf.call(e8) : F3(t7) ? F3(e8) && BigInt.prototype.valueOf.call(t7) === BigInt.prototype.valueOf.call(e8) : N$1(e8) && Symbol.prototype.valueOf.call(t7) === Symbol.prototype.valueOf.call(e8);
    }(t6, e7)) return false;
  }
  return C2(t6, e7, n6, r6, 0);
}
function z2(t6, e7) {
  return e7.filter(function(e8) {
    return w$1(t6, e8);
  });
}
function C2(t6, e7, n6, r6, o5, c5) {
  if (5 === arguments.length) {
    c5 = Object.keys(t6);
    var a5 = Object.keys(e7);
    if (c5.length !== a5.length) return false;
  }
  for (var i5 = 0; i5 < c5.length; i5++) if (!E2(e7, c5[i5])) return false;
  if (n6 && 5 === arguments.length) {
    var u5 = v$1(t6);
    if (0 !== u5.length) {
      var l5 = 0;
      for (i5 = 0; i5 < u5.length; i5++) {
        var f5 = u5[i5];
        if (w$1(t6, f5)) {
          if (!w$1(e7, f5)) return false;
          c5.push(f5), l5++;
        } else if (w$1(e7, f5)) return false;
      }
      var s5 = v$1(e7);
      if (u5.length !== s5.length && z2(e7, s5).length !== l5) return false;
    } else {
      var p5 = v$1(e7);
      if (0 !== p5.length && 0 !== z2(e7, p5).length) return false;
    }
  }
  if (0 === c5.length && (0 === o5 || 1 === o5 && 0 === t6.length || 0 === t6.size)) return true;
  if (void 0 === r6) r6 = { val1: /* @__PURE__ */ new Map(), val2: /* @__PURE__ */ new Map(), position: 0 };
  else {
    var g5 = r6.val1.get(t6);
    if (void 0 !== g5) {
      var h6 = r6.val2.get(e7);
      if (void 0 !== h6) return g5 === h6;
    }
    r6.position++;
  }
  r6.val1.set(t6, r6.position), r6.val2.set(e7, r6.position);
  var y7 = Q2(t6, e7, n6, c5, r6, o5);
  return r6.val1.delete(t6), r6.val2.delete(e7), y7;
}
function Y2(t6, e7, n6, r6) {
  for (var o5 = h$12(t6), c5 = 0; c5 < o5.length; c5++) {
    var a5 = o5[c5];
    if (B3(e7, a5, n6, r6)) return t6.delete(a5), true;
  }
  return false;
}
function W2(t6) {
  switch (p$3(t6)) {
    case "undefined":
      return null;
    case "object":
      return;
    case "symbol":
      return false;
    case "string":
      t6 = +t6;
    case "number":
      if (d$12(t6)) return false;
  }
  return true;
}
function H3(t6, e7, n6) {
  var r6 = W2(n6);
  return null != r6 ? r6 : e7.has(r6) && !t6.has(r6);
}
function J2(t6, e7, n6, r6, o5) {
  var c5 = W2(n6);
  if (null != c5) return c5;
  var a5 = e7.get(c5);
  return !(void 0 === a5 && !e7.has(c5) || !B3(r6, a5, false, o5)) && (!t6.has(c5) && B3(r6, a5, false, o5));
}
function K2(t6, e7, n6, r6, o5, c5) {
  for (var a5 = h$12(t6), i5 = 0; i5 < a5.length; i5++) {
    var u5 = a5[i5];
    if (B3(n6, u5, o5, c5) && B3(r6, e7.get(u5), o5, c5)) return t6.delete(u5), true;
  }
  return false;
}
function Q2(t6, e7, n6, r6, o5, c5) {
  var a5 = 0;
  if (2 === c5) {
    if (!function(t7, e8, n7, r7) {
      for (var o6 = null, c6 = h$12(t7), a6 = 0; a6 < c6.length; a6++) {
        var i6 = c6[a6];
        if ("object" === p$3(i6) && null !== i6) null === o6 && (o6 = /* @__PURE__ */ new Set()), o6.add(i6);
        else if (!e8.has(i6)) {
          if (n7) return false;
          if (!H3(t7, e8, i6)) return false;
          null === o6 && (o6 = /* @__PURE__ */ new Set()), o6.add(i6);
        }
      }
      if (null !== o6) {
        for (var u6 = h$12(e8), l6 = 0; l6 < u6.length; l6++) {
          var f5 = u6[l6];
          if ("object" === p$3(f5) && null !== f5) {
            if (!Y2(o6, f5, n7, r7)) return false;
          } else if (!n7 && !t7.has(f5) && !Y2(o6, f5, n7, r7)) return false;
        }
        return 0 === o6.size;
      }
      return true;
    }(t6, e7, n6, o5)) return false;
  } else if (3 === c5) {
    if (!function(t7, e8, n7, r7) {
      for (var o6 = null, c6 = y$2(t7), a6 = 0; a6 < c6.length; a6++) {
        var i6 = s$3(c6[a6], 2), u6 = i6[0], l6 = i6[1];
        if ("object" === p$3(u6) && null !== u6) null === o6 && (o6 = /* @__PURE__ */ new Set()), o6.add(u6);
        else {
          var f5 = e8.get(u6);
          if (void 0 === f5 && !e8.has(u6) || !B3(l6, f5, n7, r7)) {
            if (n7) return false;
            if (!J2(t7, e8, u6, l6, r7)) return false;
            null === o6 && (o6 = /* @__PURE__ */ new Set()), o6.add(u6);
          }
        }
      }
      if (null !== o6) {
        for (var g5 = y$2(e8), h6 = 0; h6 < g5.length; h6++) {
          var b6 = s$3(g5[h6], 2), v11 = (u6 = b6[0], b6[1]);
          if ("object" === p$3(u6) && null !== u6) {
            if (!K2(o6, t7, u6, v11, n7, r7)) return false;
          } else if (!(n7 || t7.has(u6) && B3(t7.get(u6), v11, false, r7) || K2(o6, t7, u6, v11, false, r7))) return false;
        }
        return 0 === o6.size;
      }
      return true;
    }(t6, e7, n6, o5)) return false;
  } else if (1 === c5) for (; a5 < t6.length; a5++) {
    if (!E2(t6, a5)) {
      if (E2(e7, a5)) return false;
      for (var i5 = Object.keys(t6); a5 < i5.length; a5++) {
        var u5 = i5[a5];
        if (!E2(e7, u5) || !B3(t6[u5], e7[u5], n6, o5)) return false;
      }
      return i5.length === Object.keys(e7).length;
    }
    if (!E2(e7, a5) || !B3(t6[a5], e7[a5], n6, o5)) return false;
  }
  for (a5 = 0; a5 < r6.length; a5++) {
    var l5 = r6[a5];
    if (!B3(t6[l5], e7[l5], n6, o5)) return false;
  }
  return true;
}
var X2 = { isDeepEqual: function(t6, e7) {
  return B3(t6, e7, false);
}, isDeepStrictEqual: function(t6, e7) {
  return B3(t6, e7, true);
} };
var Z2 = {};
var $$1 = false;
function tt() {
  if ($$1) return Z2;
  $$1 = true;
  var o5 = T$1;
  function c5(t6) {
    return (c5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t7) {
      return typeof t7;
    } : function(t7) {
      return t7 && "function" == typeof Symbol && t7.constructor === Symbol && t7 !== Symbol.prototype ? "symbol" : typeof t7;
    })(t6);
  }
  var a5, u5, l5 = i$5().codes, s5 = l5.ERR_AMBIGUOUS_ARGUMENT, p5 = l5.ERR_INVALID_ARG_TYPE, g5 = l5.ERR_INVALID_ARG_VALUE, h6 = l5.ERR_INVALID_RETURN_VALUE, y7 = l5.ERR_MISSING_ARGS, b6 = f$6(), v11 = X.inspect, d5 = X.types, m$13 = d5.isPromise, E4 = d5.isRegExp, w5 = Object.assign ? Object.assign : r2.assign, S4 = Object.is ? Object.is : m4;
  function j4() {
    a5 = X2.isDeepEqual, u5 = X2.isDeepStrictEqual;
  }
  var O6 = false, x5 = Z2 = k5, q6 = {};
  function R4(t6) {
    if (t6.message instanceof Error) throw t6.message;
    throw new b6(t6);
  }
  function A4(t6, e7, n6, r6) {
    if (!n6) {
      var o6 = false;
      if (0 === e7) o6 = true, r6 = "No value argument passed to `assert.ok()`";
      else if (r6 instanceof Error) throw r6;
      var c6 = new b6({ actual: n6, expected: true, message: r6, operator: "==", stackStartFn: t6 });
      throw c6.generatedMessage = o6, c6;
    }
  }
  function k5() {
    for (var t6 = arguments.length, e7 = new Array(t6), n6 = 0; n6 < t6; n6++) e7[n6] = arguments[n6];
    A4.apply(void 0, [k5, e7.length].concat(e7));
  }
  x5.fail = function t6(e7, n6, r6, c6, a6) {
    var i5, u6 = arguments.length;
    if (0 === u6) i5 = "Failed";
    else if (1 === u6) r6 = e7, e7 = void 0;
    else {
      if (false === O6) {
        O6 = true;
        var l6 = o5.emitWarning ? o5.emitWarning : console.warn.bind(console);
        l6("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
      }
      2 === u6 && (c6 = "!=");
    }
    if (r6 instanceof Error) throw r6;
    var f5 = { actual: e7, expected: n6, operator: void 0 === c6 ? "fail" : c6, stackStartFn: a6 || t6 };
    void 0 !== r6 && (f5.message = r6);
    var s6 = new b6(f5);
    throw i5 && (s6.message = i5, s6.generatedMessage = true), s6;
  }, x5.AssertionError = b6, x5.ok = k5, x5.equal = function t6(e7, n6, r6) {
    if (arguments.length < 2) throw new y7("actual", "expected");
    e7 != n6 && R4({ actual: e7, expected: n6, message: r6, operator: "==", stackStartFn: t6 });
  }, x5.notEqual = function t6(e7, n6, r6) {
    if (arguments.length < 2) throw new y7("actual", "expected");
    e7 == n6 && R4({ actual: e7, expected: n6, message: r6, operator: "!=", stackStartFn: t6 });
  }, x5.deepEqual = function t6(e7, n6, r6) {
    if (arguments.length < 2) throw new y7("actual", "expected");
    void 0 === a5 && j4(), a5(e7, n6) || R4({ actual: e7, expected: n6, message: r6, operator: "deepEqual", stackStartFn: t6 });
  }, x5.notDeepEqual = function t6(e7, n6, r6) {
    if (arguments.length < 2) throw new y7("actual", "expected");
    void 0 === a5 && j4(), a5(e7, n6) && R4({ actual: e7, expected: n6, message: r6, operator: "notDeepEqual", stackStartFn: t6 });
  }, x5.deepStrictEqual = function t6(e7, n6, r6) {
    if (arguments.length < 2) throw new y7("actual", "expected");
    void 0 === a5 && j4(), u5(e7, n6) || R4({ actual: e7, expected: n6, message: r6, operator: "deepStrictEqual", stackStartFn: t6 });
  }, x5.notDeepStrictEqual = function t6(e7, n6, r6) {
    if (arguments.length < 2) throw new y7("actual", "expected");
    void 0 === a5 && j4();
    u5(e7, n6) && R4({ actual: e7, expected: n6, message: r6, operator: "notDeepStrictEqual", stackStartFn: t6 });
  }, x5.strictEqual = function t6(e7, n6, r6) {
    if (arguments.length < 2) throw new y7("actual", "expected");
    S4(e7, n6) || R4({ actual: e7, expected: n6, message: r6, operator: "strictEqual", stackStartFn: t6 });
  }, x5.notStrictEqual = function t6(e7, n6, r6) {
    if (arguments.length < 2) throw new y7("actual", "expected");
    S4(e7, n6) && R4({ actual: e7, expected: n6, message: r6, operator: "notStrictEqual", stackStartFn: t6 });
  };
  var _4 = function t6(e7, n6, r6) {
    var o6 = this;
    !function(t7, e8) {
      if (!(t7 instanceof e8)) throw new TypeError("Cannot call a class as a function");
    }(this, t6), n6.forEach(function(t7) {
      t7 in e7 && (void 0 !== r6 && "string" == typeof r6[t7] && E4(e7[t7]) && e7[t7].test(r6[t7]) ? o6[t7] = r6[t7] : o6[t7] = e7[t7]);
    });
  };
  function T5(t6, e7, n6, r6, o6, c6) {
    if (!(n6 in t6) || !u5(t6[n6], e7[n6])) {
      if (!r6) {
        var a6 = new _4(t6, o6), i5 = new _4(e7, o6, t6), l6 = new b6({ actual: a6, expected: i5, operator: "deepStrictEqual", stackStartFn: c6 });
        throw l6.actual = t6, l6.expected = e7, l6.operator = c6.name, l6;
      }
      R4({ actual: t6, expected: e7, message: r6, operator: c6.name, stackStartFn: c6 });
    }
  }
  function P5(t6, e7, n6, r6) {
    if ("function" != typeof e7) {
      if (E4(e7)) return e7.test(t6);
      if (2 === arguments.length) throw new p5("expected", ["Function", "RegExp"], e7);
      if ("object" !== c5(t6) || null === t6) {
        var o6 = new b6({ actual: t6, expected: e7, message: n6, operator: "deepStrictEqual", stackStartFn: r6 });
        throw o6.operator = r6.name, o6;
      }
      var i5 = Object.keys(e7);
      if (e7 instanceof Error) i5.push("name", "message");
      else if (0 === i5.length) throw new g5("error", e7, "may not be an empty object");
      return void 0 === a5 && j4(), i5.forEach(function(o7) {
        "string" == typeof t6[o7] && E4(e7[o7]) && e7[o7].test(t6[o7]) || T5(t6, e7, o7, n6, i5, r6);
      }), true;
    }
    return void 0 !== e7.prototype && t6 instanceof e7 || !Error.isPrototypeOf(e7) && true === e7.call({}, t6);
  }
  function I4(t6) {
    if ("function" != typeof t6) throw new p5("fn", "Function", t6);
    try {
      t6();
    } catch (t7) {
      return t7;
    }
    return q6;
  }
  function D5(t6) {
    return m$13(t6) || null !== t6 && "object" === c5(t6) && "function" == typeof t6.then && "function" == typeof t6.catch;
  }
  function F5(t6) {
    return Promise.resolve().then(function() {
      var e7;
      if ("function" == typeof t6) {
        if (!D5(e7 = t6())) throw new h6("instance of Promise", "promiseFn", e7);
      } else {
        if (!D5(t6)) throw new p5("promiseFn", ["Function", "Promise"], t6);
        e7 = t6;
      }
      return Promise.resolve().then(function() {
        return e7;
      }).then(function() {
        return q6;
      }).catch(function(t7) {
        return t7;
      });
    });
  }
  function N4(t6, e7, n6, r6) {
    if ("string" == typeof n6) {
      if (4 === arguments.length) throw new p5("error", ["Object", "Error", "Function", "RegExp"], n6);
      if ("object" === c5(e7) && null !== e7) {
        if (e7.message === n6) throw new s5("error/message", 'The error message "'.concat(e7.message, '" is identical to the message.'));
      } else if (e7 === n6) throw new s5("error/message", 'The error "'.concat(e7, '" is identical to the message.'));
      r6 = n6, n6 = void 0;
    } else if (null != n6 && "object" !== c5(n6) && "function" != typeof n6) throw new p5("error", ["Object", "Error", "Function", "RegExp"], n6);
    if (e7 === q6) {
      var o6 = "";
      n6 && n6.name && (o6 += " (".concat(n6.name, ")")), o6 += r6 ? ": ".concat(r6) : ".";
      var a6 = "rejects" === t6.name ? "rejection" : "exception";
      R4({ actual: void 0, expected: n6, operator: t6.name, message: "Missing expected ".concat(a6).concat(o6), stackStartFn: t6 });
    }
    if (n6 && !P5(e7, n6, r6, t6)) throw e7;
  }
  function L5(t6, e7, n6, r6) {
    if (e7 !== q6) {
      if ("string" == typeof n6 && (r6 = n6, n6 = void 0), !n6 || P5(e7, n6)) {
        var o6 = r6 ? ": ".concat(r6) : ".", c6 = "doesNotReject" === t6.name ? "rejection" : "exception";
        R4({ actual: e7, expected: n6, operator: t6.name, message: "Got unwanted ".concat(c6).concat(o6, "\n") + 'Actual message: "'.concat(e7 && e7.message, '"'), stackStartFn: t6 });
      }
      throw e7;
    }
  }
  function M4() {
    for (var t6 = arguments.length, e7 = new Array(t6), n6 = 0; n6 < t6; n6++) e7[n6] = arguments[n6];
    A4.apply(void 0, [M4, e7.length].concat(e7));
  }
  return x5.throws = function t6(e7) {
    for (var n6 = arguments.length, r6 = new Array(n6 > 1 ? n6 - 1 : 0), o6 = 1; o6 < n6; o6++) r6[o6 - 1] = arguments[o6];
    N4.apply(void 0, [t6, I4(e7)].concat(r6));
  }, x5.rejects = function t6(e7) {
    for (var n6 = arguments.length, r6 = new Array(n6 > 1 ? n6 - 1 : 0), o6 = 1; o6 < n6; o6++) r6[o6 - 1] = arguments[o6];
    return F5(e7).then(function(e8) {
      return N4.apply(void 0, [t6, e8].concat(r6));
    });
  }, x5.doesNotThrow = function t6(e7) {
    for (var n6 = arguments.length, r6 = new Array(n6 > 1 ? n6 - 1 : 0), o6 = 1; o6 < n6; o6++) r6[o6 - 1] = arguments[o6];
    L5.apply(void 0, [t6, I4(e7)].concat(r6));
  }, x5.doesNotReject = function t6(e7) {
    for (var n6 = arguments.length, r6 = new Array(n6 > 1 ? n6 - 1 : 0), o6 = 1; o6 < n6; o6++) r6[o6 - 1] = arguments[o6];
    return F5(e7).then(function(e8) {
      return L5.apply(void 0, [t6, e8].concat(r6));
    });
  }, x5.ifError = function t6(e7) {
    if (null != e7) {
      var n6 = "ifError got unwanted exception: ";
      "object" === c5(e7) && "string" == typeof e7.message ? 0 === e7.message.length && e7.constructor ? n6 += e7.constructor.name : n6 += e7.message : n6 += v11(e7);
      var r6 = new b6({ actual: e7, expected: null, operator: "ifError", message: n6, stackStartFn: t6 }), o6 = e7.stack;
      if ("string" == typeof o6) {
        var a6 = o6.split("\n");
        a6.shift();
        for (var i5 = r6.stack.split("\n"), u6 = 0; u6 < a6.length; u6++) {
          var l6 = i5.indexOf(a6[u6]);
          if (-1 !== l6) {
            i5 = i5.slice(0, l6);
            break;
          }
        }
        r6.stack = "".concat(i5.join("\n"), "\n").concat(a6.join("\n"));
      }
      throw r6;
    }
  }, x5.strict = w5(M4, x5, { equal: x5.strictEqual, deepEqual: x5.deepStrictEqual, notEqual: x5.notStrictEqual, notDeepEqual: x5.notDeepStrictEqual }), x5.strict.strict = x5.strict, Z2;
}
var et = tt();
et.AssertionError;
et.deepEqual;
et.deepStrictEqual;
et.doesNotReject;
et.doesNotThrow;
et.equal;
et.fail;
et.ifError;
et.notDeepEqual;
et.notDeepStrictEqual;
et.notEqual;
et.notStrictEqual;
et.ok;
et.rejects;
et.strict;
et.strictEqual;
et.throws;
et.AssertionError;
et.deepEqual;
et.deepStrictEqual;
et.doesNotReject;
et.doesNotThrow;
et.equal;
et.fail;
et.ifError;
et.notDeepEqual;
et.notDeepStrictEqual;
et.notEqual;
et.notStrictEqual;
et.ok;
et.rejects;
et.strict;
et.strictEqual;
et.throws;
et.AssertionError;
et.deepEqual;
et.deepStrictEqual;
et.doesNotReject;
et.doesNotThrow;
et.equal;
et.fail;
et.ifError;
et.notDeepEqual;
et.notDeepStrictEqual;
et.notEqual;
et.notStrictEqual;
et.ok;
et.rejects;
et.strict;
et.strictEqual;
et.throws;

// node_modules/@jspm/core/nodelibs/browser/chunk-CbQqNoLO.js
X._extend;
X.callbackify;
X.debuglog;
X.deprecate;
X.format;
X.inherits;
X.inspect;
X.isArray;
X.isBoolean;
X.isBuffer;
X.isDate;
X.isError;
X.isFunction;
X.isNull;
X.isNullOrUndefined;
X.isNumber;
X.isObject;
X.isPrimitive;
X.isRegExp;
X.isString;
X.isSymbol;
X.isUndefined;
X.log;
var promisify2 = X.promisify;
X.types;
X.TextEncoder = globalThis.TextEncoder;
X.TextDecoder = globalThis.TextDecoder;

// node_modules/@jspm/core/nodelibs/browser/chunk-b0rmRow7.js
var exports3 = {};
var _dewExec2 = false;
var _global = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
function dew2() {
  if (_dewExec2) return exports3;
  _dewExec2 = true;
  var process4 = exports3 = {};
  var cachedSetTimeout;
  var cachedClearTimeout;
  function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
  }
  function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
  }
  (function() {
    try {
      if (typeof setTimeout === "function") {
        cachedSetTimeout = setTimeout;
      } else {
        cachedSetTimeout = defaultSetTimout;
      }
    } catch (e7) {
      cachedSetTimeout = defaultSetTimout;
    }
    try {
      if (typeof clearTimeout === "function") {
        cachedClearTimeout = clearTimeout;
      } else {
        cachedClearTimeout = defaultClearTimeout;
      }
    } catch (e7) {
      cachedClearTimeout = defaultClearTimeout;
    }
  })();
  function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
      return setTimeout(fun, 0);
    }
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
      cachedSetTimeout = setTimeout;
      return setTimeout(fun, 0);
    }
    try {
      return cachedSetTimeout(fun, 0);
    } catch (e7) {
      try {
        return cachedSetTimeout.call(null, fun, 0);
      } catch (e8) {
        return cachedSetTimeout.call(this || _global, fun, 0);
      }
    }
  }
  function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
      return clearTimeout(marker);
    }
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
      cachedClearTimeout = clearTimeout;
      return clearTimeout(marker);
    }
    try {
      return cachedClearTimeout(marker);
    } catch (e7) {
      try {
        return cachedClearTimeout.call(null, marker);
      } catch (e8) {
        return cachedClearTimeout.call(this || _global, marker);
      }
    }
  }
  var queue3 = [];
  var draining3 = false;
  var currentQueue3;
  var queueIndex3 = -1;
  function cleanUpNextTick3() {
    if (!draining3 || !currentQueue3) {
      return;
    }
    draining3 = false;
    if (currentQueue3.length) {
      queue3 = currentQueue3.concat(queue3);
    } else {
      queueIndex3 = -1;
    }
    if (queue3.length) {
      drainQueue3();
    }
  }
  function drainQueue3() {
    if (draining3) {
      return;
    }
    var timeout = runTimeout(cleanUpNextTick3);
    draining3 = true;
    var len = queue3.length;
    while (len) {
      currentQueue3 = queue3;
      queue3 = [];
      while (++queueIndex3 < len) {
        if (currentQueue3) {
          currentQueue3[queueIndex3].run();
        }
      }
      queueIndex3 = -1;
      len = queue3.length;
    }
    currentQueue3 = null;
    draining3 = false;
    runClearTimeout(timeout);
  }
  process4.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i5 = 1; i5 < arguments.length; i5++) {
        args[i5 - 1] = arguments[i5];
      }
    }
    queue3.push(new Item3(fun, args));
    if (queue3.length === 1 && !draining3) {
      runTimeout(drainQueue3);
    }
  };
  function Item3(fun, array) {
    (this || _global).fun = fun;
    (this || _global).array = array;
  }
  Item3.prototype.run = function() {
    (this || _global).fun.apply(null, (this || _global).array);
  };
  process4.title = "browser";
  process4.browser = true;
  process4.env = {};
  process4.argv = [];
  process4.version = "";
  process4.versions = {};
  function noop3() {
  }
  process4.on = noop3;
  process4.addListener = noop3;
  process4.once = noop3;
  process4.off = noop3;
  process4.removeListener = noop3;
  process4.removeAllListeners = noop3;
  process4.emit = noop3;
  process4.prependListener = noop3;
  process4.prependOnceListener = noop3;
  process4.listeners = function(name2) {
    return [];
  };
  process4.binding = function(name2) {
    throw new Error("process.binding is not supported");
  };
  process4.cwd = function() {
    return "/";
  };
  process4.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
  };
  process4.umask = function() {
    return 0;
  };
  return exports3;
}
var process2 = dew2();
process2.platform = "browser";
process2.addListener;
process2.argv;
process2.binding;
process2.browser;
process2.chdir;
process2.cwd;
process2.emit;
process2.env;
process2.listeners;
process2.nextTick;
process2.off;
process2.on;
process2.once;
process2.prependListener;
process2.prependOnceListener;
process2.removeAllListeners;
process2.removeListener;
process2.title;
process2.umask;
process2.version;
process2.versions;

// node_modules/@jspm/core/nodelibs/browser/chunk-DHWh-hmB.js
var exports$12 = {};
var _dewExec$12 = false;
function dew$12() {
  if (_dewExec$12) return exports$12;
  _dewExec$12 = true;
  var process$1 = process2;
  function assertPath(path2) {
    if (typeof path2 !== "string") {
      throw new TypeError("Path must be a string. Received " + JSON.stringify(path2));
    }
  }
  function normalizeStringPosix(path2, allowAboveRoot) {
    var res = "";
    var lastSegmentLength = 0;
    var lastSlash = -1;
    var dots = 0;
    var code;
    for (var i5 = 0; i5 <= path2.length; ++i5) {
      if (i5 < path2.length) code = path2.charCodeAt(i5);
      else if (code === 47) break;
      else code = 47;
      if (code === 47) {
        if (lastSlash === i5 - 1 || dots === 1) ;
        else if (lastSlash !== i5 - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              var lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                }
                lastSlash = i5;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i5;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0) res += "/..";
            else res = "..";
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0) res += "/" + path2.slice(lastSlash + 1, i5);
          else res = path2.slice(lastSlash + 1, i5);
          lastSegmentLength = i5 - lastSlash - 1;
        }
        lastSlash = i5;
        dots = 0;
      } else if (code === 46 && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  function _format(sep2, pathObject) {
    var dir = pathObject.dir || pathObject.root;
    var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) {
      return base;
    }
    if (dir === pathObject.root) {
      return dir + base;
    }
    return dir + sep2 + base;
  }
  var posix2 = {
    // path.resolve([from ...], to)
    resolve: function resolve3() {
      var resolvedPath = "";
      var resolvedAbsolute = false;
      var cwd3;
      for (var i5 = arguments.length - 1; i5 >= -1 && !resolvedAbsolute; i5--) {
        var path2;
        if (i5 >= 0) path2 = arguments[i5];
        else {
          if (cwd3 === void 0) cwd3 = process$1.cwd();
          path2 = cwd3;
        }
        assertPath(path2);
        if (path2.length === 0) {
          continue;
        }
        resolvedPath = path2 + "/" + resolvedPath;
        resolvedAbsolute = path2.charCodeAt(0) === 47;
      }
      resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
      if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return "/" + resolvedPath;
        else return "/";
      } else if (resolvedPath.length > 0) {
        return resolvedPath;
      } else {
        return ".";
      }
    },
    normalize: function normalize2(path2) {
      assertPath(path2);
      if (path2.length === 0) return ".";
      var isAbsolute2 = path2.charCodeAt(0) === 47;
      var trailingSeparator = path2.charCodeAt(path2.length - 1) === 47;
      path2 = normalizeStringPosix(path2, !isAbsolute2);
      if (path2.length === 0 && !isAbsolute2) path2 = ".";
      if (path2.length > 0 && trailingSeparator) path2 += "/";
      if (isAbsolute2) return "/" + path2;
      return path2;
    },
    isAbsolute: function isAbsolute2(path2) {
      assertPath(path2);
      return path2.length > 0 && path2.charCodeAt(0) === 47;
    },
    join: function join2() {
      if (arguments.length === 0) return ".";
      var joined;
      for (var i5 = 0; i5 < arguments.length; ++i5) {
        var arg = arguments[i5];
        assertPath(arg);
        if (arg.length > 0) {
          if (joined === void 0) joined = arg;
          else joined += "/" + arg;
        }
      }
      if (joined === void 0) return ".";
      return posix2.normalize(joined);
    },
    relative: function relative2(from, to) {
      assertPath(from);
      assertPath(to);
      if (from === to) return "";
      from = posix2.resolve(from);
      to = posix2.resolve(to);
      if (from === to) return "";
      var fromStart = 1;
      for (; fromStart < from.length; ++fromStart) {
        if (from.charCodeAt(fromStart) !== 47) break;
      }
      var fromEnd = from.length;
      var fromLen = fromEnd - fromStart;
      var toStart = 1;
      for (; toStart < to.length; ++toStart) {
        if (to.charCodeAt(toStart) !== 47) break;
      }
      var toEnd = to.length;
      var toLen = toEnd - toStart;
      var length = fromLen < toLen ? fromLen : toLen;
      var lastCommonSep = -1;
      var i5 = 0;
      for (; i5 <= length; ++i5) {
        if (i5 === length) {
          if (toLen > length) {
            if (to.charCodeAt(toStart + i5) === 47) {
              return to.slice(toStart + i5 + 1);
            } else if (i5 === 0) {
              return to.slice(toStart + i5);
            }
          } else if (fromLen > length) {
            if (from.charCodeAt(fromStart + i5) === 47) {
              lastCommonSep = i5;
            } else if (i5 === 0) {
              lastCommonSep = 0;
            }
          }
          break;
        }
        var fromCode = from.charCodeAt(fromStart + i5);
        var toCode = to.charCodeAt(toStart + i5);
        if (fromCode !== toCode) break;
        else if (fromCode === 47) lastCommonSep = i5;
      }
      var out = "";
      for (i5 = fromStart + lastCommonSep + 1; i5 <= fromEnd; ++i5) {
        if (i5 === fromEnd || from.charCodeAt(i5) === 47) {
          if (out.length === 0) out += "..";
          else out += "/..";
        }
      }
      if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
      else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) ++toStart;
        return to.slice(toStart);
      }
    },
    _makeLong: function _makeLong2(path2) {
      return path2;
    },
    dirname: function dirname2(path2) {
      assertPath(path2);
      if (path2.length === 0) return ".";
      var code = path2.charCodeAt(0);
      var hasRoot = code === 47;
      var end = -1;
      var matchedSlash = true;
      for (var i5 = path2.length - 1; i5 >= 1; --i5) {
        code = path2.charCodeAt(i5);
        if (code === 47) {
          if (!matchedSlash) {
            end = i5;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1) return hasRoot ? "/" : ".";
      if (hasRoot && end === 1) return "//";
      return path2.slice(0, end);
    },
    basename: function basename2(path2, ext) {
      if (ext !== void 0 && typeof ext !== "string") throw new TypeError('"ext" argument must be a string');
      assertPath(path2);
      var start = 0;
      var end = -1;
      var matchedSlash = true;
      var i5;
      if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
        if (ext.length === path2.length && ext === path2) return "";
        var extIdx = ext.length - 1;
        var firstNonSlashEnd = -1;
        for (i5 = path2.length - 1; i5 >= 0; --i5) {
          var code = path2.charCodeAt(i5);
          if (code === 47) {
            if (!matchedSlash) {
              start = i5 + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i5 + 1;
            }
            if (extIdx >= 0) {
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end = i5;
                }
              } else {
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path2.length;
        return path2.slice(start, end);
      } else {
        for (i5 = path2.length - 1; i5 >= 0; --i5) {
          if (path2.charCodeAt(i5) === 47) {
            if (!matchedSlash) {
              start = i5 + 1;
              break;
            }
          } else if (end === -1) {
            matchedSlash = false;
            end = i5 + 1;
          }
        }
        if (end === -1) return "";
        return path2.slice(start, end);
      }
    },
    extname: function extname2(path2) {
      assertPath(path2);
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var preDotState = 0;
      for (var i5 = path2.length - 1; i5 >= 0; --i5) {
        var code = path2.charCodeAt(i5);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i5 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i5 + 1;
        }
        if (code === 46) {
          if (startDot === -1) startDot = i5;
          else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
      }
      return path2.slice(startDot, end);
    },
    format: function format3(pathObject) {
      if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
      }
      return _format("/", pathObject);
    },
    parse: function parse3(path2) {
      assertPath(path2);
      var ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
      };
      if (path2.length === 0) return ret;
      var code = path2.charCodeAt(0);
      var isAbsolute2 = code === 47;
      var start;
      if (isAbsolute2) {
        ret.root = "/";
        start = 1;
      } else {
        start = 0;
      }
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var i5 = path2.length - 1;
      var preDotState = 0;
      for (; i5 >= start; --i5) {
        code = path2.charCodeAt(i5);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i5 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i5 + 1;
        }
        if (code === 46) {
          if (startDot === -1) startDot = i5;
          else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
          if (startPart === 0 && isAbsolute2) ret.base = ret.name = path2.slice(1, end);
          else ret.base = ret.name = path2.slice(startPart, end);
        }
      } else {
        if (startPart === 0 && isAbsolute2) {
          ret.name = path2.slice(1, startDot);
          ret.base = path2.slice(1, end);
        } else {
          ret.name = path2.slice(startPart, startDot);
          ret.base = path2.slice(startPart, end);
        }
        ret.ext = path2.slice(startDot, end);
      }
      if (startPart > 0) ret.dir = path2.slice(0, startPart - 1);
      else if (isAbsolute2) ret.dir = "/";
      return ret;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  posix2.posix = posix2;
  exports$12 = posix2;
  return exports$12;
}
var exports$22 = dew$12();
var t$13 = 2147483647;
var o$23 = /^xn--/;
var n$23 = /[^\0-\x7E]/;
var e$23 = /[\x2E\u3002\uFF0E\uFF61]/g;
var r$23 = { overflow: "Overflow: input needs wider integers to process", "not-basic": "Illegal input >= 0x80 (not a basic code point)", "invalid-input": "Invalid input" };
var c$13 = Math.floor;
var s2 = String.fromCharCode;
function i$13(t6) {
  throw new RangeError(r$23[t6]);
}
function f$13(t6, o5) {
  const n6 = t6.split("@");
  let r6 = "";
  n6.length > 1 && (r6 = n6[0] + "@", t6 = n6[1]);
  const c5 = function(t7, o6) {
    const n7 = [];
    let e7 = t7.length;
    for (; e7--; ) n7[e7] = o6(t7[e7]);
    return n7;
  }((t6 = t6.replace(e$23, ".")).split("."), o5).join(".");
  return r6 + c5;
}
function l$13(t6) {
  const o5 = [];
  let n6 = 0;
  const e7 = t6.length;
  for (; n6 < e7; ) {
    const r6 = t6.charCodeAt(n6++);
    if (r6 >= 55296 && r6 <= 56319 && n6 < e7) {
      const e8 = t6.charCodeAt(n6++);
      56320 == (64512 & e8) ? o5.push(((1023 & r6) << 10) + (1023 & e8) + 65536) : (o5.push(r6), n6--);
    } else o5.push(r6);
  }
  return o5;
}
var u$13 = function(t6, o5) {
  return t6 + 22 + 75 * (t6 < 26) - ((0 != o5) << 5);
};
var a$13 = function(t6, o5, n6) {
  let e7 = 0;
  for (t6 = n6 ? c$13(t6 / 700) : t6 >> 1, t6 += c$13(t6 / o5); t6 > 455; e7 += 36) t6 = c$13(t6 / 35);
  return c$13(e7 + 36 * t6 / (t6 + 38));
};
var d3 = function(o5) {
  const n6 = [], e7 = o5.length;
  let r6 = 0, s5 = 128, f5 = 72, l5 = o5.lastIndexOf("-");
  l5 < 0 && (l5 = 0);
  for (let t6 = 0; t6 < l5; ++t6) o5.charCodeAt(t6) >= 128 && i$13("not-basic"), n6.push(o5.charCodeAt(t6));
  for (let d5 = l5 > 0 ? l5 + 1 : 0; d5 < e7; ) {
    let l6 = r6;
    for (let n7 = 1, s6 = 36; ; s6 += 36) {
      d5 >= e7 && i$13("invalid-input");
      const l7 = (u5 = o5.charCodeAt(d5++)) - 48 < 10 ? u5 - 22 : u5 - 65 < 26 ? u5 - 65 : u5 - 97 < 26 ? u5 - 97 : 36;
      (l7 >= 36 || l7 > c$13((t$13 - r6) / n7)) && i$13("overflow"), r6 += l7 * n7;
      const a5 = s6 <= f5 ? 1 : s6 >= f5 + 26 ? 26 : s6 - f5;
      if (l7 < a5) break;
      const h7 = 36 - a5;
      n7 > c$13(t$13 / h7) && i$13("overflow"), n7 *= h7;
    }
    const h6 = n6.length + 1;
    f5 = a$13(r6 - l6, h6, 0 == l6), c$13(r6 / h6) > t$13 - s5 && i$13("overflow"), s5 += c$13(r6 / h6), r6 %= h6, n6.splice(r6++, 0, s5);
  }
  var u5;
  return String.fromCodePoint(...n6);
};
var h$13 = function(o5) {
  const n6 = [];
  let e7 = (o5 = l$13(o5)).length, r6 = 128, f5 = 0, d5 = 72;
  for (const t6 of o5) t6 < 128 && n6.push(s2(t6));
  let h6 = n6.length, p5 = h6;
  for (h6 && n6.push("-"); p5 < e7; ) {
    let e8 = t$13;
    for (const t6 of o5) t6 >= r6 && t6 < e8 && (e8 = t6);
    const l5 = p5 + 1;
    e8 - r6 > c$13((t$13 - f5) / l5) && i$13("overflow"), f5 += (e8 - r6) * l5, r6 = e8;
    for (const e9 of o5) if (e9 < r6 && ++f5 > t$13 && i$13("overflow"), e9 == r6) {
      let t6 = f5;
      for (let o6 = 36; ; o6 += 36) {
        const e10 = o6 <= d5 ? 1 : o6 >= d5 + 26 ? 26 : o6 - d5;
        if (t6 < e10) break;
        const r7 = t6 - e10, i5 = 36 - e10;
        n6.push(s2(u$13(e10 + r7 % i5, 0))), t6 = c$13(r7 / i5);
      }
      n6.push(s2(u$13(t6, 0))), d5 = a$13(f5, l5, p5 == h6), f5 = 0, ++p5;
    }
    ++f5, ++r6;
  }
  return n6.join("");
};
var p$13 = { version: "2.1.0", ucs2: { decode: l$13, encode: (t6) => String.fromCodePoint(...t6) }, decode: d3, encode: h$13, toASCII: function(t6) {
  return f$13(t6, function(t7) {
    return n$23.test(t7) ? "xn--" + h$13(t7) : t7;
  });
}, toUnicode: function(t6) {
  return f$13(t6, function(t7) {
    return o$23.test(t7) ? d3(t7.slice(4).toLowerCase()) : t7;
  });
} };
function e$13(e7, n6) {
  return Object.prototype.hasOwnProperty.call(e7, n6);
}
var n$13 = function(n6, r6, t6, o5) {
  r6 = r6 || "&", t6 = t6 || "=";
  var a5 = {};
  if ("string" != typeof n6 || 0 === n6.length) return a5;
  var u5 = /\+/g;
  n6 = n6.split(r6);
  var c5 = 1e3;
  o5 && "number" == typeof o5.maxKeys && (c5 = o5.maxKeys);
  var i5 = n6.length;
  c5 > 0 && i5 > c5 && (i5 = c5);
  for (var s5 = 0; s5 < i5; ++s5) {
    var p5, f5, d5, y7, m7 = n6[s5].replace(u5, "%20"), l5 = m7.indexOf(t6);
    l5 >= 0 ? (p5 = m7.substr(0, l5), f5 = m7.substr(l5 + 1)) : (p5 = m7, f5 = ""), d5 = decodeURIComponent(p5), y7 = decodeURIComponent(f5), e$13(a5, d5) ? Array.isArray(a5[d5]) ? a5[d5].push(y7) : a5[d5] = [a5[d5], y7] : a5[d5] = y7;
  }
  return a5;
};
var r$13 = function(e7) {
  switch (typeof e7) {
    case "string":
      return e7;
    case "boolean":
      return e7 ? "true" : "false";
    case "number":
      return isFinite(e7) ? e7 : "";
    default:
      return "";
  }
};
var t3 = function(e7, n6, t6, o5) {
  return n6 = n6 || "&", t6 = t6 || "=", null === e7 && (e7 = void 0), "object" == typeof e7 ? Object.keys(e7).map(function(o6) {
    var a5 = encodeURIComponent(r$13(o6)) + t6;
    return Array.isArray(e7[o6]) ? e7[o6].map(function(e8) {
      return a5 + encodeURIComponent(r$13(e8));
    }).join(n6) : a5 + encodeURIComponent(r$13(e7[o6]));
  }).join(n6) : o5 ? encodeURIComponent(r$13(o5)) + t6 + encodeURIComponent(r$13(e7)) : "";
};
var o$13 = {};
o$13.decode = o$13.parse = n$13, o$13.encode = o$13.stringify = t3;
o$13.decode;
o$13.encode;
o$13.parse;
o$13.stringify;
var h3 = {};
var e4 = p$13;
var a2 = { isString: function(t6) {
  return "string" == typeof t6;
}, isObject: function(t6) {
  return "object" == typeof t6 && null !== t6;
}, isNull: function(t6) {
  return null === t6;
}, isNullOrUndefined: function(t6) {
  return null == t6;
} };
function r3() {
  this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null;
}
h3.parse = O4, h3.resolve = function(t6, s5) {
  return O4(t6, false, true).resolve(s5);
}, h3.resolveObject = function(t6, s5) {
  return t6 ? O4(t6, false, true).resolveObject(s5) : s5;
}, h3.format = function(t6) {
  a2.isString(t6) && (t6 = O4(t6));
  return t6 instanceof r3 ? t6.format() : r3.prototype.format.call(t6);
}, h3.Url = r3;
var o2 = /^([a-z0-9.+-]+:)/i;
var n3 = /:[0-9]*$/;
var i2 = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
var l2 = ["{", "}", "|", "\\", "^", "`"].concat(["<", ">", '"', "`", " ", "\r", "\n", "	"]);
var p2 = ["'"].concat(l2);
var c2 = ["%", "/", "?", ";", "#"].concat(p2);
var u2 = ["/", "?", "#"];
var f2 = /^[+a-z0-9A-Z_-]{0,63}$/;
var m5 = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
var v8 = { javascript: true, "javascript:": true };
var g3 = { javascript: true, "javascript:": true };
var y4 = { http: true, https: true, ftp: true, gopher: true, file: true, "http:": true, "https:": true, "ftp:": true, "gopher:": true, "file:": true };
var b4 = o$13;
function O4(t6, s5, h6) {
  if (t6 && a2.isObject(t6) && t6 instanceof r3) return t6;
  var e7 = new r3();
  return e7.parse(t6, s5, h6), e7;
}
r3.prototype.parse = function(t6, s5, h6) {
  if (!a2.isString(t6)) throw new TypeError("Parameter 'url' must be a string, not " + typeof t6);
  var r6 = t6.indexOf("?"), n6 = -1 !== r6 && r6 < t6.indexOf("#") ? "?" : "#", l5 = t6.split(n6);
  l5[0] = l5[0].replace(/\\/g, "/");
  var O6 = t6 = l5.join(n6);
  if (O6 = O6.trim(), !h6 && 1 === t6.split("#").length) {
    var d5 = i2.exec(O6);
    if (d5) return this.path = O6, this.href = O6, this.pathname = d5[1], d5[2] ? (this.search = d5[2], this.query = s5 ? b4.parse(this.search.substr(1)) : this.search.substr(1)) : s5 && (this.search = "", this.query = {}), this;
  }
  var j4 = o2.exec(O6);
  if (j4) {
    var q6 = (j4 = j4[0]).toLowerCase();
    this.protocol = q6, O6 = O6.substr(j4.length);
  }
  if (h6 || j4 || O6.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var x5 = "//" === O6.substr(0, 2);
    !x5 || j4 && g3[j4] || (O6 = O6.substr(2), this.slashes = true);
  }
  if (!g3[j4] && (x5 || j4 && !y4[j4])) {
    for (var A4, C4, I4 = -1, w5 = 0; w5 < u2.length; w5++) {
      -1 !== (N4 = O6.indexOf(u2[w5])) && (-1 === I4 || N4 < I4) && (I4 = N4);
    }
    -1 !== (C4 = -1 === I4 ? O6.lastIndexOf("@") : O6.lastIndexOf("@", I4)) && (A4 = O6.slice(0, C4), O6 = O6.slice(C4 + 1), this.auth = decodeURIComponent(A4)), I4 = -1;
    for (w5 = 0; w5 < c2.length; w5++) {
      var N4;
      -1 !== (N4 = O6.indexOf(c2[w5])) && (-1 === I4 || N4 < I4) && (I4 = N4);
    }
    -1 === I4 && (I4 = O6.length), this.host = O6.slice(0, I4), O6 = O6.slice(I4), this.parseHost(), this.hostname = this.hostname || "";
    var U5 = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
    if (!U5) for (var k5 = this.hostname.split(/\./), S4 = (w5 = 0, k5.length); w5 < S4; w5++) {
      var R4 = k5[w5];
      if (R4 && !R4.match(f2)) {
        for (var $3 = "", z4 = 0, H4 = R4.length; z4 < H4; z4++) R4.charCodeAt(z4) > 127 ? $3 += "x" : $3 += R4[z4];
        if (!$3.match(f2)) {
          var L5 = k5.slice(0, w5), Z3 = k5.slice(w5 + 1), _4 = R4.match(m5);
          _4 && (L5.push(_4[1]), Z3.unshift(_4[2])), Z3.length && (O6 = "/" + Z3.join(".") + O6), this.hostname = L5.join(".");
          break;
        }
      }
    }
    this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), U5 || (this.hostname = e4.toASCII(this.hostname));
    var E4 = this.port ? ":" + this.port : "", P5 = this.hostname || "";
    this.host = P5 + E4, this.href += this.host, U5 && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), "/" !== O6[0] && (O6 = "/" + O6));
  }
  if (!v8[q6]) for (w5 = 0, S4 = p2.length; w5 < S4; w5++) {
    var T5 = p2[w5];
    if (-1 !== O6.indexOf(T5)) {
      var B5 = encodeURIComponent(T5);
      B5 === T5 && (B5 = escape(T5)), O6 = O6.split(T5).join(B5);
    }
  }
  var D5 = O6.indexOf("#");
  -1 !== D5 && (this.hash = O6.substr(D5), O6 = O6.slice(0, D5));
  var F5 = O6.indexOf("?");
  if (-1 !== F5 ? (this.search = O6.substr(F5), this.query = O6.substr(F5 + 1), s5 && (this.query = b4.parse(this.query)), O6 = O6.slice(0, F5)) : s5 && (this.search = "", this.query = {}), O6 && (this.pathname = O6), y4[q6] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
    E4 = this.pathname || "";
    var G3 = this.search || "";
    this.path = E4 + G3;
  }
  return this.href = this.format(), this;
}, r3.prototype.format = function() {
  var t6 = this.auth || "";
  t6 && (t6 = (t6 = encodeURIComponent(t6)).replace(/%3A/i, ":"), t6 += "@");
  var s5 = this.protocol || "", h6 = this.pathname || "", e7 = this.hash || "", r6 = false, o5 = "";
  this.host ? r6 = t6 + this.host : this.hostname && (r6 = t6 + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), this.port && (r6 += ":" + this.port)), this.query && a2.isObject(this.query) && Object.keys(this.query).length && (o5 = b4.stringify(this.query));
  var n6 = this.search || o5 && "?" + o5 || "";
  return s5 && ":" !== s5.substr(-1) && (s5 += ":"), this.slashes || (!s5 || y4[s5]) && false !== r6 ? (r6 = "//" + (r6 || ""), h6 && "/" !== h6.charAt(0) && (h6 = "/" + h6)) : r6 || (r6 = ""), e7 && "#" !== e7.charAt(0) && (e7 = "#" + e7), n6 && "?" !== n6.charAt(0) && (n6 = "?" + n6), s5 + r6 + (h6 = h6.replace(/[?#]/g, function(t7) {
    return encodeURIComponent(t7);
  })) + (n6 = n6.replace("#", "%23")) + e7;
}, r3.prototype.resolve = function(t6) {
  return this.resolveObject(O4(t6, false, true)).format();
}, r3.prototype.resolveObject = function(t6) {
  if (a2.isString(t6)) {
    var s5 = new r3();
    s5.parse(t6, false, true), t6 = s5;
  }
  for (var h6 = new r3(), e7 = Object.keys(this), o5 = 0; o5 < e7.length; o5++) {
    var n6 = e7[o5];
    h6[n6] = this[n6];
  }
  if (h6.hash = t6.hash, "" === t6.href) return h6.href = h6.format(), h6;
  if (t6.slashes && !t6.protocol) {
    for (var i5 = Object.keys(t6), l5 = 0; l5 < i5.length; l5++) {
      var p5 = i5[l5];
      "protocol" !== p5 && (h6[p5] = t6[p5]);
    }
    return y4[h6.protocol] && h6.hostname && !h6.pathname && (h6.path = h6.pathname = "/"), h6.href = h6.format(), h6;
  }
  if (t6.protocol && t6.protocol !== h6.protocol) {
    if (!y4[t6.protocol]) {
      for (var c5 = Object.keys(t6), u5 = 0; u5 < c5.length; u5++) {
        var f5 = c5[u5];
        h6[f5] = t6[f5];
      }
      return h6.href = h6.format(), h6;
    }
    if (h6.protocol = t6.protocol, t6.host || g3[t6.protocol]) h6.pathname = t6.pathname;
    else {
      for (var m7 = (t6.pathname || "").split("/"); m7.length && !(t6.host = m7.shift()); ) ;
      t6.host || (t6.host = ""), t6.hostname || (t6.hostname = ""), "" !== m7[0] && m7.unshift(""), m7.length < 2 && m7.unshift(""), h6.pathname = m7.join("/");
    }
    if (h6.search = t6.search, h6.query = t6.query, h6.host = t6.host || "", h6.auth = t6.auth, h6.hostname = t6.hostname || t6.host, h6.port = t6.port, h6.pathname || h6.search) {
      var v11 = h6.pathname || "", b6 = h6.search || "";
      h6.path = v11 + b6;
    }
    return h6.slashes = h6.slashes || t6.slashes, h6.href = h6.format(), h6;
  }
  var O6 = h6.pathname && "/" === h6.pathname.charAt(0), d5 = t6.host || t6.pathname && "/" === t6.pathname.charAt(0), j4 = d5 || O6 || h6.host && t6.pathname, q6 = j4, x5 = h6.pathname && h6.pathname.split("/") || [], A4 = (m7 = t6.pathname && t6.pathname.split("/") || [], h6.protocol && !y4[h6.protocol]);
  if (A4 && (h6.hostname = "", h6.port = null, h6.host && ("" === x5[0] ? x5[0] = h6.host : x5.unshift(h6.host)), h6.host = "", t6.protocol && (t6.hostname = null, t6.port = null, t6.host && ("" === m7[0] ? m7[0] = t6.host : m7.unshift(t6.host)), t6.host = null), j4 = j4 && ("" === m7[0] || "" === x5[0])), d5) h6.host = t6.host || "" === t6.host ? t6.host : h6.host, h6.hostname = t6.hostname || "" === t6.hostname ? t6.hostname : h6.hostname, h6.search = t6.search, h6.query = t6.query, x5 = m7;
  else if (m7.length) x5 || (x5 = []), x5.pop(), x5 = x5.concat(m7), h6.search = t6.search, h6.query = t6.query;
  else if (!a2.isNullOrUndefined(t6.search)) {
    if (A4) h6.hostname = h6.host = x5.shift(), (U5 = !!(h6.host && h6.host.indexOf("@") > 0) && h6.host.split("@")) && (h6.auth = U5.shift(), h6.host = h6.hostname = U5.shift());
    return h6.search = t6.search, h6.query = t6.query, a2.isNull(h6.pathname) && a2.isNull(h6.search) || (h6.path = (h6.pathname ? h6.pathname : "") + (h6.search ? h6.search : "")), h6.href = h6.format(), h6;
  }
  if (!x5.length) return h6.pathname = null, h6.search ? h6.path = "/" + h6.search : h6.path = null, h6.href = h6.format(), h6;
  for (var C4 = x5.slice(-1)[0], I4 = (h6.host || t6.host || x5.length > 1) && ("." === C4 || ".." === C4) || "" === C4, w5 = 0, N4 = x5.length; N4 >= 0; N4--) "." === (C4 = x5[N4]) ? x5.splice(N4, 1) : ".." === C4 ? (x5.splice(N4, 1), w5++) : w5 && (x5.splice(N4, 1), w5--);
  if (!j4 && !q6) for (; w5--; w5) x5.unshift("..");
  !j4 || "" === x5[0] || x5[0] && "/" === x5[0].charAt(0) || x5.unshift(""), I4 && "/" !== x5.join("/").substr(-1) && x5.push("");
  var U5, k5 = "" === x5[0] || x5[0] && "/" === x5[0].charAt(0);
  A4 && (h6.hostname = h6.host = k5 ? "" : x5.length ? x5.shift() : "", (U5 = !!(h6.host && h6.host.indexOf("@") > 0) && h6.host.split("@")) && (h6.auth = U5.shift(), h6.host = h6.hostname = U5.shift()));
  return (j4 = j4 || h6.host && x5.length) && !k5 && x5.unshift(""), x5.length ? h6.pathname = x5.join("/") : (h6.pathname = null, h6.path = null), a2.isNull(h6.pathname) && a2.isNull(h6.search) || (h6.path = (h6.pathname ? h6.pathname : "") + (h6.search ? h6.search : "")), h6.auth = t6.auth || h6.auth, h6.slashes = h6.slashes || t6.slashes, h6.href = h6.format(), h6;
}, r3.prototype.parseHost = function() {
  var t6 = this.host, s5 = n3.exec(t6);
  s5 && (":" !== (s5 = s5[0]) && (this.port = s5.substr(1)), t6 = t6.substr(0, t6.length - s5.length)), t6 && (this.hostname = t6);
};
h3.Url;
h3.format;
h3.resolve;
h3.resolveObject;
var exports4 = {};
var _dewExec3 = false;
function dew3() {
  if (_dewExec3) return exports4;
  _dewExec3 = true;
  var process4 = T$1;
  function assertPath(path2) {
    if (typeof path2 !== "string") {
      throw new TypeError("Path must be a string. Received " + JSON.stringify(path2));
    }
  }
  function normalizeStringPosix(path2, allowAboveRoot) {
    var res = "";
    var lastSegmentLength = 0;
    var lastSlash = -1;
    var dots = 0;
    var code;
    for (var i5 = 0; i5 <= path2.length; ++i5) {
      if (i5 < path2.length) code = path2.charCodeAt(i5);
      else if (code === 47) break;
      else code = 47;
      if (code === 47) {
        if (lastSlash === i5 - 1 || dots === 1) ;
        else if (lastSlash !== i5 - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              var lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                }
                lastSlash = i5;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i5;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0) res += "/..";
            else res = "..";
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0) res += "/" + path2.slice(lastSlash + 1, i5);
          else res = path2.slice(lastSlash + 1, i5);
          lastSegmentLength = i5 - lastSlash - 1;
        }
        lastSlash = i5;
        dots = 0;
      } else if (code === 46 && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  function _format(sep2, pathObject) {
    var dir = pathObject.dir || pathObject.root;
    var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) {
      return base;
    }
    if (dir === pathObject.root) {
      return dir + base;
    }
    return dir + sep2 + base;
  }
  var posix2 = {
    // path.resolve([from ...], to)
    resolve: function resolve3() {
      var resolvedPath = "";
      var resolvedAbsolute = false;
      var cwd3;
      for (var i5 = arguments.length - 1; i5 >= -1 && !resolvedAbsolute; i5--) {
        var path2;
        if (i5 >= 0) path2 = arguments[i5];
        else {
          if (cwd3 === void 0) cwd3 = process4.cwd();
          path2 = cwd3;
        }
        assertPath(path2);
        if (path2.length === 0) {
          continue;
        }
        resolvedPath = path2 + "/" + resolvedPath;
        resolvedAbsolute = path2.charCodeAt(0) === 47;
      }
      resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
      if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return "/" + resolvedPath;
        else return "/";
      } else if (resolvedPath.length > 0) {
        return resolvedPath;
      } else {
        return ".";
      }
    },
    normalize: function normalize2(path2) {
      assertPath(path2);
      if (path2.length === 0) return ".";
      var isAbsolute2 = path2.charCodeAt(0) === 47;
      var trailingSeparator = path2.charCodeAt(path2.length - 1) === 47;
      path2 = normalizeStringPosix(path2, !isAbsolute2);
      if (path2.length === 0 && !isAbsolute2) path2 = ".";
      if (path2.length > 0 && trailingSeparator) path2 += "/";
      if (isAbsolute2) return "/" + path2;
      return path2;
    },
    isAbsolute: function isAbsolute2(path2) {
      assertPath(path2);
      return path2.length > 0 && path2.charCodeAt(0) === 47;
    },
    join: function join2() {
      if (arguments.length === 0) return ".";
      var joined;
      for (var i5 = 0; i5 < arguments.length; ++i5) {
        var arg = arguments[i5];
        assertPath(arg);
        if (arg.length > 0) {
          if (joined === void 0) joined = arg;
          else joined += "/" + arg;
        }
      }
      if (joined === void 0) return ".";
      return posix2.normalize(joined);
    },
    relative: function relative2(from, to) {
      assertPath(from);
      assertPath(to);
      if (from === to) return "";
      from = posix2.resolve(from);
      to = posix2.resolve(to);
      if (from === to) return "";
      var fromStart = 1;
      for (; fromStart < from.length; ++fromStart) {
        if (from.charCodeAt(fromStart) !== 47) break;
      }
      var fromEnd = from.length;
      var fromLen = fromEnd - fromStart;
      var toStart = 1;
      for (; toStart < to.length; ++toStart) {
        if (to.charCodeAt(toStart) !== 47) break;
      }
      var toEnd = to.length;
      var toLen = toEnd - toStart;
      var length = fromLen < toLen ? fromLen : toLen;
      var lastCommonSep = -1;
      var i5 = 0;
      for (; i5 <= length; ++i5) {
        if (i5 === length) {
          if (toLen > length) {
            if (to.charCodeAt(toStart + i5) === 47) {
              return to.slice(toStart + i5 + 1);
            } else if (i5 === 0) {
              return to.slice(toStart + i5);
            }
          } else if (fromLen > length) {
            if (from.charCodeAt(fromStart + i5) === 47) {
              lastCommonSep = i5;
            } else if (i5 === 0) {
              lastCommonSep = 0;
            }
          }
          break;
        }
        var fromCode = from.charCodeAt(fromStart + i5);
        var toCode = to.charCodeAt(toStart + i5);
        if (fromCode !== toCode) break;
        else if (fromCode === 47) lastCommonSep = i5;
      }
      var out = "";
      for (i5 = fromStart + lastCommonSep + 1; i5 <= fromEnd; ++i5) {
        if (i5 === fromEnd || from.charCodeAt(i5) === 47) {
          if (out.length === 0) out += "..";
          else out += "/..";
        }
      }
      if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
      else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) ++toStart;
        return to.slice(toStart);
      }
    },
    _makeLong: function _makeLong2(path2) {
      return path2;
    },
    dirname: function dirname2(path2) {
      assertPath(path2);
      if (path2.length === 0) return ".";
      var code = path2.charCodeAt(0);
      var hasRoot = code === 47;
      var end = -1;
      var matchedSlash = true;
      for (var i5 = path2.length - 1; i5 >= 1; --i5) {
        code = path2.charCodeAt(i5);
        if (code === 47) {
          if (!matchedSlash) {
            end = i5;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1) return hasRoot ? "/" : ".";
      if (hasRoot && end === 1) return "//";
      return path2.slice(0, end);
    },
    basename: function basename2(path2, ext) {
      if (ext !== void 0 && typeof ext !== "string") throw new TypeError('"ext" argument must be a string');
      assertPath(path2);
      var start = 0;
      var end = -1;
      var matchedSlash = true;
      var i5;
      if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
        if (ext.length === path2.length && ext === path2) return "";
        var extIdx = ext.length - 1;
        var firstNonSlashEnd = -1;
        for (i5 = path2.length - 1; i5 >= 0; --i5) {
          var code = path2.charCodeAt(i5);
          if (code === 47) {
            if (!matchedSlash) {
              start = i5 + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i5 + 1;
            }
            if (extIdx >= 0) {
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end = i5;
                }
              } else {
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path2.length;
        return path2.slice(start, end);
      } else {
        for (i5 = path2.length - 1; i5 >= 0; --i5) {
          if (path2.charCodeAt(i5) === 47) {
            if (!matchedSlash) {
              start = i5 + 1;
              break;
            }
          } else if (end === -1) {
            matchedSlash = false;
            end = i5 + 1;
          }
        }
        if (end === -1) return "";
        return path2.slice(start, end);
      }
    },
    extname: function extname2(path2) {
      assertPath(path2);
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var preDotState = 0;
      for (var i5 = path2.length - 1; i5 >= 0; --i5) {
        var code = path2.charCodeAt(i5);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i5 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i5 + 1;
        }
        if (code === 46) {
          if (startDot === -1) startDot = i5;
          else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
      }
      return path2.slice(startDot, end);
    },
    format: function format3(pathObject) {
      if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
      }
      return _format("/", pathObject);
    },
    parse: function parse3(path2) {
      assertPath(path2);
      var ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
      };
      if (path2.length === 0) return ret;
      var code = path2.charCodeAt(0);
      var isAbsolute2 = code === 47;
      var start;
      if (isAbsolute2) {
        ret.root = "/";
        start = 1;
      } else {
        start = 0;
      }
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var i5 = path2.length - 1;
      var preDotState = 0;
      for (; i5 >= start; --i5) {
        code = path2.charCodeAt(i5);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i5 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i5 + 1;
        }
        if (code === 46) {
          if (startDot === -1) startDot = i5;
          else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
          if (startPart === 0 && isAbsolute2) ret.base = ret.name = path2.slice(1, end);
          else ret.base = ret.name = path2.slice(startPart, end);
        }
      } else {
        if (startPart === 0 && isAbsolute2) {
          ret.name = path2.slice(1, startDot);
          ret.base = path2.slice(1, end);
        } else {
          ret.name = path2.slice(startPart, startDot);
          ret.base = path2.slice(startPart, end);
        }
        ret.ext = path2.slice(startDot, end);
      }
      if (startPart > 0) ret.dir = path2.slice(0, startPart - 1);
      else if (isAbsolute2) ret.dir = "/";
      return ret;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  posix2.posix = posix2;
  exports4 = posix2;
  return exports4;
}
var path = dew3();
var processPlatform$1 = typeof Deno !== "undefined" ? Deno.build.os === "windows" ? "win32" : Deno.build.os : void 0;
h3.URL = typeof URL !== "undefined" ? URL : null;
h3.pathToFileURL = pathToFileURL$1;
h3.fileURLToPath = fileURLToPath$1;
h3.Url;
h3.format;
h3.resolve;
h3.resolveObject;
h3.URL;
var CHAR_BACKWARD_SLASH$1 = 92;
var CHAR_FORWARD_SLASH$1 = 47;
var CHAR_LOWERCASE_A$1 = 97;
var CHAR_LOWERCASE_Z$1 = 122;
var isWindows$1 = processPlatform$1 === "win32";
var forwardSlashRegEx$1 = /\//g;
var percentRegEx$1 = /%/g;
var backslashRegEx$1 = /\\/g;
var newlineRegEx$1 = /\n/g;
var carriageReturnRegEx$1 = /\r/g;
var tabRegEx$1 = /\t/g;
function fileURLToPath$1(path2) {
  if (typeof path2 === "string") path2 = new URL(path2);
  else if (!(path2 instanceof URL)) {
    throw new Deno.errors.InvalidData(
      "invalid argument path , must be a string or URL"
    );
  }
  if (path2.protocol !== "file:") {
    throw new Deno.errors.InvalidData("invalid url scheme");
  }
  return isWindows$1 ? getPathFromURLWin$1(path2) : getPathFromURLPosix$1(path2);
}
function getPathFromURLWin$1(url) {
  const hostname = url.hostname;
  let pathname = url.pathname;
  for (let n6 = 0; n6 < pathname.length; n6++) {
    if (pathname[n6] === "%") {
      const third = pathname.codePointAt(n6 + 2) || 32;
      if (pathname[n6 + 1] === "2" && third === 102 || // 2f 2F /
      pathname[n6 + 1] === "5" && third === 99) {
        throw new Deno.errors.InvalidData(
          "must not include encoded \\ or / characters"
        );
      }
    }
  }
  pathname = pathname.replace(forwardSlashRegEx$1, "\\");
  pathname = decodeURIComponent(pathname);
  if (hostname !== "") {
    return `\\\\${hostname}${pathname}`;
  } else {
    const letter = pathname.codePointAt(1) | 32;
    const sep2 = pathname[2];
    if (letter < CHAR_LOWERCASE_A$1 || letter > CHAR_LOWERCASE_Z$1 || // a..z A..Z
    sep2 !== ":") {
      throw new Deno.errors.InvalidData("file url path must be absolute");
    }
    return pathname.slice(1);
  }
}
function getPathFromURLPosix$1(url) {
  if (url.hostname !== "") {
    throw new Deno.errors.InvalidData("invalid file url hostname");
  }
  const pathname = url.pathname;
  for (let n6 = 0; n6 < pathname.length; n6++) {
    if (pathname[n6] === "%") {
      const third = pathname.codePointAt(n6 + 2) || 32;
      if (pathname[n6 + 1] === "2" && third === 102) {
        throw new Deno.errors.InvalidData(
          "must not include encoded / characters"
        );
      }
    }
  }
  return decodeURIComponent(pathname);
}
function pathToFileURL$1(filepath) {
  let resolved = path.resolve(filepath);
  const filePathLast = filepath.charCodeAt(filepath.length - 1);
  if ((filePathLast === CHAR_FORWARD_SLASH$1 || isWindows$1 && filePathLast === CHAR_BACKWARD_SLASH$1) && resolved[resolved.length - 1] !== path.sep) {
    resolved += "/";
  }
  const outURL = new URL("file://");
  if (resolved.includes("%")) resolved = resolved.replace(percentRegEx$1, "%25");
  if (!isWindows$1 && resolved.includes("\\")) {
    resolved = resolved.replace(backslashRegEx$1, "%5C");
  }
  if (resolved.includes("\n")) resolved = resolved.replace(newlineRegEx$1, "%0A");
  if (resolved.includes("\r")) {
    resolved = resolved.replace(carriageReturnRegEx$1, "%0D");
  }
  if (resolved.includes("	")) resolved = resolved.replace(tabRegEx$1, "%09");
  outURL.pathname = resolved;
  return outURL;
}
var processPlatform = typeof Deno !== "undefined" ? Deno.build.os === "windows" ? "win32" : Deno.build.os : void 0;
h3.URL = typeof URL !== "undefined" ? URL : null;
h3.pathToFileURL = pathToFileURL;
h3.fileURLToPath = fileURLToPath;
h3.Url;
h3.format;
h3.resolve;
h3.resolveObject;
h3.parse;
h3.URL;
var CHAR_BACKWARD_SLASH = 92;
var CHAR_FORWARD_SLASH = 47;
var CHAR_LOWERCASE_A = 97;
var CHAR_LOWERCASE_Z = 122;
var isWindows = processPlatform === "win32";
var forwardSlashRegEx = /\//g;
var percentRegEx = /%/g;
var backslashRegEx = /\\/g;
var newlineRegEx = /\n/g;
var carriageReturnRegEx = /\r/g;
var tabRegEx = /\t/g;
function fileURLToPath(path2) {
  if (typeof path2 === "string") path2 = new URL(path2);
  else if (!(path2 instanceof URL)) {
    throw new Deno.errors.InvalidData(
      "invalid argument path , must be a string or URL"
    );
  }
  if (path2.protocol !== "file:") {
    throw new Deno.errors.InvalidData("invalid url scheme");
  }
  return isWindows ? getPathFromURLWin(path2) : getPathFromURLPosix(path2);
}
function getPathFromURLWin(url) {
  const hostname = url.hostname;
  let pathname = url.pathname;
  for (let n6 = 0; n6 < pathname.length; n6++) {
    if (pathname[n6] === "%") {
      const third = pathname.codePointAt(n6 + 2) || 32;
      if (pathname[n6 + 1] === "2" && third === 102 || // 2f 2F /
      pathname[n6 + 1] === "5" && third === 99) {
        throw new Deno.errors.InvalidData(
          "must not include encoded \\ or / characters"
        );
      }
    }
  }
  pathname = pathname.replace(forwardSlashRegEx, "\\");
  pathname = decodeURIComponent(pathname);
  if (hostname !== "") {
    return `\\\\${hostname}${pathname}`;
  } else {
    const letter = pathname.codePointAt(1) | 32;
    const sep2 = pathname[2];
    if (letter < CHAR_LOWERCASE_A || letter > CHAR_LOWERCASE_Z || // a..z A..Z
    sep2 !== ":") {
      throw new Deno.errors.InvalidData("file url path must be absolute");
    }
    return pathname.slice(1);
  }
}
function getPathFromURLPosix(url) {
  if (url.hostname !== "") {
    throw new Deno.errors.InvalidData("invalid file url hostname");
  }
  const pathname = url.pathname;
  for (let n6 = 0; n6 < pathname.length; n6++) {
    if (pathname[n6] === "%") {
      const third = pathname.codePointAt(n6 + 2) || 32;
      if (pathname[n6 + 1] === "2" && third === 102) {
        throw new Deno.errors.InvalidData(
          "must not include encoded / characters"
        );
      }
    }
  }
  return decodeURIComponent(pathname);
}
function pathToFileURL(filepath) {
  let resolved = exports$22.resolve(filepath);
  const filePathLast = filepath.charCodeAt(filepath.length - 1);
  if ((filePathLast === CHAR_FORWARD_SLASH || isWindows && filePathLast === CHAR_BACKWARD_SLASH) && resolved[resolved.length - 1] !== exports$22.sep) {
    resolved += "/";
  }
  const outURL = new URL("file://");
  if (resolved.includes("%")) resolved = resolved.replace(percentRegEx, "%25");
  if (!isWindows && resolved.includes("\\")) {
    resolved = resolved.replace(backslashRegEx, "%5C");
  }
  if (resolved.includes("\n")) resolved = resolved.replace(newlineRegEx, "%0A");
  if (resolved.includes("\r")) {
    resolved = resolved.replace(carriageReturnRegEx, "%0D");
  }
  if (resolved.includes("	")) resolved = resolved.replace(tabRegEx, "%09");
  outURL.pathname = resolved;
  return outURL;
}

// node_modules/@jspm/core/nodelibs/browser/chunk-DEMDiNwt.js
function unimplemented2(name2) {
  throw new Error("Node.js process " + name2 + " is not supported by JSPM core outside of Node.js");
}
var queue2 = [];
var draining2 = false;
var currentQueue2;
var queueIndex2 = -1;
function cleanUpNextTick2() {
  if (!draining2 || !currentQueue2)
    return;
  draining2 = false;
  if (currentQueue2.length) {
    queue2 = currentQueue2.concat(queue2);
  } else {
    queueIndex2 = -1;
  }
  if (queue2.length)
    drainQueue2();
}
function drainQueue2() {
  if (draining2)
    return;
  var timeout = setTimeout(cleanUpNextTick2, 0);
  draining2 = true;
  var len = queue2.length;
  while (len) {
    currentQueue2 = queue2;
    queue2 = [];
    while (++queueIndex2 < len) {
      if (currentQueue2)
        currentQueue2[queueIndex2].run();
    }
    queueIndex2 = -1;
    len = queue2.length;
  }
  currentQueue2 = null;
  draining2 = false;
  clearTimeout(timeout);
}
function nextTick2(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i5 = 1; i5 < arguments.length; i5++)
      args[i5 - 1] = arguments[i5];
  }
  queue2.push(new Item2(fun, args));
  if (queue2.length === 1 && !draining2)
    setTimeout(drainQueue2, 0);
}
function Item2(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item2.prototype.run = function() {
  this.fun.apply(null, this.array);
};
var title2 = "browser";
var arch2 = "x64";
var platform2 = "browser";
var env3 = {
  PATH: "/usr/bin",
  LANG: navigator.language + ".UTF-8",
  PWD: "/",
  HOME: "/home",
  TMP: "/tmp"
};
var argv2 = ["/usr/bin/node"];
var execArgv2 = [];
var version2 = "v16.8.0";
var versions2 = {};
var emitWarning2 = function(message, type) {
  console.warn((type ? type + ": " : "") + message);
};
var binding2 = function(name2) {
  unimplemented2("binding");
};
var umask2 = function(mask) {
  return 0;
};
var cwd2 = function() {
  return "/";
};
var chdir2 = function(dir) {
};
var release2 = {
  name: "node",
  sourceUrl: "",
  headersUrl: "",
  libUrl: ""
};
function noop2() {
}
var _rawDebug2 = noop2;
var moduleLoadList2 = [];
function _linkedBinding2(name2) {
  unimplemented2("_linkedBinding");
}
var domain2 = {};
var _exiting2 = false;
var config2 = {};
function dlopen2(name2) {
  unimplemented2("dlopen");
}
function _getActiveRequests2() {
  return [];
}
function _getActiveHandles2() {
  return [];
}
var reallyExit2 = noop2;
var _kill2 = noop2;
var cpuUsage2 = function() {
  return {};
};
var resourceUsage2 = cpuUsage2;
var memoryUsage2 = cpuUsage2;
var kill2 = noop2;
var exit2 = noop2;
var openStdin2 = noop2;
var allowedNodeEnvironmentFlags2 = {};
function assert2(condition, message) {
  if (!condition) throw new Error(message || "assertion error");
}
var features2 = {
  inspector: false,
  debug: false,
  uv: false,
  ipv6: false,
  tls_alpn: false,
  tls_sni: false,
  tls_ocsp: false,
  tls: false,
  cached_builtins: true
};
var _fatalExceptions2 = noop2;
var setUncaughtExceptionCaptureCallback2 = noop2;
function hasUncaughtExceptionCaptureCallback2() {
  return false;
}
var _tickCallback2 = noop2;
var _debugProcess2 = noop2;
var _debugEnd2 = noop2;
var _startProfilerIdleNotifier2 = noop2;
var _stopProfilerIdleNotifier2 = noop2;
var stdout2 = void 0;
var stderr2 = void 0;
var stdin2 = void 0;
var abort2 = noop2;
var pid2 = 2;
var ppid2 = 1;
var execPath2 = "/bin/usr/node";
var debugPort2 = 9229;
var argv02 = "node";
var _preload_modules2 = [];
var setSourceMapsEnabled2 = noop2;
var _performance2 = {
  now: typeof performance !== "undefined" ? performance.now.bind(performance) : void 0,
  timing: typeof performance !== "undefined" ? performance.timing : void 0
};
if (_performance2.now === void 0) {
  nowOffset = Date.now();
  if (_performance2.timing && _performance2.timing.navigationStart) {
    nowOffset = _performance2.timing.navigationStart;
  }
  _performance2.now = () => Date.now() - nowOffset;
}
var nowOffset;
function uptime2() {
  return _performance2.now() / 1e3;
}
var nanoPerSec2 = 1e9;
function hrtime2(previousTimestamp) {
  var baseNow = Math.floor((Date.now() - _performance2.now()) * 1e-3);
  var clocktime = _performance2.now() * 1e-3;
  var seconds = Math.floor(clocktime) + baseNow;
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += nanoPerSec2;
    }
  }
  return [seconds, nanoseconds];
}
hrtime2.bigint = function(time) {
  var diff = hrtime2(time);
  if (typeof BigInt === "undefined") {
    return diff[0] * nanoPerSec2 + diff[1];
  }
  return BigInt(diff[0] * nanoPerSec2) + BigInt(diff[1]);
};
var _maxListeners2 = 10;
var _events2 = {};
var _eventsCount2 = 0;
function on2() {
  return process3;
}
var addListener2 = on2;
var once2 = on2;
var off2 = on2;
var removeListener2 = on2;
var removeAllListeners2 = on2;
var emit2 = noop2;
var prependListener2 = on2;
var prependOnceListener2 = on2;
function listeners2(name2) {
  return [];
}
var process3 = {
  version: version2,
  versions: versions2,
  arch: arch2,
  platform: platform2,
  release: release2,
  _rawDebug: _rawDebug2,
  moduleLoadList: moduleLoadList2,
  binding: binding2,
  _linkedBinding: _linkedBinding2,
  _events: _events2,
  _eventsCount: _eventsCount2,
  _maxListeners: _maxListeners2,
  on: on2,
  addListener: addListener2,
  once: once2,
  off: off2,
  removeListener: removeListener2,
  removeAllListeners: removeAllListeners2,
  emit: emit2,
  prependListener: prependListener2,
  prependOnceListener: prependOnceListener2,
  listeners: listeners2,
  domain: domain2,
  _exiting: _exiting2,
  config: config2,
  dlopen: dlopen2,
  uptime: uptime2,
  _getActiveRequests: _getActiveRequests2,
  _getActiveHandles: _getActiveHandles2,
  reallyExit: reallyExit2,
  _kill: _kill2,
  cpuUsage: cpuUsage2,
  resourceUsage: resourceUsage2,
  memoryUsage: memoryUsage2,
  kill: kill2,
  exit: exit2,
  openStdin: openStdin2,
  allowedNodeEnvironmentFlags: allowedNodeEnvironmentFlags2,
  assert: assert2,
  features: features2,
  _fatalExceptions: _fatalExceptions2,
  setUncaughtExceptionCaptureCallback: setUncaughtExceptionCaptureCallback2,
  hasUncaughtExceptionCaptureCallback: hasUncaughtExceptionCaptureCallback2,
  emitWarning: emitWarning2,
  nextTick: nextTick2,
  _tickCallback: _tickCallback2,
  _debugProcess: _debugProcess2,
  _debugEnd: _debugEnd2,
  _startProfilerIdleNotifier: _startProfilerIdleNotifier2,
  _stopProfilerIdleNotifier: _stopProfilerIdleNotifier2,
  stdout: stdout2,
  stdin: stdin2,
  stderr: stderr2,
  abort: abort2,
  umask: umask2,
  chdir: chdir2,
  cwd: cwd2,
  env: env3,
  title: title2,
  argv: argv2,
  execArgv: execArgv2,
  pid: pid2,
  ppid: ppid2,
  execPath: execPath2,
  debugPort: debugPort2,
  hrtime: hrtime2,
  argv0: argv02,
  _preload_modules: _preload_modules2,
  setSourceMapsEnabled: setSourceMapsEnabled2
};

// node_modules/@jspm/core/nodelibs/browser/chunk-tHuMsdT0.js
var e5;
var t4;
var n4 = "object" == typeof Reflect ? Reflect : null;
var r4 = n4 && "function" == typeof n4.apply ? n4.apply : function(e7, t6, n6) {
  return Function.prototype.apply.call(e7, t6, n6);
};
t4 = n4 && "function" == typeof n4.ownKeys ? n4.ownKeys : Object.getOwnPropertySymbols ? function(e7) {
  return Object.getOwnPropertyNames(e7).concat(Object.getOwnPropertySymbols(e7));
} : function(e7) {
  return Object.getOwnPropertyNames(e7);
};
var i3 = Number.isNaN || function(e7) {
  return e7 != e7;
};
function o3() {
  o3.init.call(this);
}
e5 = o3, o3.EventEmitter = o3, o3.prototype._events = void 0, o3.prototype._eventsCount = 0, o3.prototype._maxListeners = void 0;
var s3 = 10;
function u3(e7) {
  if ("function" != typeof e7) throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e7);
}
function f3(e7) {
  return void 0 === e7._maxListeners ? o3.defaultMaxListeners : e7._maxListeners;
}
function v9(e7, t6, n6, r6) {
  var i5, o5, s5, v11;
  if (u3(n6), void 0 === (o5 = e7._events) ? (o5 = e7._events = /* @__PURE__ */ Object.create(null), e7._eventsCount = 0) : (void 0 !== o5.newListener && (e7.emit("newListener", t6, n6.listener ? n6.listener : n6), o5 = e7._events), s5 = o5[t6]), void 0 === s5) s5 = o5[t6] = n6, ++e7._eventsCount;
  else if ("function" == typeof s5 ? s5 = o5[t6] = r6 ? [n6, s5] : [s5, n6] : r6 ? s5.unshift(n6) : s5.push(n6), (i5 = f3(e7)) > 0 && s5.length > i5 && !s5.warned) {
    s5.warned = true;
    var a5 = new Error("Possible EventEmitter memory leak detected. " + s5.length + " " + String(t6) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    a5.name = "MaxListenersExceededWarning", a5.emitter = e7, a5.type = t6, a5.count = s5.length, v11 = a5, console && console.warn && console.warn(v11);
  }
  return e7;
}
function a3() {
  if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function l3(e7, t6, n6) {
  var r6 = { fired: false, wrapFn: void 0, target: e7, type: t6, listener: n6 }, i5 = a3.bind(r6);
  return i5.listener = n6, r6.wrapFn = i5, i5;
}
function h4(e7, t6, n6) {
  var r6 = e7._events;
  if (void 0 === r6) return [];
  var i5 = r6[t6];
  return void 0 === i5 ? [] : "function" == typeof i5 ? n6 ? [i5.listener || i5] : [i5] : n6 ? function(e8) {
    for (var t7 = new Array(e8.length), n7 = 0; n7 < t7.length; ++n7) t7[n7] = e8[n7].listener || e8[n7];
    return t7;
  }(i5) : c3(i5, i5.length);
}
function p3(e7) {
  var t6 = this._events;
  if (void 0 !== t6) {
    var n6 = t6[e7];
    if ("function" == typeof n6) return 1;
    if (void 0 !== n6) return n6.length;
  }
  return 0;
}
function c3(e7, t6) {
  for (var n6 = new Array(t6), r6 = 0; r6 < t6; ++r6) n6[r6] = e7[r6];
  return n6;
}
Object.defineProperty(o3, "defaultMaxListeners", { enumerable: true, get: function() {
  return s3;
}, set: function(e7) {
  if ("number" != typeof e7 || e7 < 0 || i3(e7)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e7 + ".");
  s3 = e7;
} }), o3.init = function() {
  void 0 !== this._events && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
}, o3.prototype.setMaxListeners = function(e7) {
  if ("number" != typeof e7 || e7 < 0 || i3(e7)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e7 + ".");
  return this._maxListeners = e7, this;
}, o3.prototype.getMaxListeners = function() {
  return f3(this);
}, o3.prototype.emit = function(e7) {
  for (var t6 = [], n6 = 1; n6 < arguments.length; n6++) t6.push(arguments[n6]);
  var i5 = "error" === e7, o5 = this._events;
  if (void 0 !== o5) i5 = i5 && void 0 === o5.error;
  else if (!i5) return false;
  if (i5) {
    var s5;
    if (t6.length > 0 && (s5 = t6[0]), s5 instanceof Error) throw s5;
    var u5 = new Error("Unhandled error." + (s5 ? " (" + s5.message + ")" : ""));
    throw u5.context = s5, u5;
  }
  var f5 = o5[e7];
  if (void 0 === f5) return false;
  if ("function" == typeof f5) r4(f5, this, t6);
  else {
    var v11 = f5.length, a5 = c3(f5, v11);
    for (n6 = 0; n6 < v11; ++n6) r4(a5[n6], this, t6);
  }
  return true;
}, o3.prototype.addListener = function(e7, t6) {
  return v9(this, e7, t6, false);
}, o3.prototype.on = o3.prototype.addListener, o3.prototype.prependListener = function(e7, t6) {
  return v9(this, e7, t6, true);
}, o3.prototype.once = function(e7, t6) {
  return u3(t6), this.on(e7, l3(this, e7, t6)), this;
}, o3.prototype.prependOnceListener = function(e7, t6) {
  return u3(t6), this.prependListener(e7, l3(this, e7, t6)), this;
}, o3.prototype.removeListener = function(e7, t6) {
  var n6, r6, i5, o5, s5;
  if (u3(t6), void 0 === (r6 = this._events)) return this;
  if (void 0 === (n6 = r6[e7])) return this;
  if (n6 === t6 || n6.listener === t6) 0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete r6[e7], r6.removeListener && this.emit("removeListener", e7, n6.listener || t6));
  else if ("function" != typeof n6) {
    for (i5 = -1, o5 = n6.length - 1; o5 >= 0; o5--) if (n6[o5] === t6 || n6[o5].listener === t6) {
      s5 = n6[o5].listener, i5 = o5;
      break;
    }
    if (i5 < 0) return this;
    0 === i5 ? n6.shift() : !function(e8, t7) {
      for (; t7 + 1 < e8.length; t7++) e8[t7] = e8[t7 + 1];
      e8.pop();
    }(n6, i5), 1 === n6.length && (r6[e7] = n6[0]), void 0 !== r6.removeListener && this.emit("removeListener", e7, s5 || t6);
  }
  return this;
}, o3.prototype.off = o3.prototype.removeListener, o3.prototype.removeAllListeners = function(e7) {
  var t6, n6, r6;
  if (void 0 === (n6 = this._events)) return this;
  if (void 0 === n6.removeListener) return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== n6[e7] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete n6[e7]), this;
  if (0 === arguments.length) {
    var i5, o5 = Object.keys(n6);
    for (r6 = 0; r6 < o5.length; ++r6) "removeListener" !== (i5 = o5[r6]) && this.removeAllListeners(i5);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if ("function" == typeof (t6 = n6[e7])) this.removeListener(e7, t6);
  else if (void 0 !== t6) for (r6 = t6.length - 1; r6 >= 0; r6--) this.removeListener(e7, t6[r6]);
  return this;
}, o3.prototype.listeners = function(e7) {
  return h4(this, e7, true);
}, o3.prototype.rawListeners = function(e7) {
  return h4(this, e7, false);
}, o3.listenerCount = function(e7, t6) {
  return "function" == typeof e7.listenerCount ? e7.listenerCount(t6) : p3.call(e7, t6);
}, o3.prototype.listenerCount = p3, o3.prototype.eventNames = function() {
  return this._eventsCount > 0 ? t4(this._events) : [];
};
var y5 = e5;
y5.EventEmitter;
y5.defaultMaxListeners;
y5.init;
y5.listenerCount;
y5.EventEmitter;
y5.defaultMaxListeners;
y5.init;
y5.listenerCount;

// node_modules/@jspm/core/nodelibs/browser/chunk-DtDiafJB.js
y5.once = function(emitter, event) {
  return new Promise((resolve3, reject) => {
    function eventListener(...args) {
      if (errorListener !== void 0) {
        emitter.removeListener("error", errorListener);
      }
      resolve3(args);
    }
    let errorListener;
    if (event !== "error") {
      errorListener = (err) => {
        emitter.removeListener(name, eventListener);
        reject(err);
      };
      emitter.once("error", errorListener);
    }
    emitter.once(event, eventListener);
  });
};
y5.on = function(emitter, event) {
  const unconsumedEventValues = [];
  const unconsumedPromises = [];
  let error = null;
  let finished = false;
  const iterator = {
    async next() {
      const value = unconsumedEventValues.shift();
      if (value) {
        return createIterResult(value, false);
      }
      if (error) {
        const p5 = Promise.reject(error);
        error = null;
        return p5;
      }
      if (finished) {
        return createIterResult(void 0, true);
      }
      return new Promise((resolve3, reject) => unconsumedPromises.push({ resolve: resolve3, reject }));
    },
    async return() {
      emitter.removeListener(event, eventHandler);
      emitter.removeListener("error", errorHandler);
      finished = true;
      for (const promise3 of unconsumedPromises) {
        promise3.resolve(createIterResult(void 0, true));
      }
      return createIterResult(void 0, true);
    },
    throw(err) {
      error = err;
      emitter.removeListener(event, eventHandler);
      emitter.removeListener("error", errorHandler);
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
  emitter.on(event, eventHandler);
  emitter.on("error", errorHandler);
  return iterator;
  function eventHandler(...args) {
    const promise3 = unconsumedPromises.shift();
    if (promise3) {
      promise3.resolve(createIterResult(args, false));
    } else {
      unconsumedEventValues.push(args);
    }
  }
  function errorHandler(err) {
    finished = true;
    const toError = unconsumedPromises.shift();
    if (toError) {
      toError.reject(err);
    } else {
      error = err;
    }
    iterator.return();
  }
};

// node_modules/@jspm/core/nodelibs/browser/chunk-B738Er4n.js
for (r$14 = { byteLength: function(r6) {
  var t6 = u$23(r6), e7 = t6[0], n6 = t6[1];
  return 3 * (e7 + n6) / 4 - n6;
}, toByteArray: function(r6) {
  var t6, o5, a5 = u$23(r6), h6 = a5[0], c5 = a5[1], d5 = new n$24(function(r7, t7, e7) {
    return 3 * (t7 + e7) / 4 - e7;
  }(0, h6, c5)), f5 = 0, A4 = c5 > 0 ? h6 - 4 : h6;
  for (o5 = 0; o5 < A4; o5 += 4) t6 = e$24[r6.charCodeAt(o5)] << 18 | e$24[r6.charCodeAt(o5 + 1)] << 12 | e$24[r6.charCodeAt(o5 + 2)] << 6 | e$24[r6.charCodeAt(o5 + 3)], d5[f5++] = t6 >> 16 & 255, d5[f5++] = t6 >> 8 & 255, d5[f5++] = 255 & t6;
  2 === c5 && (t6 = e$24[r6.charCodeAt(o5)] << 2 | e$24[r6.charCodeAt(o5 + 1)] >> 4, d5[f5++] = 255 & t6);
  1 === c5 && (t6 = e$24[r6.charCodeAt(o5)] << 10 | e$24[r6.charCodeAt(o5 + 1)] << 4 | e$24[r6.charCodeAt(o5 + 2)] >> 2, d5[f5++] = t6 >> 8 & 255, d5[f5++] = 255 & t6);
  return d5;
}, fromByteArray: function(r6) {
  for (var e7, n6 = r6.length, o5 = n6 % 3, a5 = [], h6 = 0, u5 = n6 - o5; h6 < u5; h6 += 16383) a5.push(c$14(r6, h6, h6 + 16383 > u5 ? u5 : h6 + 16383));
  1 === o5 ? (e7 = r6[n6 - 1], a5.push(t$14[e7 >> 2] + t$14[e7 << 4 & 63] + "==")) : 2 === o5 && (e7 = (r6[n6 - 2] << 8) + r6[n6 - 1], a5.push(t$14[e7 >> 10] + t$14[e7 >> 4 & 63] + t$14[e7 << 2 & 63] + "="));
  return a5.join("");
} }, t$14 = [], e$24 = [], n$24 = "undefined" != typeof Uint8Array ? Uint8Array : Array, o$24 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a$14 = 0, h$14 = o$24.length; a$14 < h$14; ++a$14) t$14[a$14] = o$24[a$14], e$24[o$24.charCodeAt(a$14)] = a$14;
var r$14;
var t$14;
var e$24;
var n$24;
var o$24;
var a$14;
var h$14;
function u$23(r6) {
  var t6 = r6.length;
  if (t6 % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
  var e7 = r6.indexOf("=");
  return -1 === e7 && (e7 = t6), [e7, e7 === t6 ? 0 : 4 - e7 % 4];
}
function c$14(r6, e7, n6) {
  for (var o5, a5, h6 = [], u5 = e7; u5 < n6; u5 += 3) o5 = (r6[u5] << 16 & 16711680) + (r6[u5 + 1] << 8 & 65280) + (255 & r6[u5 + 2]), h6.push(t$14[(a5 = o5) >> 18 & 63] + t$14[a5 >> 12 & 63] + t$14[a5 >> 6 & 63] + t$14[63 & a5]);
  return h6.join("");
}
e$24["-".charCodeAt(0)] = 62, e$24["_".charCodeAt(0)] = 63;
var a$1$1 = { read: function(a5, t6, o5, r6, h6) {
  var M4, f5, p5 = 8 * h6 - r6 - 1, w5 = (1 << p5) - 1, e7 = w5 >> 1, i5 = -7, N4 = o5 ? h6 - 1 : 0, n6 = o5 ? -1 : 1, u5 = a5[t6 + N4];
  for (N4 += n6, M4 = u5 & (1 << -i5) - 1, u5 >>= -i5, i5 += p5; i5 > 0; M4 = 256 * M4 + a5[t6 + N4], N4 += n6, i5 -= 8) ;
  for (f5 = M4 & (1 << -i5) - 1, M4 >>= -i5, i5 += r6; i5 > 0; f5 = 256 * f5 + a5[t6 + N4], N4 += n6, i5 -= 8) ;
  if (0 === M4) M4 = 1 - e7;
  else {
    if (M4 === w5) return f5 ? NaN : 1 / 0 * (u5 ? -1 : 1);
    f5 += Math.pow(2, r6), M4 -= e7;
  }
  return (u5 ? -1 : 1) * f5 * Math.pow(2, M4 - r6);
}, write: function(a5, t6, o5, r6, h6, M4) {
  var f5, p5, w5, e7 = 8 * M4 - h6 - 1, i5 = (1 << e7) - 1, N4 = i5 >> 1, n6 = 23 === h6 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, u5 = r6 ? 0 : M4 - 1, l5 = r6 ? 1 : -1, s5 = t6 < 0 || 0 === t6 && 1 / t6 < 0 ? 1 : 0;
  for (t6 = Math.abs(t6), isNaN(t6) || t6 === 1 / 0 ? (p5 = isNaN(t6) ? 1 : 0, f5 = i5) : (f5 = Math.floor(Math.log(t6) / Math.LN2), t6 * (w5 = Math.pow(2, -f5)) < 1 && (f5--, w5 *= 2), (t6 += f5 + N4 >= 1 ? n6 / w5 : n6 * Math.pow(2, 1 - N4)) * w5 >= 2 && (f5++, w5 /= 2), f5 + N4 >= i5 ? (p5 = 0, f5 = i5) : f5 + N4 >= 1 ? (p5 = (t6 * w5 - 1) * Math.pow(2, h6), f5 += N4) : (p5 = t6 * Math.pow(2, N4 - 1) * Math.pow(2, h6), f5 = 0)); h6 >= 8; a5[o5 + u5] = 255 & p5, u5 += l5, p5 /= 256, h6 -= 8) ;
  for (f5 = f5 << h6 | p5, e7 += h6; e7 > 0; a5[o5 + u5] = 255 & f5, u5 += l5, f5 /= 256, e7 -= 8) ;
  a5[o5 + u5 - l5] |= 128 * s5;
} };
var e$1$1 = {};
var n$1$1 = r$14;
var i$14 = a$1$1;
var o$1$1 = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
e$1$1.Buffer = u$1$1, e$1$1.SlowBuffer = function(t6) {
  +t6 != t6 && (t6 = 0);
  return u$1$1.alloc(+t6);
}, e$1$1.INSPECT_MAX_BYTES = 50;
function f$22(t6) {
  if (t6 > 2147483647) throw new RangeError('The value "' + t6 + '" is invalid for option "size"');
  var r6 = new Uint8Array(t6);
  return Object.setPrototypeOf(r6, u$1$1.prototype), r6;
}
function u$1$1(t6, r6, e7) {
  if ("number" == typeof t6) {
    if ("string" == typeof r6) throw new TypeError('The "string" argument must be of type string. Received type number');
    return a$22(t6);
  }
  return s$13(t6, r6, e7);
}
function s$13(t6, r6, e7) {
  if ("string" == typeof t6) return function(t7, r7) {
    "string" == typeof r7 && "" !== r7 || (r7 = "utf8");
    if (!u$1$1.isEncoding(r7)) throw new TypeError("Unknown encoding: " + r7);
    var e8 = 0 | y6(t7, r7), n7 = f$22(e8), i6 = n7.write(t7, r7);
    i6 !== e8 && (n7 = n7.slice(0, i6));
    return n7;
  }(t6, r6);
  if (ArrayBuffer.isView(t6)) return p4(t6);
  if (null == t6) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t6);
  if (F4(t6, ArrayBuffer) || t6 && F4(t6.buffer, ArrayBuffer)) return c$1$1(t6, r6, e7);
  if ("undefined" != typeof SharedArrayBuffer && (F4(t6, SharedArrayBuffer) || t6 && F4(t6.buffer, SharedArrayBuffer))) return c$1$1(t6, r6, e7);
  if ("number" == typeof t6) throw new TypeError('The "value" argument must not be of type number. Received type number');
  var n6 = t6.valueOf && t6.valueOf();
  if (null != n6 && n6 !== t6) return u$1$1.from(n6, r6, e7);
  var i5 = function(t7) {
    if (u$1$1.isBuffer(t7)) {
      var r7 = 0 | l$14(t7.length), e8 = f$22(r7);
      return 0 === e8.length || t7.copy(e8, 0, 0, r7), e8;
    }
    if (void 0 !== t7.length) return "number" != typeof t7.length || N3(t7.length) ? f$22(0) : p4(t7);
    if ("Buffer" === t7.type && Array.isArray(t7.data)) return p4(t7.data);
  }(t6);
  if (i5) return i5;
  if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof t6[Symbol.toPrimitive]) return u$1$1.from(t6[Symbol.toPrimitive]("string"), r6, e7);
  throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t6);
}
function h$1$1(t6) {
  if ("number" != typeof t6) throw new TypeError('"size" argument must be of type number');
  if (t6 < 0) throw new RangeError('The value "' + t6 + '" is invalid for option "size"');
}
function a$22(t6) {
  return h$1$1(t6), f$22(t6 < 0 ? 0 : 0 | l$14(t6));
}
function p4(t6) {
  for (var r6 = t6.length < 0 ? 0 : 0 | l$14(t6.length), e7 = f$22(r6), n6 = 0; n6 < r6; n6 += 1) e7[n6] = 255 & t6[n6];
  return e7;
}
function c$1$1(t6, r6, e7) {
  if (r6 < 0 || t6.byteLength < r6) throw new RangeError('"offset" is outside of buffer bounds');
  if (t6.byteLength < r6 + (e7 || 0)) throw new RangeError('"length" is outside of buffer bounds');
  var n6;
  return n6 = void 0 === r6 && void 0 === e7 ? new Uint8Array(t6) : void 0 === e7 ? new Uint8Array(t6, r6) : new Uint8Array(t6, r6, e7), Object.setPrototypeOf(n6, u$1$1.prototype), n6;
}
function l$14(t6) {
  if (t6 >= 2147483647) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647 .toString(16) + " bytes");
  return 0 | t6;
}
function y6(t6, r6) {
  if (u$1$1.isBuffer(t6)) return t6.length;
  if (ArrayBuffer.isView(t6) || F4(t6, ArrayBuffer)) return t6.byteLength;
  if ("string" != typeof t6) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t6);
  var e7 = t6.length, n6 = arguments.length > 2 && true === arguments[2];
  if (!n6 && 0 === e7) return 0;
  for (var i5 = false; ; ) switch (r6) {
    case "ascii":
    case "latin1":
    case "binary":
      return e7;
    case "utf8":
    case "utf-8":
      return _3(t6).length;
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return 2 * e7;
    case "hex":
      return e7 >>> 1;
    case "base64":
      return z3(t6).length;
    default:
      if (i5) return n6 ? -1 : _3(t6).length;
      r6 = ("" + r6).toLowerCase(), i5 = true;
  }
}
function g4(t6, r6, e7) {
  var n6 = false;
  if ((void 0 === r6 || r6 < 0) && (r6 = 0), r6 > this.length) return "";
  if ((void 0 === e7 || e7 > this.length) && (e7 = this.length), e7 <= 0) return "";
  if ((e7 >>>= 0) <= (r6 >>>= 0)) return "";
  for (t6 || (t6 = "utf8"); ; ) switch (t6) {
    case "hex":
      return O5(this, r6, e7);
    case "utf8":
    case "utf-8":
      return I3(this, r6, e7);
    case "ascii":
      return S3(this, r6, e7);
    case "latin1":
    case "binary":
      return R3(this, r6, e7);
    case "base64":
      return T4(this, r6, e7);
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return L4(this, r6, e7);
    default:
      if (n6) throw new TypeError("Unknown encoding: " + t6);
      t6 = (t6 + "").toLowerCase(), n6 = true;
  }
}
function w4(t6, r6, e7) {
  var n6 = t6[r6];
  t6[r6] = t6[e7], t6[e7] = n6;
}
function d4(t6, r6, e7, n6, i5) {
  if (0 === t6.length) return -1;
  if ("string" == typeof e7 ? (n6 = e7, e7 = 0) : e7 > 2147483647 ? e7 = 2147483647 : e7 < -2147483648 && (e7 = -2147483648), N3(e7 = +e7) && (e7 = i5 ? 0 : t6.length - 1), e7 < 0 && (e7 = t6.length + e7), e7 >= t6.length) {
    if (i5) return -1;
    e7 = t6.length - 1;
  } else if (e7 < 0) {
    if (!i5) return -1;
    e7 = 0;
  }
  if ("string" == typeof r6 && (r6 = u$1$1.from(r6, n6)), u$1$1.isBuffer(r6)) return 0 === r6.length ? -1 : v10(t6, r6, e7, n6, i5);
  if ("number" == typeof r6) return r6 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? i5 ? Uint8Array.prototype.indexOf.call(t6, r6, e7) : Uint8Array.prototype.lastIndexOf.call(t6, r6, e7) : v10(t6, [r6], e7, n6, i5);
  throw new TypeError("val must be string, number or Buffer");
}
function v10(t6, r6, e7, n6, i5) {
  var o5, f5 = 1, u5 = t6.length, s5 = r6.length;
  if (void 0 !== n6 && ("ucs2" === (n6 = String(n6).toLowerCase()) || "ucs-2" === n6 || "utf16le" === n6 || "utf-16le" === n6)) {
    if (t6.length < 2 || r6.length < 2) return -1;
    f5 = 2, u5 /= 2, s5 /= 2, e7 /= 2;
  }
  function h6(t7, r7) {
    return 1 === f5 ? t7[r7] : t7.readUInt16BE(r7 * f5);
  }
  if (i5) {
    var a5 = -1;
    for (o5 = e7; o5 < u5; o5++) if (h6(t6, o5) === h6(r6, -1 === a5 ? 0 : o5 - a5)) {
      if (-1 === a5 && (a5 = o5), o5 - a5 + 1 === s5) return a5 * f5;
    } else -1 !== a5 && (o5 -= o5 - a5), a5 = -1;
  } else for (e7 + s5 > u5 && (e7 = u5 - s5), o5 = e7; o5 >= 0; o5--) {
    for (var p5 = true, c5 = 0; c5 < s5; c5++) if (h6(t6, o5 + c5) !== h6(r6, c5)) {
      p5 = false;
      break;
    }
    if (p5) return o5;
  }
  return -1;
}
function b5(t6, r6, e7, n6) {
  e7 = Number(e7) || 0;
  var i5 = t6.length - e7;
  n6 ? (n6 = Number(n6)) > i5 && (n6 = i5) : n6 = i5;
  var o5 = r6.length;
  n6 > o5 / 2 && (n6 = o5 / 2);
  for (var f5 = 0; f5 < n6; ++f5) {
    var u5 = parseInt(r6.substr(2 * f5, 2), 16);
    if (N3(u5)) return f5;
    t6[e7 + f5] = u5;
  }
  return f5;
}
function m6(t6, r6, e7, n6) {
  return D4(_3(r6, t6.length - e7), t6, e7, n6);
}
function E3(t6, r6, e7, n6) {
  return D4(function(t7) {
    for (var r7 = [], e8 = 0; e8 < t7.length; ++e8) r7.push(255 & t7.charCodeAt(e8));
    return r7;
  }(r6), t6, e7, n6);
}
function B4(t6, r6, e7, n6) {
  return E3(t6, r6, e7, n6);
}
function A3(t6, r6, e7, n6) {
  return D4(z3(r6), t6, e7, n6);
}
function U4(t6, r6, e7, n6) {
  return D4(function(t7, r7) {
    for (var e8, n7, i5, o5 = [], f5 = 0; f5 < t7.length && !((r7 -= 2) < 0); ++f5) e8 = t7.charCodeAt(f5), n7 = e8 >> 8, i5 = e8 % 256, o5.push(i5), o5.push(n7);
    return o5;
  }(r6, t6.length - e7), t6, e7, n6);
}
function T4(t6, r6, e7) {
  return 0 === r6 && e7 === t6.length ? n$1$1.fromByteArray(t6) : n$1$1.fromByteArray(t6.slice(r6, e7));
}
function I3(t6, r6, e7) {
  e7 = Math.min(t6.length, e7);
  for (var n6 = [], i5 = r6; i5 < e7; ) {
    var o5, f5, u5, s5, h6 = t6[i5], a5 = null, p5 = h6 > 239 ? 4 : h6 > 223 ? 3 : h6 > 191 ? 2 : 1;
    if (i5 + p5 <= e7) switch (p5) {
      case 1:
        h6 < 128 && (a5 = h6);
        break;
      case 2:
        128 == (192 & (o5 = t6[i5 + 1])) && (s5 = (31 & h6) << 6 | 63 & o5) > 127 && (a5 = s5);
        break;
      case 3:
        o5 = t6[i5 + 1], f5 = t6[i5 + 2], 128 == (192 & o5) && 128 == (192 & f5) && (s5 = (15 & h6) << 12 | (63 & o5) << 6 | 63 & f5) > 2047 && (s5 < 55296 || s5 > 57343) && (a5 = s5);
        break;
      case 4:
        o5 = t6[i5 + 1], f5 = t6[i5 + 2], u5 = t6[i5 + 3], 128 == (192 & o5) && 128 == (192 & f5) && 128 == (192 & u5) && (s5 = (15 & h6) << 18 | (63 & o5) << 12 | (63 & f5) << 6 | 63 & u5) > 65535 && s5 < 1114112 && (a5 = s5);
    }
    null === a5 ? (a5 = 65533, p5 = 1) : a5 > 65535 && (a5 -= 65536, n6.push(a5 >>> 10 & 1023 | 55296), a5 = 56320 | 1023 & a5), n6.push(a5), i5 += p5;
  }
  return function(t7) {
    var r7 = t7.length;
    if (r7 <= 4096) return String.fromCharCode.apply(String, t7);
    var e8 = "", n7 = 0;
    for (; n7 < r7; ) e8 += String.fromCharCode.apply(String, t7.slice(n7, n7 += 4096));
    return e8;
  }(n6);
}
e$1$1.kMaxLength = 2147483647, u$1$1.TYPED_ARRAY_SUPPORT = function() {
  try {
    var t6 = new Uint8Array(1), r6 = { foo: function() {
      return 42;
    } };
    return Object.setPrototypeOf(r6, Uint8Array.prototype), Object.setPrototypeOf(t6, r6), 42 === t6.foo();
  } catch (t7) {
    return false;
  }
}(), u$1$1.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(u$1$1.prototype, "parent", { enumerable: true, get: function() {
  if (u$1$1.isBuffer(this)) return this.buffer;
} }), Object.defineProperty(u$1$1.prototype, "offset", { enumerable: true, get: function() {
  if (u$1$1.isBuffer(this)) return this.byteOffset;
} }), u$1$1.poolSize = 8192, u$1$1.from = function(t6, r6, e7) {
  return s$13(t6, r6, e7);
}, Object.setPrototypeOf(u$1$1.prototype, Uint8Array.prototype), Object.setPrototypeOf(u$1$1, Uint8Array), u$1$1.alloc = function(t6, r6, e7) {
  return function(t7, r7, e8) {
    return h$1$1(t7), t7 <= 0 ? f$22(t7) : void 0 !== r7 ? "string" == typeof e8 ? f$22(t7).fill(r7, e8) : f$22(t7).fill(r7) : f$22(t7);
  }(t6, r6, e7);
}, u$1$1.allocUnsafe = function(t6) {
  return a$22(t6);
}, u$1$1.allocUnsafeSlow = function(t6) {
  return a$22(t6);
}, u$1$1.isBuffer = function(t6) {
  return null != t6 && true === t6._isBuffer && t6 !== u$1$1.prototype;
}, u$1$1.compare = function(t6, r6) {
  if (F4(t6, Uint8Array) && (t6 = u$1$1.from(t6, t6.offset, t6.byteLength)), F4(r6, Uint8Array) && (r6 = u$1$1.from(r6, r6.offset, r6.byteLength)), !u$1$1.isBuffer(t6) || !u$1$1.isBuffer(r6)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
  if (t6 === r6) return 0;
  for (var e7 = t6.length, n6 = r6.length, i5 = 0, o5 = Math.min(e7, n6); i5 < o5; ++i5) if (t6[i5] !== r6[i5]) {
    e7 = t6[i5], n6 = r6[i5];
    break;
  }
  return e7 < n6 ? -1 : n6 < e7 ? 1 : 0;
}, u$1$1.isEncoding = function(t6) {
  switch (String(t6).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
}, u$1$1.concat = function(t6, r6) {
  if (!Array.isArray(t6)) throw new TypeError('"list" argument must be an Array of Buffers');
  if (0 === t6.length) return u$1$1.alloc(0);
  var e7;
  if (void 0 === r6) for (r6 = 0, e7 = 0; e7 < t6.length; ++e7) r6 += t6[e7].length;
  var n6 = u$1$1.allocUnsafe(r6), i5 = 0;
  for (e7 = 0; e7 < t6.length; ++e7) {
    var o5 = t6[e7];
    if (F4(o5, Uint8Array) && (o5 = u$1$1.from(o5)), !u$1$1.isBuffer(o5)) throw new TypeError('"list" argument must be an Array of Buffers');
    o5.copy(n6, i5), i5 += o5.length;
  }
  return n6;
}, u$1$1.byteLength = y6, u$1$1.prototype._isBuffer = true, u$1$1.prototype.swap16 = function() {
  var t6 = this.length;
  if (t6 % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
  for (var r6 = 0; r6 < t6; r6 += 2) w4(this, r6, r6 + 1);
  return this;
}, u$1$1.prototype.swap32 = function() {
  var t6 = this.length;
  if (t6 % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
  for (var r6 = 0; r6 < t6; r6 += 4) w4(this, r6, r6 + 3), w4(this, r6 + 1, r6 + 2);
  return this;
}, u$1$1.prototype.swap64 = function() {
  var t6 = this.length;
  if (t6 % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
  for (var r6 = 0; r6 < t6; r6 += 8) w4(this, r6, r6 + 7), w4(this, r6 + 1, r6 + 6), w4(this, r6 + 2, r6 + 5), w4(this, r6 + 3, r6 + 4);
  return this;
}, u$1$1.prototype.toString = function() {
  var t6 = this.length;
  return 0 === t6 ? "" : 0 === arguments.length ? I3(this, 0, t6) : g4.apply(this, arguments);
}, u$1$1.prototype.toLocaleString = u$1$1.prototype.toString, u$1$1.prototype.equals = function(t6) {
  if (!u$1$1.isBuffer(t6)) throw new TypeError("Argument must be a Buffer");
  return this === t6 || 0 === u$1$1.compare(this, t6);
}, u$1$1.prototype.inspect = function() {
  var t6 = "", r6 = e$1$1.INSPECT_MAX_BYTES;
  return t6 = this.toString("hex", 0, r6).replace(/(.{2})/g, "$1 ").trim(), this.length > r6 && (t6 += " ... "), "<Buffer " + t6 + ">";
}, o$1$1 && (u$1$1.prototype[o$1$1] = u$1$1.prototype.inspect), u$1$1.prototype.compare = function(t6, r6, e7, n6, i5) {
  if (F4(t6, Uint8Array) && (t6 = u$1$1.from(t6, t6.offset, t6.byteLength)), !u$1$1.isBuffer(t6)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t6);
  if (void 0 === r6 && (r6 = 0), void 0 === e7 && (e7 = t6 ? t6.length : 0), void 0 === n6 && (n6 = 0), void 0 === i5 && (i5 = this.length), r6 < 0 || e7 > t6.length || n6 < 0 || i5 > this.length) throw new RangeError("out of range index");
  if (n6 >= i5 && r6 >= e7) return 0;
  if (n6 >= i5) return -1;
  if (r6 >= e7) return 1;
  if (this === t6) return 0;
  for (var o5 = (i5 >>>= 0) - (n6 >>>= 0), f5 = (e7 >>>= 0) - (r6 >>>= 0), s5 = Math.min(o5, f5), h6 = this.slice(n6, i5), a5 = t6.slice(r6, e7), p5 = 0; p5 < s5; ++p5) if (h6[p5] !== a5[p5]) {
    o5 = h6[p5], f5 = a5[p5];
    break;
  }
  return o5 < f5 ? -1 : f5 < o5 ? 1 : 0;
}, u$1$1.prototype.includes = function(t6, r6, e7) {
  return -1 !== this.indexOf(t6, r6, e7);
}, u$1$1.prototype.indexOf = function(t6, r6, e7) {
  return d4(this, t6, r6, e7, true);
}, u$1$1.prototype.lastIndexOf = function(t6, r6, e7) {
  return d4(this, t6, r6, e7, false);
}, u$1$1.prototype.write = function(t6, r6, e7, n6) {
  if (void 0 === r6) n6 = "utf8", e7 = this.length, r6 = 0;
  else if (void 0 === e7 && "string" == typeof r6) n6 = r6, e7 = this.length, r6 = 0;
  else {
    if (!isFinite(r6)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    r6 >>>= 0, isFinite(e7) ? (e7 >>>= 0, void 0 === n6 && (n6 = "utf8")) : (n6 = e7, e7 = void 0);
  }
  var i5 = this.length - r6;
  if ((void 0 === e7 || e7 > i5) && (e7 = i5), t6.length > 0 && (e7 < 0 || r6 < 0) || r6 > this.length) throw new RangeError("Attempt to write outside buffer bounds");
  n6 || (n6 = "utf8");
  for (var o5 = false; ; ) switch (n6) {
    case "hex":
      return b5(this, t6, r6, e7);
    case "utf8":
    case "utf-8":
      return m6(this, t6, r6, e7);
    case "ascii":
      return E3(this, t6, r6, e7);
    case "latin1":
    case "binary":
      return B4(this, t6, r6, e7);
    case "base64":
      return A3(this, t6, r6, e7);
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return U4(this, t6, r6, e7);
    default:
      if (o5) throw new TypeError("Unknown encoding: " + n6);
      n6 = ("" + n6).toLowerCase(), o5 = true;
  }
}, u$1$1.prototype.toJSON = function() {
  return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
};
function S3(t6, r6, e7) {
  var n6 = "";
  e7 = Math.min(t6.length, e7);
  for (var i5 = r6; i5 < e7; ++i5) n6 += String.fromCharCode(127 & t6[i5]);
  return n6;
}
function R3(t6, r6, e7) {
  var n6 = "";
  e7 = Math.min(t6.length, e7);
  for (var i5 = r6; i5 < e7; ++i5) n6 += String.fromCharCode(t6[i5]);
  return n6;
}
function O5(t6, r6, e7) {
  var n6 = t6.length;
  (!r6 || r6 < 0) && (r6 = 0), (!e7 || e7 < 0 || e7 > n6) && (e7 = n6);
  for (var i5 = "", o5 = r6; o5 < e7; ++o5) i5 += Y3[t6[o5]];
  return i5;
}
function L4(t6, r6, e7) {
  for (var n6 = t6.slice(r6, e7), i5 = "", o5 = 0; o5 < n6.length; o5 += 2) i5 += String.fromCharCode(n6[o5] + 256 * n6[o5 + 1]);
  return i5;
}
function x4(t6, r6, e7) {
  if (t6 % 1 != 0 || t6 < 0) throw new RangeError("offset is not uint");
  if (t6 + r6 > e7) throw new RangeError("Trying to access beyond buffer length");
}
function C3(t6, r6, e7, n6, i5, o5) {
  if (!u$1$1.isBuffer(t6)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (r6 > i5 || r6 < o5) throw new RangeError('"value" argument is out of bounds');
  if (e7 + n6 > t6.length) throw new RangeError("Index out of range");
}
function P4(t6, r6, e7, n6, i5, o5) {
  if (e7 + n6 > t6.length) throw new RangeError("Index out of range");
  if (e7 < 0) throw new RangeError("Index out of range");
}
function k4(t6, r6, e7, n6, o5) {
  return r6 = +r6, e7 >>>= 0, o5 || P4(t6, 0, e7, 4), i$14.write(t6, r6, e7, n6, 23, 4), e7 + 4;
}
function M3(t6, r6, e7, n6, o5) {
  return r6 = +r6, e7 >>>= 0, o5 || P4(t6, 0, e7, 8), i$14.write(t6, r6, e7, n6, 52, 8), e7 + 8;
}
u$1$1.prototype.slice = function(t6, r6) {
  var e7 = this.length;
  (t6 = ~~t6) < 0 ? (t6 += e7) < 0 && (t6 = 0) : t6 > e7 && (t6 = e7), (r6 = void 0 === r6 ? e7 : ~~r6) < 0 ? (r6 += e7) < 0 && (r6 = 0) : r6 > e7 && (r6 = e7), r6 < t6 && (r6 = t6);
  var n6 = this.subarray(t6, r6);
  return Object.setPrototypeOf(n6, u$1$1.prototype), n6;
}, u$1$1.prototype.readUIntLE = function(t6, r6, e7) {
  t6 >>>= 0, r6 >>>= 0, e7 || x4(t6, r6, this.length);
  for (var n6 = this[t6], i5 = 1, o5 = 0; ++o5 < r6 && (i5 *= 256); ) n6 += this[t6 + o5] * i5;
  return n6;
}, u$1$1.prototype.readUIntBE = function(t6, r6, e7) {
  t6 >>>= 0, r6 >>>= 0, e7 || x4(t6, r6, this.length);
  for (var n6 = this[t6 + --r6], i5 = 1; r6 > 0 && (i5 *= 256); ) n6 += this[t6 + --r6] * i5;
  return n6;
}, u$1$1.prototype.readUInt8 = function(t6, r6) {
  return t6 >>>= 0, r6 || x4(t6, 1, this.length), this[t6];
}, u$1$1.prototype.readUInt16LE = function(t6, r6) {
  return t6 >>>= 0, r6 || x4(t6, 2, this.length), this[t6] | this[t6 + 1] << 8;
}, u$1$1.prototype.readUInt16BE = function(t6, r6) {
  return t6 >>>= 0, r6 || x4(t6, 2, this.length), this[t6] << 8 | this[t6 + 1];
}, u$1$1.prototype.readUInt32LE = function(t6, r6) {
  return t6 >>>= 0, r6 || x4(t6, 4, this.length), (this[t6] | this[t6 + 1] << 8 | this[t6 + 2] << 16) + 16777216 * this[t6 + 3];
}, u$1$1.prototype.readUInt32BE = function(t6, r6) {
  return t6 >>>= 0, r6 || x4(t6, 4, this.length), 16777216 * this[t6] + (this[t6 + 1] << 16 | this[t6 + 2] << 8 | this[t6 + 3]);
}, u$1$1.prototype.readIntLE = function(t6, r6, e7) {
  t6 >>>= 0, r6 >>>= 0, e7 || x4(t6, r6, this.length);
  for (var n6 = this[t6], i5 = 1, o5 = 0; ++o5 < r6 && (i5 *= 256); ) n6 += this[t6 + o5] * i5;
  return n6 >= (i5 *= 128) && (n6 -= Math.pow(2, 8 * r6)), n6;
}, u$1$1.prototype.readIntBE = function(t6, r6, e7) {
  t6 >>>= 0, r6 >>>= 0, e7 || x4(t6, r6, this.length);
  for (var n6 = r6, i5 = 1, o5 = this[t6 + --n6]; n6 > 0 && (i5 *= 256); ) o5 += this[t6 + --n6] * i5;
  return o5 >= (i5 *= 128) && (o5 -= Math.pow(2, 8 * r6)), o5;
}, u$1$1.prototype.readInt8 = function(t6, r6) {
  return t6 >>>= 0, r6 || x4(t6, 1, this.length), 128 & this[t6] ? -1 * (255 - this[t6] + 1) : this[t6];
}, u$1$1.prototype.readInt16LE = function(t6, r6) {
  t6 >>>= 0, r6 || x4(t6, 2, this.length);
  var e7 = this[t6] | this[t6 + 1] << 8;
  return 32768 & e7 ? 4294901760 | e7 : e7;
}, u$1$1.prototype.readInt16BE = function(t6, r6) {
  t6 >>>= 0, r6 || x4(t6, 2, this.length);
  var e7 = this[t6 + 1] | this[t6] << 8;
  return 32768 & e7 ? 4294901760 | e7 : e7;
}, u$1$1.prototype.readInt32LE = function(t6, r6) {
  return t6 >>>= 0, r6 || x4(t6, 4, this.length), this[t6] | this[t6 + 1] << 8 | this[t6 + 2] << 16 | this[t6 + 3] << 24;
}, u$1$1.prototype.readInt32BE = function(t6, r6) {
  return t6 >>>= 0, r6 || x4(t6, 4, this.length), this[t6] << 24 | this[t6 + 1] << 16 | this[t6 + 2] << 8 | this[t6 + 3];
}, u$1$1.prototype.readFloatLE = function(t6, r6) {
  return t6 >>>= 0, r6 || x4(t6, 4, this.length), i$14.read(this, t6, true, 23, 4);
}, u$1$1.prototype.readFloatBE = function(t6, r6) {
  return t6 >>>= 0, r6 || x4(t6, 4, this.length), i$14.read(this, t6, false, 23, 4);
}, u$1$1.prototype.readDoubleLE = function(t6, r6) {
  return t6 >>>= 0, r6 || x4(t6, 8, this.length), i$14.read(this, t6, true, 52, 8);
}, u$1$1.prototype.readDoubleBE = function(t6, r6) {
  return t6 >>>= 0, r6 || x4(t6, 8, this.length), i$14.read(this, t6, false, 52, 8);
}, u$1$1.prototype.writeUIntLE = function(t6, r6, e7, n6) {
  (t6 = +t6, r6 >>>= 0, e7 >>>= 0, n6) || C3(this, t6, r6, e7, Math.pow(2, 8 * e7) - 1, 0);
  var i5 = 1, o5 = 0;
  for (this[r6] = 255 & t6; ++o5 < e7 && (i5 *= 256); ) this[r6 + o5] = t6 / i5 & 255;
  return r6 + e7;
}, u$1$1.prototype.writeUIntBE = function(t6, r6, e7, n6) {
  (t6 = +t6, r6 >>>= 0, e7 >>>= 0, n6) || C3(this, t6, r6, e7, Math.pow(2, 8 * e7) - 1, 0);
  var i5 = e7 - 1, o5 = 1;
  for (this[r6 + i5] = 255 & t6; --i5 >= 0 && (o5 *= 256); ) this[r6 + i5] = t6 / o5 & 255;
  return r6 + e7;
}, u$1$1.prototype.writeUInt8 = function(t6, r6, e7) {
  return t6 = +t6, r6 >>>= 0, e7 || C3(this, t6, r6, 1, 255, 0), this[r6] = 255 & t6, r6 + 1;
}, u$1$1.prototype.writeUInt16LE = function(t6, r6, e7) {
  return t6 = +t6, r6 >>>= 0, e7 || C3(this, t6, r6, 2, 65535, 0), this[r6] = 255 & t6, this[r6 + 1] = t6 >>> 8, r6 + 2;
}, u$1$1.prototype.writeUInt16BE = function(t6, r6, e7) {
  return t6 = +t6, r6 >>>= 0, e7 || C3(this, t6, r6, 2, 65535, 0), this[r6] = t6 >>> 8, this[r6 + 1] = 255 & t6, r6 + 2;
}, u$1$1.prototype.writeUInt32LE = function(t6, r6, e7) {
  return t6 = +t6, r6 >>>= 0, e7 || C3(this, t6, r6, 4, 4294967295, 0), this[r6 + 3] = t6 >>> 24, this[r6 + 2] = t6 >>> 16, this[r6 + 1] = t6 >>> 8, this[r6] = 255 & t6, r6 + 4;
}, u$1$1.prototype.writeUInt32BE = function(t6, r6, e7) {
  return t6 = +t6, r6 >>>= 0, e7 || C3(this, t6, r6, 4, 4294967295, 0), this[r6] = t6 >>> 24, this[r6 + 1] = t6 >>> 16, this[r6 + 2] = t6 >>> 8, this[r6 + 3] = 255 & t6, r6 + 4;
}, u$1$1.prototype.writeIntLE = function(t6, r6, e7, n6) {
  if (t6 = +t6, r6 >>>= 0, !n6) {
    var i5 = Math.pow(2, 8 * e7 - 1);
    C3(this, t6, r6, e7, i5 - 1, -i5);
  }
  var o5 = 0, f5 = 1, u5 = 0;
  for (this[r6] = 255 & t6; ++o5 < e7 && (f5 *= 256); ) t6 < 0 && 0 === u5 && 0 !== this[r6 + o5 - 1] && (u5 = 1), this[r6 + o5] = (t6 / f5 >> 0) - u5 & 255;
  return r6 + e7;
}, u$1$1.prototype.writeIntBE = function(t6, r6, e7, n6) {
  if (t6 = +t6, r6 >>>= 0, !n6) {
    var i5 = Math.pow(2, 8 * e7 - 1);
    C3(this, t6, r6, e7, i5 - 1, -i5);
  }
  var o5 = e7 - 1, f5 = 1, u5 = 0;
  for (this[r6 + o5] = 255 & t6; --o5 >= 0 && (f5 *= 256); ) t6 < 0 && 0 === u5 && 0 !== this[r6 + o5 + 1] && (u5 = 1), this[r6 + o5] = (t6 / f5 >> 0) - u5 & 255;
  return r6 + e7;
}, u$1$1.prototype.writeInt8 = function(t6, r6, e7) {
  return t6 = +t6, r6 >>>= 0, e7 || C3(this, t6, r6, 1, 127, -128), t6 < 0 && (t6 = 255 + t6 + 1), this[r6] = 255 & t6, r6 + 1;
}, u$1$1.prototype.writeInt16LE = function(t6, r6, e7) {
  return t6 = +t6, r6 >>>= 0, e7 || C3(this, t6, r6, 2, 32767, -32768), this[r6] = 255 & t6, this[r6 + 1] = t6 >>> 8, r6 + 2;
}, u$1$1.prototype.writeInt16BE = function(t6, r6, e7) {
  return t6 = +t6, r6 >>>= 0, e7 || C3(this, t6, r6, 2, 32767, -32768), this[r6] = t6 >>> 8, this[r6 + 1] = 255 & t6, r6 + 2;
}, u$1$1.prototype.writeInt32LE = function(t6, r6, e7) {
  return t6 = +t6, r6 >>>= 0, e7 || C3(this, t6, r6, 4, 2147483647, -2147483648), this[r6] = 255 & t6, this[r6 + 1] = t6 >>> 8, this[r6 + 2] = t6 >>> 16, this[r6 + 3] = t6 >>> 24, r6 + 4;
}, u$1$1.prototype.writeInt32BE = function(t6, r6, e7) {
  return t6 = +t6, r6 >>>= 0, e7 || C3(this, t6, r6, 4, 2147483647, -2147483648), t6 < 0 && (t6 = 4294967295 + t6 + 1), this[r6] = t6 >>> 24, this[r6 + 1] = t6 >>> 16, this[r6 + 2] = t6 >>> 8, this[r6 + 3] = 255 & t6, r6 + 4;
}, u$1$1.prototype.writeFloatLE = function(t6, r6, e7) {
  return k4(this, t6, r6, true, e7);
}, u$1$1.prototype.writeFloatBE = function(t6, r6, e7) {
  return k4(this, t6, r6, false, e7);
}, u$1$1.prototype.writeDoubleLE = function(t6, r6, e7) {
  return M3(this, t6, r6, true, e7);
}, u$1$1.prototype.writeDoubleBE = function(t6, r6, e7) {
  return M3(this, t6, r6, false, e7);
}, u$1$1.prototype.copy = function(t6, r6, e7, n6) {
  if (!u$1$1.isBuffer(t6)) throw new TypeError("argument should be a Buffer");
  if (e7 || (e7 = 0), n6 || 0 === n6 || (n6 = this.length), r6 >= t6.length && (r6 = t6.length), r6 || (r6 = 0), n6 > 0 && n6 < e7 && (n6 = e7), n6 === e7) return 0;
  if (0 === t6.length || 0 === this.length) return 0;
  if (r6 < 0) throw new RangeError("targetStart out of bounds");
  if (e7 < 0 || e7 >= this.length) throw new RangeError("Index out of range");
  if (n6 < 0) throw new RangeError("sourceEnd out of bounds");
  n6 > this.length && (n6 = this.length), t6.length - r6 < n6 - e7 && (n6 = t6.length - r6 + e7);
  var i5 = n6 - e7;
  if (this === t6 && "function" == typeof Uint8Array.prototype.copyWithin) this.copyWithin(r6, e7, n6);
  else if (this === t6 && e7 < r6 && r6 < n6) for (var o5 = i5 - 1; o5 >= 0; --o5) t6[o5 + r6] = this[o5 + e7];
  else Uint8Array.prototype.set.call(t6, this.subarray(e7, n6), r6);
  return i5;
}, u$1$1.prototype.fill = function(t6, r6, e7, n6) {
  if ("string" == typeof t6) {
    if ("string" == typeof r6 ? (n6 = r6, r6 = 0, e7 = this.length) : "string" == typeof e7 && (n6 = e7, e7 = this.length), void 0 !== n6 && "string" != typeof n6) throw new TypeError("encoding must be a string");
    if ("string" == typeof n6 && !u$1$1.isEncoding(n6)) throw new TypeError("Unknown encoding: " + n6);
    if (1 === t6.length) {
      var i5 = t6.charCodeAt(0);
      ("utf8" === n6 && i5 < 128 || "latin1" === n6) && (t6 = i5);
    }
  } else "number" == typeof t6 ? t6 &= 255 : "boolean" == typeof t6 && (t6 = Number(t6));
  if (r6 < 0 || this.length < r6 || this.length < e7) throw new RangeError("Out of range index");
  if (e7 <= r6) return this;
  var o5;
  if (r6 >>>= 0, e7 = void 0 === e7 ? this.length : e7 >>> 0, t6 || (t6 = 0), "number" == typeof t6) for (o5 = r6; o5 < e7; ++o5) this[o5] = t6;
  else {
    var f5 = u$1$1.isBuffer(t6) ? t6 : u$1$1.from(t6, n6), s5 = f5.length;
    if (0 === s5) throw new TypeError('The value "' + t6 + '" is invalid for argument "value"');
    for (o5 = 0; o5 < e7 - r6; ++o5) this[o5 + r6] = f5[o5 % s5];
  }
  return this;
};
var j3 = /[^+/0-9A-Za-z-_]/g;
function _3(t6, r6) {
  var e7;
  r6 = r6 || 1 / 0;
  for (var n6 = t6.length, i5 = null, o5 = [], f5 = 0; f5 < n6; ++f5) {
    if ((e7 = t6.charCodeAt(f5)) > 55295 && e7 < 57344) {
      if (!i5) {
        if (e7 > 56319) {
          (r6 -= 3) > -1 && o5.push(239, 191, 189);
          continue;
        }
        if (f5 + 1 === n6) {
          (r6 -= 3) > -1 && o5.push(239, 191, 189);
          continue;
        }
        i5 = e7;
        continue;
      }
      if (e7 < 56320) {
        (r6 -= 3) > -1 && o5.push(239, 191, 189), i5 = e7;
        continue;
      }
      e7 = 65536 + (i5 - 55296 << 10 | e7 - 56320);
    } else i5 && (r6 -= 3) > -1 && o5.push(239, 191, 189);
    if (i5 = null, e7 < 128) {
      if ((r6 -= 1) < 0) break;
      o5.push(e7);
    } else if (e7 < 2048) {
      if ((r6 -= 2) < 0) break;
      o5.push(e7 >> 6 | 192, 63 & e7 | 128);
    } else if (e7 < 65536) {
      if ((r6 -= 3) < 0) break;
      o5.push(e7 >> 12 | 224, e7 >> 6 & 63 | 128, 63 & e7 | 128);
    } else {
      if (!(e7 < 1114112)) throw new Error("Invalid code point");
      if ((r6 -= 4) < 0) break;
      o5.push(e7 >> 18 | 240, e7 >> 12 & 63 | 128, e7 >> 6 & 63 | 128, 63 & e7 | 128);
    }
  }
  return o5;
}
function z3(t6) {
  return n$1$1.toByteArray(function(t7) {
    if ((t7 = (t7 = t7.split("=")[0]).trim().replace(j3, "")).length < 2) return "";
    for (; t7.length % 4 != 0; ) t7 += "=";
    return t7;
  }(t6));
}
function D4(t6, r6, e7, n6) {
  for (var i5 = 0; i5 < n6 && !(i5 + e7 >= r6.length || i5 >= t6.length); ++i5) r6[i5 + e7] = t6[i5];
  return i5;
}
function F4(t6, r6) {
  return t6 instanceof r6 || null != t6 && null != t6.constructor && null != t6.constructor.name && t6.constructor.name === r6.name;
}
function N3(t6) {
  return t6 != t6;
}
var Y3 = function() {
  for (var t6 = new Array(256), r6 = 0; r6 < 16; ++r6) for (var e7 = 16 * r6, n6 = 0; n6 < 16; ++n6) t6[e7 + n6] = "0123456789abcdef"[r6] + "0123456789abcdef"[n6];
  return t6;
}();
e$1$1.Buffer;
e$1$1.INSPECT_MAX_BYTES;
e$1$1.kMaxLength;
var e6 = {};
var n5 = e$1$1;
var o4 = n5.Buffer;
function t5(r6, e7) {
  for (var n6 in r6) e7[n6] = r6[n6];
}
function f4(r6, e7, n6) {
  return o4(r6, e7, n6);
}
o4.from && o4.alloc && o4.allocUnsafe && o4.allocUnsafeSlow ? e6 = n5 : (t5(n5, e6), e6.Buffer = f4), f4.prototype = Object.create(o4.prototype), t5(o4, f4), f4.from = function(r6, e7, n6) {
  if ("number" == typeof r6) throw new TypeError("Argument must not be a number");
  return o4(r6, e7, n6);
}, f4.alloc = function(r6, e7, n6) {
  if ("number" != typeof r6) throw new TypeError("Argument must be a number");
  var t6 = o4(r6);
  return void 0 !== e7 ? "string" == typeof n6 ? t6.fill(e7, n6) : t6.fill(e7) : t6.fill(0), t6;
}, f4.allocUnsafe = function(r6) {
  if ("number" != typeof r6) throw new TypeError("Argument must be a number");
  return o4(r6);
}, f4.allocUnsafeSlow = function(r6) {
  if ("number" != typeof r6) throw new TypeError("Argument must be a number");
  return n5.SlowBuffer(r6);
};
var u4 = e6;
var e$14 = {};
var s4 = u4.Buffer;
var i4 = s4.isEncoding || function(t6) {
  switch ((t6 = "" + t6) && t6.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return true;
    default:
      return false;
  }
};
function a4(t6) {
  var e7;
  switch (this.encoding = function(t7) {
    var e8 = function(t8) {
      if (!t8) return "utf8";
      for (var e9; ; ) switch (t8) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return t8;
        default:
          if (e9) return;
          t8 = ("" + t8).toLowerCase(), e9 = true;
      }
    }(t7);
    if ("string" != typeof e8 && (s4.isEncoding === i4 || !i4(t7))) throw new Error("Unknown encoding: " + t7);
    return e8 || t7;
  }(t6), this.encoding) {
    case "utf16le":
      this.text = h5, this.end = l4, e7 = 4;
      break;
    case "utf8":
      this.fillLast = n$14, e7 = 4;
      break;
    case "base64":
      this.text = u$14, this.end = o$14, e7 = 3;
      break;
    default:
      return this.write = f$14, this.end = c4, void 0;
  }
  this.lastNeed = 0, this.lastTotal = 0, this.lastChar = s4.allocUnsafe(e7);
}
function r5(t6) {
  return t6 <= 127 ? 0 : t6 >> 5 == 6 ? 2 : t6 >> 4 == 14 ? 3 : t6 >> 3 == 30 ? 4 : t6 >> 6 == 2 ? -1 : -2;
}
function n$14(t6) {
  var e7 = this.lastTotal - this.lastNeed, s5 = function(t7, e8, s6) {
    if (128 != (192 & e8[0])) return t7.lastNeed = 0, "\uFFFD";
    if (t7.lastNeed > 1 && e8.length > 1) {
      if (128 != (192 & e8[1])) return t7.lastNeed = 1, "\uFFFD";
      if (t7.lastNeed > 2 && e8.length > 2 && 128 != (192 & e8[2])) return t7.lastNeed = 2, "\uFFFD";
    }
  }(this, t6);
  return void 0 !== s5 ? s5 : this.lastNeed <= t6.length ? (t6.copy(this.lastChar, e7, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (t6.copy(this.lastChar, e7, 0, t6.length), this.lastNeed -= t6.length, void 0);
}
function h5(t6, e7) {
  if ((t6.length - e7) % 2 == 0) {
    var s5 = t6.toString("utf16le", e7);
    if (s5) {
      var i5 = s5.charCodeAt(s5.length - 1);
      if (i5 >= 55296 && i5 <= 56319) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = t6[t6.length - 2], this.lastChar[1] = t6[t6.length - 1], s5.slice(0, -1);
    }
    return s5;
  }
  return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = t6[t6.length - 1], t6.toString("utf16le", e7, t6.length - 1);
}
function l4(t6) {
  var e7 = t6 && t6.length ? this.write(t6) : "";
  if (this.lastNeed) {
    var s5 = this.lastTotal - this.lastNeed;
    return e7 + this.lastChar.toString("utf16le", 0, s5);
  }
  return e7;
}
function u$14(t6, e7) {
  var s5 = (t6.length - e7) % 3;
  return 0 === s5 ? t6.toString("base64", e7) : (this.lastNeed = 3 - s5, this.lastTotal = 3, 1 === s5 ? this.lastChar[0] = t6[t6.length - 1] : (this.lastChar[0] = t6[t6.length - 2], this.lastChar[1] = t6[t6.length - 1]), t6.toString("base64", e7, t6.length - s5));
}
function o$14(t6) {
  var e7 = t6 && t6.length ? this.write(t6) : "";
  return this.lastNeed ? e7 + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : e7;
}
function f$14(t6) {
  return t6.toString(this.encoding);
}
function c4(t6) {
  return t6 && t6.length ? this.write(t6) : "";
}
e$14.StringDecoder = a4, a4.prototype.write = function(t6) {
  if (0 === t6.length) return "";
  var e7, s5;
  if (this.lastNeed) {
    if (void 0 === (e7 = this.fillLast(t6))) return "";
    s5 = this.lastNeed, this.lastNeed = 0;
  } else s5 = 0;
  return s5 < t6.length ? e7 ? e7 + this.text(t6, s5) : this.text(t6, s5) : e7 || "";
}, a4.prototype.end = function(t6) {
  var e7 = t6 && t6.length ? this.write(t6) : "";
  return this.lastNeed ? e7 + "\uFFFD" : e7;
}, a4.prototype.text = function(t6, e7) {
  var s5 = function(t7, e8, s6) {
    var i6 = e8.length - 1;
    if (i6 < s6) return 0;
    var a5 = r5(e8[i6]);
    if (a5 >= 0) return a5 > 0 && (t7.lastNeed = a5 - 1), a5;
    if (--i6 < s6 || -2 === a5) return 0;
    if ((a5 = r5(e8[i6])) >= 0) return a5 > 0 && (t7.lastNeed = a5 - 2), a5;
    if (--i6 < s6 || -2 === a5) return 0;
    if ((a5 = r5(e8[i6])) >= 0) return a5 > 0 && (2 === a5 ? a5 = 0 : t7.lastNeed = a5 - 3), a5;
    return 0;
  }(this, t6, e7);
  if (!this.lastNeed) return t6.toString("utf8", e7);
  this.lastTotal = s5;
  var i5 = t6.length - (s5 - this.lastNeed);
  return t6.copy(this.lastChar, 0, i5), t6.toString("utf8", e7, i5);
}, a4.prototype.fillLast = function(t6) {
  if (this.lastNeed <= t6.length) return t6.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  t6.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, t6.length), this.lastNeed -= t6.length;
};
var exports$2$1 = {};
var _dewExec$2$1 = false;
function dew$2$1() {
  if (_dewExec$2$1) return exports$2$1;
  _dewExec$2$1 = true;
  exports$2$1.byteLength = byteLength;
  exports$2$1.toByteArray = toByteArray;
  exports$2$1.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i5 = 0, len = code.length; i5 < len; ++i5) {
    lookup[i5] = code[i5];
    revLookup[code.charCodeAt(i5)] = i5;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1) validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i6;
    for (i6 = 0; i6 < len2; i6 += 4) {
      tmp = revLookup[b64.charCodeAt(i6)] << 18 | revLookup[b64.charCodeAt(i6 + 1)] << 12 | revLookup[b64.charCodeAt(i6 + 2)] << 6 | revLookup[b64.charCodeAt(i6 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i6)] << 2 | revLookup[b64.charCodeAt(i6 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i6)] << 10 | revLookup[b64.charCodeAt(i6 + 1)] << 4 | revLookup[b64.charCodeAt(i6 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num2) {
    return lookup[num2 >> 18 & 63] + lookup[num2 >> 12 & 63] + lookup[num2 >> 6 & 63] + lookup[num2 & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i6 = start; i6 < end; i6 += 3) {
      tmp = (uint8[i6] << 16 & 16711680) + (uint8[i6 + 1] << 8 & 65280) + (uint8[i6 + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i6 = 0, len22 = len2 - extraBytes; i6 < len22; i6 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i6, i6 + maxChunkLength > len22 ? len22 : i6 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
    }
    return parts.join("");
  }
  return exports$2$1;
}
var exports$1$1 = {};
var _dewExec$1$1 = false;
function dew$1$1() {
  if (_dewExec$1$1) return exports$1$1;
  _dewExec$1$1 = true;
  exports$1$1.read = function(buffer2, offset, isLE, mLen, nBytes) {
    var e7, m7;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i5 = isLE ? nBytes - 1 : 0;
    var d5 = isLE ? -1 : 1;
    var s5 = buffer2[offset + i5];
    i5 += d5;
    e7 = s5 & (1 << -nBits) - 1;
    s5 >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e7 = e7 * 256 + buffer2[offset + i5], i5 += d5, nBits -= 8) {
    }
    m7 = e7 & (1 << -nBits) - 1;
    e7 >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m7 = m7 * 256 + buffer2[offset + i5], i5 += d5, nBits -= 8) {
    }
    if (e7 === 0) {
      e7 = 1 - eBias;
    } else if (e7 === eMax) {
      return m7 ? NaN : (s5 ? -1 : 1) * Infinity;
    } else {
      m7 = m7 + Math.pow(2, mLen);
      e7 = e7 - eBias;
    }
    return (s5 ? -1 : 1) * m7 * Math.pow(2, e7 - mLen);
  };
  exports$1$1.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
    var e7, m7, c5;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i5 = isLE ? 0 : nBytes - 1;
    var d5 = isLE ? 1 : -1;
    var s5 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m7 = isNaN(value) ? 1 : 0;
      e7 = eMax;
    } else {
      e7 = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c5 = Math.pow(2, -e7)) < 1) {
        e7--;
        c5 *= 2;
      }
      if (e7 + eBias >= 1) {
        value += rt / c5;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c5 >= 2) {
        e7++;
        c5 /= 2;
      }
      if (e7 + eBias >= eMax) {
        m7 = 0;
        e7 = eMax;
      } else if (e7 + eBias >= 1) {
        m7 = (value * c5 - 1) * Math.pow(2, mLen);
        e7 = e7 + eBias;
      } else {
        m7 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e7 = 0;
      }
    }
    for (; mLen >= 8; buffer2[offset + i5] = m7 & 255, i5 += d5, m7 /= 256, mLen -= 8) {
    }
    e7 = e7 << mLen | m7;
    eLen += mLen;
    for (; eLen > 0; buffer2[offset + i5] = e7 & 255, i5 += d5, e7 /= 256, eLen -= 8) {
    }
    buffer2[offset + i5 - d5] |= s5 * 128;
  };
  return exports$1$1;
}
var exports$g = {};
var _dewExec$g = false;
function dew$g() {
  if (_dewExec$g) return exports$g;
  _dewExec$g = true;
  const base64 = dew$2$1();
  const ieee754 = dew$1$1();
  const customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports$g.Buffer = Buffer3;
  exports$g.SlowBuffer = SlowBuffer;
  exports$g.INSPECT_MAX_BYTES = 50;
  const K_MAX_LENGTH = 2147483647;
  exports$g.kMaxLength = K_MAX_LENGTH;
  Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  }
  function typedArraySupport() {
    try {
      const arr = new Uint8Array(1);
      const proto = {
        foo: function() {
          return 42;
        }
      };
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e7) {
      return false;
    }
  }
  Object.defineProperty(Buffer3.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer3.isBuffer(this)) return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer3.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer3.isBuffer(this)) return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer3.prototype);
    return buf;
  }
  function Buffer3(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError('The "string" argument must be of type string. Received type number');
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer3.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer3.from(valueOf, encodingOrOffset, length);
    }
    const b6 = fromObject(value);
    if (b6) return b6;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
  }
  Buffer3.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer3, Uint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer3.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer3.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer3.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer3.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for (let i5 = 0; i5 < length; i5 += 1) {
      buf[i5] = array[i5] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      const copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array);
    } else if (length === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer3.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer3.isBuffer(obj)) {
      const len = checked(obj.length) | 0;
      const buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer3.alloc(+length);
  }
  Buffer3.isBuffer = function isBuffer(b6) {
    return b6 != null && b6._isBuffer === true && b6 !== Buffer3.prototype;
  };
  Buffer3.compare = function compare(a5, b6) {
    if (isInstance(a5, Uint8Array)) a5 = Buffer3.from(a5, a5.offset, a5.byteLength);
    if (isInstance(b6, Uint8Array)) b6 = Buffer3.from(b6, b6.offset, b6.byteLength);
    if (!Buffer3.isBuffer(a5) || !Buffer3.isBuffer(b6)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a5 === b6) return 0;
    let x5 = a5.length;
    let y7 = b6.length;
    for (let i5 = 0, len = Math.min(x5, y7); i5 < len; ++i5) {
      if (a5[i5] !== b6[i5]) {
        x5 = a5[i5];
        y7 = b6[i5];
        break;
      }
    }
    if (x5 < y7) return -1;
    if (y7 < x5) return 1;
    return 0;
  };
  Buffer3.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer3.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer3.alloc(0);
    }
    let i5;
    if (length === void 0) {
      length = 0;
      for (i5 = 0; i5 < list.length; ++i5) {
        length += list[i5].length;
      }
    }
    const buffer2 = Buffer3.allocUnsafe(length);
    let pos = 0;
    for (i5 = 0; i5 < list.length; ++i5) {
      let buf = list[i5];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer2.length) {
          if (!Buffer3.isBuffer(buf)) buf = Buffer3.from(buf);
          buf.copy(buffer2, pos);
        } else {
          Uint8Array.prototype.set.call(buffer2, buf, pos);
        }
      } else if (!Buffer3.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer2, pos);
      }
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength(string, encoding) {
    if (Buffer3.isBuffer(string)) {
      return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer3.byteLength = byteLength;
  function slowToString(encoding, start, end) {
    let loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding) encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer3.prototype._isBuffer = true;
  function swap(b6, n6, m7) {
    const i5 = b6[n6];
    b6[n6] = b6[m7];
    b6[m7] = i5;
  }
  Buffer3.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (let i5 = 0; i5 < len; i5 += 2) {
      swap(this, i5, i5 + 1);
    }
    return this;
  };
  Buffer3.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (let i5 = 0; i5 < len; i5 += 4) {
      swap(this, i5, i5 + 3);
      swap(this, i5 + 1, i5 + 2);
    }
    return this;
  };
  Buffer3.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (let i5 = 0; i5 < len; i5 += 8) {
      swap(this, i5, i5 + 7);
      swap(this, i5 + 1, i5 + 6);
      swap(this, i5 + 2, i5 + 5);
      swap(this, i5 + 3, i5 + 4);
    }
    return this;
  };
  Buffer3.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0) return "";
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
  Buffer3.prototype.equals = function equals(b6) {
    if (!Buffer3.isBuffer(b6)) throw new TypeError("Argument must be a Buffer");
    if (this === b6) return true;
    return Buffer3.compare(this, b6) === 0;
  };
  Buffer3.prototype.inspect = function inspect() {
    let str = "";
    const max = exports$g.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max) str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
  }
  Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer3.from(target, target.offset, target.byteLength);
    }
    if (!Buffer3.isBuffer(target)) {
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x5 = thisEnd - thisStart;
    let y7 = end - start;
    const len = Math.min(x5, y7);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for (let i5 = 0; i5 < len; ++i5) {
      if (thisCopy[i5] !== targetCopy[i5]) {
        x5 = thisCopy[i5];
        y7 = targetCopy[i5];
        break;
      }
    }
    if (x5 < y7) return -1;
    if (y7 < x5) return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0) return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0) byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir) return -1;
      else byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;
      else return -1;
    }
    if (typeof val === "string") {
      val = Buffer3.from(val, encoding);
    }
    if (Buffer3.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read2(buf, i6) {
      if (indexSize === 1) {
        return buf[i6];
      } else {
        return buf.readUInt16BE(i6 * indexSize);
      }
    }
    let i5;
    if (dir) {
      let foundIndex = -1;
      for (i5 = byteOffset; i5 < arrLength; i5++) {
        if (read2(arr, i5) === read2(val, foundIndex === -1 ? 0 : i5 - foundIndex)) {
          if (foundIndex === -1) foundIndex = i5;
          if (i5 - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1) i5 -= i5 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
      for (i5 = byteOffset; i5 >= 0; i5--) {
        let found = true;
        for (let j4 = 0; j4 < valLength; j4++) {
          if (read2(arr, i5 + j4) !== read2(val, j4)) {
            found = false;
            break;
          }
        }
        if (found) return i5;
      }
    }
    return -1;
  }
  Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    let i5;
    for (i5 = 0; i5 < length; ++i5) {
      const parsed = parseInt(string.substr(i5 * 2, 2), 16);
      if (numberIsNaN(parsed)) return i5;
      buf[offset + i5] = parsed;
    }
    return i5;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer3.prototype.write = function write2(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0) encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    }
    const remaining = this.length - offset;
    if (length === void 0 || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding) encoding = "utf8";
    let loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer3.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i5 = start;
    while (i5 < end) {
      const firstByte = buf[i5];
      let codePoint = null;
      let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i5 + bytesPerSequence <= end) {
        let secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i5 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i5 + 1];
            thirdByte = buf[i5 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i5 + 1];
            thirdByte = buf[i5 + 2];
            fourthByte = buf[i5 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i5 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  const MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    let res = "";
    let i5 = 0;
    while (i5 < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i5, i5 += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i5 = start; i5 < end; ++i5) {
      ret += String.fromCharCode(buf[i5] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    let ret = "";
    end = Math.min(buf.length, end);
    for (let i5 = start; i5 < end; ++i5) {
      ret += String.fromCharCode(buf[i5]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = "";
    for (let i5 = start; i5 < end; ++i5) {
      out += hexSliceLookupTable[buf[i5]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = "";
    for (let i5 = 0; i5 < bytes.length - 1; i5 += 2) {
      res += String.fromCharCode(bytes[i5] + bytes[i5 + 1] * 256);
    }
    return res;
  }
  Buffer3.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer3.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength2, this.length);
    let val = this[offset];
    let mul = 1;
    let i5 = 0;
    while (++i5 < byteLength2 && (mul *= 256)) {
      val += this[offset + i5] * mul;
    }
    return val;
  };
  Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength2, this.length);
    }
    let val = this[offset + --byteLength2];
    let mul = 1;
    while (byteLength2 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength2] * mul;
    }
    return val;
  };
  Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
  });
  Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
  });
  Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength2, this.length);
    let val = this[offset];
    let mul = 1;
    let i5 = 0;
    while (++i5 < byteLength2 && (mul *= 256)) {
      val += this[offset + i5] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) checkOffset(offset, byteLength2, this.length);
    let i5 = byteLength2;
    let mul = 1;
    let val = this[offset + --i5];
    while (i5 > 0 && (mul *= 256)) {
      val += this[offset + --i5] * mul;
    }
    mul *= 128;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128)) return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
  });
  Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, "offset");
    const first = this[offset];
    const last = this[offset + 7];
    if (first === void 0 || last === void 0) {
      boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
  });
  Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
  };
  Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
  };
  Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
  };
  Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer3.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
  }
  Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    let mul = 1;
    let i5 = 0;
    this[offset] = value & 255;
    while (++i5 < byteLength2 && (mul *= 256)) {
      this[offset + i5] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    let i5 = byteLength2 - 1;
    let mul = 1;
    this[offset + i5] = value & 255;
    while (--i5 >= 0 && (mul *= 256)) {
      this[offset + i5] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
  }
  function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(4294967295));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(4294967295));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
  }
  Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
  });
  Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    let i5 = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 255;
    while (++i5 < byteLength2 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i5 - 1] !== 0) {
        sub = 1;
      }
      this[offset + i5] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      const limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    let i5 = byteLength2 - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i5] = value & 255;
    while (--i5 >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i5 + 1] !== 0) {
        sub = 1;
      }
      this[offset + i5] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
    if (value < 0) value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0) value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError("Index out of range");
    if (offset < 0) throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer3.isBuffer(target)) throw new TypeError("argument should be a Buffer");
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
    if (end < 0) throw new RangeError("sourceEnd out of bounds");
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    }
    return len;
  };
  Buffer3.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        const code = val.charCodeAt(0);
        if (encoding === "utf8" && code < 128 || encoding === "latin1") {
          val = code;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val) val = 0;
    let i5;
    if (typeof val === "number") {
      for (i5 = start; i5 < end; ++i5) {
        this[i5] = val;
      }
    } else {
      const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
      const len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i5 = 0; i5 < end - start; ++i5) {
        this[i5 + start] = bytes[i5 % len];
      }
    }
    return this;
  };
  const errors = {};
  function E4(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
      constructor() {
        super();
        Object.defineProperty(this, "message", {
          value: getMessage.apply(this, arguments),
          writable: true,
          configurable: true
        });
        this.name = `${this.name} [${sym}]`;
        this.stack;
        delete this.name;
      }
      get code() {
        return sym;
      }
      set code(value) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${sym}]: ${this.message}`;
      }
    };
  }
  E4("ERR_BUFFER_OUT_OF_BOUNDS", function(name2) {
    if (name2) {
      return `${name2} is outside of buffer bounds`;
    }
    return "Attempt to access memory outside buffer bounds";
  }, RangeError);
  E4("ERR_INVALID_ARG_TYPE", function(name2, actual) {
    return `The "${name2}" argument must be of type number. Received type ${typeof actual}`;
  }, TypeError);
  E4("ERR_OUT_OF_RANGE", function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
      received = addNumericalSeparator(String(input));
    } else if (typeof input === "bigint") {
      received = String(input);
      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
        received = addNumericalSeparator(received);
      }
      received += "n";
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg;
  }, RangeError);
  function addNumericalSeparator(val) {
    let res = "";
    let i5 = val.length;
    const start = val[0] === "-" ? 1 : 0;
    for (; i5 >= start + 4; i5 -= 3) {
      res = `_${val.slice(i5 - 3, i5)}${res}`;
    }
    return `${val.slice(0, i5)}${res}`;
  }
  function checkBounds(buf, offset, byteLength2) {
    validateNumber(offset, "offset");
    if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
      boundsError(offset, buf.length - (byteLength2 + 1));
    }
  }
  function checkIntBI(value, min, max, buf, offset, byteLength2) {
    if (value > max || value < min) {
      const n6 = typeof min === "bigint" ? "n" : "";
      let range;
      {
        if (min === 0 || min === BigInt(0)) {
          range = `>= 0${n6} and < 2${n6} ** ${(byteLength2 + 1) * 8}${n6}`;
        } else {
          range = `>= -(2${n6} ** ${(byteLength2 + 1) * 8 - 1}${n6}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n6}`;
        }
      }
      throw new errors.ERR_OUT_OF_RANGE("value", range, value);
    }
    checkBounds(buf, offset, byteLength2);
  }
  function validateNumber(value, name2) {
    if (typeof value !== "number") {
      throw new errors.ERR_INVALID_ARG_TYPE(name2, "number", value);
    }
  }
  function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
      validateNumber(value, type);
      throw new errors.ERR_OUT_OF_RANGE("offset", "an integer", value);
    }
    if (length < 0) {
      throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE("offset", `>= ${0} and <= ${length}`, value);
  }
  const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2) return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for (let i5 = 0; i5 < length; ++i5) {
      codePoint = string.charCodeAt(i5);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          } else if (i5 + 1 === length) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1) bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0) break;
        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0) break;
        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0) break;
        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    const byteArray = [];
    for (let i5 = 0; i5 < str.length; ++i5) {
      byteArray.push(str.charCodeAt(i5) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    let c5, hi, lo;
    const byteArray = [];
    for (let i5 = 0; i5 < str.length; ++i5) {
      if ((units -= 2) < 0) break;
      c5 = str.charCodeAt(i5);
      hi = c5 >> 8;
      lo = c5 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    let i5;
    for (i5 = 0; i5 < length; ++i5) {
      if (i5 + offset >= dst.length || i5 >= src.length) break;
      dst[i5 + offset] = src[i5];
    }
    return i5;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  const hexSliceLookupTable = function() {
    const alphabet = "0123456789abcdef";
    const table = new Array(256);
    for (let i5 = 0; i5 < 16; ++i5) {
      const i16 = i5 * 16;
      for (let j4 = 0; j4 < 16; ++j4) {
        table[i16 + j4] = alphabet[i5] + alphabet[j4];
      }
    }
    return table;
  }();
  function defineBigIntMethod(fn) {
    return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
  }
  function BufferBigIntNotDefined() {
    throw new Error("BigInt not supported");
  }
  return exports$g;
}
var buffer = dew$g();
buffer.Buffer;
buffer.INSPECT_MAX_BYTES;
buffer.kMaxLength;
var exports$f = {};
var _dewExec$f = false;
function dew$f() {
  if (_dewExec$f) return exports$f;
  _dewExec$f = true;
  if (typeof Object.create === "function") {
    exports$f = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    exports$f = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return exports$f;
}
var exports$e = {};
var _dewExec$e = false;
function dew$e() {
  if (_dewExec$e) return exports$e;
  _dewExec$e = true;
  exports$e = y5.EventEmitter;
  return exports$e;
}
var exports$d = {};
var _dewExec$d = false;
function dew$d() {
  if (_dewExec$d) return exports$d;
  _dewExec$d = true;
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i5 = 1; i5 < arguments.length; i5++) {
      var source = arguments[i5] != null ? arguments[i5] : {};
      if (i5 % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i5 = 0; i5 < props.length; i5++) {
      var descriptor = props[i5];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    return Constructor;
  }
  var _require = buffer, Buffer3 = _require.Buffer;
  var _require2 = X, inspect = _require2.inspect;
  var custom = inspect && inspect.custom || "inspect";
  function copyBuffer(src, target, offset) {
    Buffer3.prototype.copy.call(src, target, offset);
  }
  exports$d = /* @__PURE__ */ function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList, [{
      key: "push",
      value: function push(v11) {
        var entry = {
          data: v11,
          next: null
        };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v11) {
        var entry = {
          data: v11,
          next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join2(s5) {
        if (this.length === 0) return "";
        var p5 = this.head;
        var ret = "" + p5.data;
        while (p5 = p5.next) {
          ret += s5 + p5.data;
        }
        return ret;
      }
    }, {
      key: "concat",
      value: function concat(n6) {
        if (this.length === 0) return Buffer3.alloc(0);
        var ret = Buffer3.allocUnsafe(n6 >>> 0);
        var p5 = this.head;
        var i5 = 0;
        while (p5) {
          copyBuffer(p5.data, ret, i5);
          i5 += p5.data.length;
          p5 = p5.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function consume(n6, hasStrings) {
        var ret;
        if (n6 < this.head.data.length) {
          ret = this.head.data.slice(0, n6);
          this.head.data = this.head.data.slice(n6);
        } else if (n6 === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n6) : this._getBuffer(n6);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function _getString(n6) {
        var p5 = this.head;
        var c5 = 1;
        var ret = p5.data;
        n6 -= ret.length;
        while (p5 = p5.next) {
          var str = p5.data;
          var nb = n6 > str.length ? str.length : n6;
          if (nb === str.length) ret += str;
          else ret += str.slice(0, n6);
          n6 -= nb;
          if (n6 === 0) {
            if (nb === str.length) {
              ++c5;
              if (p5.next) this.head = p5.next;
              else this.head = this.tail = null;
            } else {
              this.head = p5;
              p5.data = str.slice(nb);
            }
            break;
          }
          ++c5;
        }
        this.length -= c5;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n6) {
        var ret = Buffer3.allocUnsafe(n6);
        var p5 = this.head;
        var c5 = 1;
        p5.data.copy(ret);
        n6 -= p5.data.length;
        while (p5 = p5.next) {
          var buf = p5.data;
          var nb = n6 > buf.length ? buf.length : n6;
          buf.copy(ret, ret.length - n6, 0, nb);
          n6 -= nb;
          if (n6 === 0) {
            if (nb === buf.length) {
              ++c5;
              if (p5.next) this.head = p5.next;
              else this.head = this.tail = null;
            } else {
              this.head = p5;
              p5.data = buf.slice(nb);
            }
            break;
          }
          ++c5;
        }
        this.length -= c5;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: custom,
      value: function value(_4, options) {
        return inspect(this, _objectSpread({}, options, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        }));
      }
    }]);
    return BufferList;
  }();
  return exports$d;
}
var exports$c = {};
var _dewExec$c = false;
function dew$c() {
  if (_dewExec$c) return exports$c;
  _dewExec$c = true;
  var process$1 = process2;
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          process$1.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          process$1.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          process$1.nextTick(emitErrorAndCloseNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          process$1.nextTick(emitErrorAndCloseNT, _this, err2);
        } else {
          process$1.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        process$1.nextTick(emitCloseNT, _this);
        cb(err2);
      } else {
        process$1.nextTick(emitCloseNT, _this);
      }
    });
    return this;
  }
  function emitErrorAndCloseNT(self2, err) {
    emitErrorNT(self2, err);
    emitCloseNT(self2);
  }
  function emitCloseNT(self2) {
    if (self2._writableState && !self2._writableState.emitClose) return;
    if (self2._readableState && !self2._readableState.emitClose) return;
    self2.emit("close");
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  function errorOrDestroy(stream, err) {
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
    else stream.emit("error", err);
  }
  exports$c = {
    destroy,
    undestroy,
    errorOrDestroy
  };
  return exports$c;
}
var exports$b = {};
var _dewExec$b = false;
function dew$b() {
  if (_dewExec$b) return exports$b;
  _dewExec$b = true;
  const codes = {};
  function createErrorType(code, message, Base) {
    if (!Base) {
      Base = Error;
    }
    function getMessage(arg1, arg2, arg3) {
      if (typeof message === "string") {
        return message;
      } else {
        return message(arg1, arg2, arg3);
      }
    }
    class NodeError extends Base {
      constructor(arg1, arg2, arg3) {
        super(getMessage(arg1, arg2, arg3));
      }
    }
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes[code] = NodeError;
  }
  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      const len = expected.length;
      expected = expected.map((i5) => String(i5));
      if (len > 2) {
        return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
      } else if (len === 2) {
        return `one of ${thing} ${expected[0]} or ${expected[1]}`;
      } else {
        return `of ${thing} ${expected[0]}`;
      }
    } else {
      return `of ${thing} ${String(expected)}`;
    }
  }
  function startsWith(str, search, pos) {
    return str.substr(0, search.length) === search;
  }
  function endsWith(str, search, this_len) {
    if (this_len === void 0 || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  }
  function includes(str, search, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  }
  createErrorType("ERR_INVALID_OPT_VALUE", function(name2, value) {
    return 'The value "' + value + '" is invalid for option "' + name2 + '"';
  }, TypeError);
  createErrorType("ERR_INVALID_ARG_TYPE", function(name2, expected, actual) {
    let determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    let msg;
    if (endsWith(name2, " argument")) {
      msg = `The ${name2} ${determiner} ${oneOf(expected, "type")}`;
    } else {
      const type = includes(name2, ".") ? "property" : "argument";
      msg = `The "${name2}" ${type} ${determiner} ${oneOf(expected, "type")}`;
    }
    msg += `. Received type ${typeof actual}`;
    return msg;
  }, TypeError);
  createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name2) {
    return "The " + name2 + " method is not implemented";
  });
  createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  createErrorType("ERR_STREAM_DESTROYED", function(name2) {
    return "Cannot call " + name2 + " after a stream was destroyed";
  });
  createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
  }, TypeError);
  createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  exports$b.codes = codes;
  return exports$b;
}
var exports$a = {};
var _dewExec$a = false;
function dew$a() {
  if (_dewExec$a) return exports$a;
  _dewExec$a = true;
  var ERR_INVALID_OPT_VALUE = dew$b().codes.ERR_INVALID_OPT_VALUE;
  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }
  function getHighWaterMark(state, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name2 = isDuplex ? duplexKey : "highWaterMark";
        throw new ERR_INVALID_OPT_VALUE(name2, hwm);
      }
      return Math.floor(hwm);
    }
    return state.objectMode ? 16 : 16 * 1024;
  }
  exports$a = {
    getHighWaterMark
  };
  return exports$a;
}
var exports$9 = {};
var _dewExec$9 = false;
var _global$2 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
function dew$9() {
  if (_dewExec$9) return exports$9;
  _dewExec$9 = true;
  exports$9 = deprecate;
  function deprecate(fn, msg) {
    if (config3("noDeprecation")) {
      return fn;
    }
    var warned2 = false;
    function deprecated() {
      if (!warned2) {
        if (config3("throwDeprecation")) {
          throw new Error(msg);
        } else if (config3("traceDeprecation")) {
          console.trace(msg);
        } else {
          console.warn(msg);
        }
        warned2 = true;
      }
      return fn.apply(this || _global$2, arguments);
    }
    return deprecated;
  }
  function config3(name2) {
    try {
      if (!_global$2.localStorage) return false;
    } catch (_4) {
      return false;
    }
    var val = _global$2.localStorage[name2];
    if (null == val) return false;
    return String(val).toLowerCase() === "true";
  }
  return exports$9;
}
var exports$8 = {};
var _dewExec$8 = false;
var _global$1 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
function dew$8() {
  if (_dewExec$8) return exports$8;
  _dewExec$8 = true;
  var process$1 = process2;
  exports$8 = Writable;
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state);
    };
  }
  var Duplex;
  Writable.WritableState = WritableState;
  var internalUtil = {
    deprecate: dew$9()
  };
  var Stream = dew$e();
  var Buffer3 = buffer.Buffer;
  var OurUint8Array = _global$1.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer3.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = dew$c();
  var _require = dew$a(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = dew$b().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  dew$f()(Writable, Stream);
  function nop() {
  }
  function WritableState(options, stream, isDuplex) {
    Duplex = Duplex || dew$7();
    options = options || {};
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_4) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function value(object) {
        if (realHasInstance.call(this, object)) return true;
        if (this !== Writable) return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance2(object) {
      return object instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || dew$7();
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function") this._write = options.write;
      if (typeof options.writev === "function") this._writev = options.writev;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
      if (typeof options.final === "function") this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
  };
  function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    errorOrDestroy(stream, er);
    process$1.nextTick(cb, er);
  }
  function validChunk(stream, state, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== "string" && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }
    if (er) {
      errorOrDestroy(stream, er);
      process$1.nextTick(cb, er);
      return false;
    }
    return true;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer3.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state.ending) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer3.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret) state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state, writev2, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev2) stream._writev(chunk, state.onwrite);
    else stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
      process$1.nextTick(cb, er);
      process$1.nextTick(finishMaybe, stream, state);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
      finishMaybe(stream, state);
    }
  }
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state);
    if (er) onwriteError(stream, state, sync, er, cb);
    else {
      var finished = needFinish(state) || stream.destroyed;
      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }
      if (sync) {
        process$1.nextTick(afterWrite, stream, state, finished, cb);
      } else {
        afterWrite(stream, state, finished, cb);
      }
    }
  }
  function afterWrite(stream, state, finished, cb) {
    if (!finished) onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  }
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l5 = state.bufferedRequestCount;
      var buffer2 = new Array(l5);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer2[count] = entry;
        if (!entry.isBuf) allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer2.allBuffers = allBuffers;
      doWrite(stream, state, true, state.length, buffer2, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
      state.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--;
        if (state.writing) {
          break;
        }
      }
      if (entry === null) state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (!state.ending) endWritable(this, state, cb);
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function callFinal(stream, state) {
    stream._final(function(err) {
      state.pendingcb--;
      if (err) {
        errorOrDestroy(stream, err);
      }
      state.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state);
    });
  }
  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === "function" && !state.destroyed) {
        state.pendingcb++;
        state.finalCalled = true;
        process$1.nextTick(callFinal, stream, state);
      } else {
        state.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      prefinish(stream, state);
      if (state.pendingcb === 0) {
        state.finished = true;
        stream.emit("finish");
        if (state.autoDestroy) {
          var rState = stream._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream.destroy();
          }
        }
      }
    }
    return need;
  }
  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished) process$1.nextTick(cb);
      else stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  return exports$8;
}
var exports$7 = {};
var _dewExec$7 = false;
function dew$7() {
  if (_dewExec$7) return exports$7;
  _dewExec$7 = true;
  var process$1 = process2;
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) {
      keys2.push(key);
    }
    return keys2;
  };
  exports$7 = Duplex;
  var Readable2 = dew$3();
  var Writable = dew$8();
  dew$f()(Duplex, Readable2);
  {
    var keys = objectKeys(Writable.prototype);
    for (var v11 = 0; v11 < keys.length; v11++) {
      var method = keys[v11];
      if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable2.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
      if (options.readable === false) this.readable = false;
      if (options.writable === false) this.writable = false;
      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  function onend() {
    if (this._writableState.ended) return;
    process$1.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  return exports$7;
}
var exports$6 = {};
var _dewExec$6 = false;
function dew$6() {
  if (_dewExec$6) return exports$6;
  _dewExec$6 = true;
  var ERR_STREAM_PREMATURE_CLOSE = dew$b().codes.ERR_STREAM_PREMATURE_CLOSE;
  function once3(callback) {
    var called = false;
    return function() {
      if (called) return;
      called = true;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      callback.apply(this, args);
    };
  }
  function noop3() {
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function eos(stream, opts, callback) {
    if (typeof opts === "function") return eos(stream, null, opts);
    if (!opts) opts = {};
    callback = once3(callback || noop3);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish2() {
      if (!stream.writable) onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish2() {
      writable = false;
      writableEnded = true;
      if (!readable) callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend2() {
      readable = false;
      readableEnded = true;
      if (!writable) callback.call(stream);
    };
    var onerror = function onerror2(err) {
      callback.call(stream, err);
    };
    var onclose = function onclose2() {
      var err;
      if (readable && !readableEnded) {
        if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
      if (writable && !writableEnded) {
        if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
    };
    var onrequest = function onrequest2() {
      stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
      stream.on("complete", onfinish);
      stream.on("abort", onclose);
      if (stream.req) onrequest();
      else stream.on("request", onrequest);
    } else if (writable && !stream._writableState) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false) stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req) stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
  }
  exports$6 = eos;
  return exports$6;
}
var exports$5 = {};
var _dewExec$5 = false;
function dew$5() {
  if (_dewExec$5) return exports$5;
  _dewExec$5 = true;
  var process$1 = process2;
  var _Object$setPrototypeO;
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var finished = dew$6();
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult2(value, done) {
    return {
      value,
      done
    };
  }
  function readAndResolve(iter) {
    var resolve3 = iter[kLastResolve];
    if (resolve3 !== null) {
      var data = iter[kStream].read();
      if (data !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve3(createIterResult2(data, false));
      }
    }
  }
  function onReadable(iter) {
    process$1.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve3, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve3(createIterResult2(void 0, true));
          return;
        }
        iter[kHandlePromise](resolve3, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error = this[kError];
      if (error !== null) {
        return Promise.reject(error);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult2(void 0, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve3, reject) {
          process$1.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve3(createIterResult2(void 0, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise3;
      if (lastPromise) {
        promise3 = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data = this[kStream].read();
        if (data !== null) {
          return Promise.resolve(createIterResult2(data, false));
        }
        promise3 = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise3;
      return promise3;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve3, reject) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve3(createIterResult2(void 0, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value(resolve3, reject) {
        var data = iterator[kStream].read();
        if (data) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve3(createIterResult2(data, false));
        } else {
          iterator[kLastResolve] = resolve3;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream, function(err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator[kLastReject];
        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err);
        }
        iterator[kError] = err;
        return;
      }
      var resolve3 = iterator[kLastResolve];
      if (resolve3 !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve3(createIterResult2(void 0, true));
      }
      iterator[kEnded] = true;
    });
    stream.on("readable", onReadable.bind(null, iterator));
    return iterator;
  };
  exports$5 = createReadableStreamAsyncIterator;
  return exports$5;
}
var exports$4 = {};
var _dewExec$4 = false;
function dew$4() {
  if (_dewExec$4) return exports$4;
  _dewExec$4 = true;
  exports$4 = function() {
    throw new Error("Readable.from is not available in the browser");
  };
  return exports$4;
}
var exports$3 = {};
var _dewExec$3 = false;
var _global2 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
function dew$3() {
  if (_dewExec$3) return exports$3;
  _dewExec$3 = true;
  var process$1 = process2;
  exports$3 = Readable2;
  var Duplex;
  Readable2.ReadableState = ReadableState;
  y5.EventEmitter;
  var EElistenerCount = function EElistenerCount2(emitter, type) {
    return emitter.listeners(type).length;
  };
  var Stream = dew$e();
  var Buffer3 = buffer.Buffer;
  var OurUint8Array = _global2.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer3.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer3.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var debugUtil = X;
  var debug;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function debug2() {
    };
  }
  var BufferList = dew$d();
  var destroyImpl = dew$c();
  var _require = dew$a(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = dew$b().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from;
  dew$f()(Readable2, Stream);
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener3(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream, isDuplex) {
    Duplex = Duplex || dew$7();
    options = options || {};
    if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder) StringDecoder = e$14.StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable2(options) {
    Duplex = Duplex || dew$7();
    if (!(this instanceof Readable2)) return new Readable2(options);
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function") this._read = options.read;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable2.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable2.prototype.destroy = destroyImpl.destroy;
  Readable2.prototype._undestroy = destroyImpl.undestroy;
  Readable2.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable2.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer3.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable2.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug("readableAddChunk", chunk);
    var state = stream._readableState;
    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else {
      var er;
      if (!skipChunkCheck) er = chunkInvalid(state, chunk);
      if (er) {
        errorOrDestroy(stream, er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer3.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed) {
          return false;
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
            else maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
        maybeReadMore(stream, state);
      }
    }
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
  }
  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      state.awaitDrain = 0;
      stream.emit("data", chunk);
    } else {
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront) state.buffer.unshift(chunk);
      else state.buffer.push(chunk);
      if (state.needReadable) emitReadable(stream);
    }
    maybeReadMore(stream, state);
  }
  function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er;
  }
  Readable2.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable2.prototype.setEncoding = function(enc) {
    if (!StringDecoder) StringDecoder = e$14.StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p5 = this._readableState.buffer.head;
    var content = "";
    while (p5 !== null) {
      content += decoder.write(p5.data);
      p5 = p5.next;
    }
    this._readableState.buffer.clear();
    if (content !== "") this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n6) {
    if (n6 >= MAX_HWM) {
      n6 = MAX_HWM;
    } else {
      n6--;
      n6 |= n6 >>> 1;
      n6 |= n6 >>> 2;
      n6 |= n6 >>> 4;
      n6 |= n6 >>> 8;
      n6 |= n6 >>> 16;
      n6++;
    }
    return n6;
  }
  function howMuchToRead(n6, state) {
    if (n6 <= 0 || state.length === 0 && state.ended) return 0;
    if (state.objectMode) return 1;
    if (n6 !== n6) {
      if (state.flowing && state.length) return state.buffer.head.data.length;
      else return state.length;
    }
    if (n6 > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n6);
    if (n6 <= state.length) return n6;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  Readable2.prototype.read = function(n6) {
    debug("read", n6);
    n6 = parseInt(n6, 10);
    var state = this._readableState;
    var nOrig = n6;
    if (n6 !== 0) state.emittedReadable = false;
    if (n6 === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
      debug("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended) endReadable(this);
      else emitReadable(this);
      return null;
    }
    n6 = howMuchToRead(n6, state);
    if (n6 === 0 && state.ended) {
      if (state.length === 0) endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    debug("need readable", doRead);
    if (state.length === 0 || state.length - n6 < state.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state.ended || state.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state.reading = true;
      state.sync = true;
      if (state.length === 0) state.needReadable = true;
      this._read(state.highWaterMark);
      state.sync = false;
      if (!state.reading) n6 = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n6 > 0) ret = fromList(n6, state);
    else ret = null;
    if (ret === null) {
      state.needReadable = state.length <= state.highWaterMark;
      n6 = 0;
    } else {
      state.length -= n6;
      state.awaitDrain = 0;
    }
    if (state.length === 0) {
      if (!state.ended) state.needReadable = true;
      if (nOrig !== n6 && state.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state) {
    debug("onEofChunk");
    if (state.ended) return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    if (state.sync) {
      emitReadable(stream);
    } else {
      state.needReadable = false;
      if (!state.emittedReadable) {
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
  }
  function emitReadable(stream) {
    var state = stream._readableState;
    debug("emitReadable", state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug("emitReadable", state.flowing);
      state.emittedReadable = true;
      process$1.nextTick(emitReadable_, stream);
    }
  }
  function emitReadable_(stream) {
    var state = stream._readableState;
    debug("emitReadable_", state.destroyed, state.length, state.ended);
    if (!state.destroyed && (state.length || state.ended)) {
      stream.emit("readable");
      state.emittedReadable = false;
    }
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
  }
  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      process$1.nextTick(maybeReadMore_, stream, state);
    }
  }
  function maybeReadMore_(stream, state) {
    while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
      var len = state.length;
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length)
        break;
    }
    state.readingMore = false;
  }
  Readable2.prototype._read = function(n6) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
  };
  Readable2.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process$1.stdout && dest !== process$1.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted) process$1.nextTick(endFn);
    else src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      var ret = dest.write(chunk);
      debug("dest.write", ret);
      if (ret === false) {
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state.awaitDrain);
          state.awaitDrain++;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
    }
    prependListener3(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
      var state = src._readableState;
      debug("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain) state.awaitDrain--;
      if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  Readable2.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state.pipesCount === 0) return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes) return this;
      if (!dest) dest = state.pipes;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest) dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var i5 = 0; i5 < len; i5++) {
        dests[i5].emit("unpipe", this, {
          hasUnpiped: false
        });
      }
      return this;
    }
    var index = indexOf(state.pipes, dest);
    if (index === -1) return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1) state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable2.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    var state = this._readableState;
    if (ev === "data") {
      state.readableListening = this.listenerCount("readable") > 0;
      if (state.flowing !== false) this.resume();
    } else if (ev === "readable") {
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.flowing = false;
        state.emittedReadable = false;
        debug("on readable", state.length, state.reading);
        if (state.length) {
          emitReadable(this);
        } else if (!state.reading) {
          process$1.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable2.prototype.addListener = Readable2.prototype.on;
  Readable2.prototype.removeListener = function(ev, fn) {
    var res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process$1.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable2.prototype.removeAllListeners = function(ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === void 0) {
      process$1.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    var state = self2._readableState;
    state.readableListening = self2.listenerCount("readable") > 0;
    if (state.resumeScheduled && !state.paused) {
      state.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  }
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable2.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
      debug("resume");
      state.flowing = !state.readableListening;
      resume(this, state);
    }
    state.paused = false;
    return this;
  };
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      process$1.nextTick(resume_, stream, state);
    }
  }
  function resume_(stream, state) {
    debug("resume", state.reading);
    if (!state.reading) {
      stream.read(0);
    }
    state.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading) stream.read(0);
  }
  Readable2.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  function flow(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    while (state.flowing && stream.read() !== null) {
    }
  }
  Readable2.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug("wrapped end");
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug("wrapped data");
      if (state.decoder) chunk = state.decoder.write(chunk);
      if (state.objectMode && (chunk === null || chunk === void 0)) return;
      else if (!state.objectMode && (!chunk || !chunk.length)) return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i5 in stream) {
      if (this[i5] === void 0 && typeof stream[i5] === "function") {
        this[i5] = /* @__PURE__ */ function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
          };
        }(i5);
      }
    }
    for (var n6 = 0; n6 < kProxyEvents.length; n6++) {
      stream.on(kProxyEvents[n6], this.emit.bind(this, kProxyEvents[n6]));
    }
    this._read = function(n7) {
      debug("wrapped _read", n7);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable2.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === void 0) {
        createReadableStreamAsyncIterator = dew$5();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable2.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable2.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState.flowing;
    },
    set: function set(state) {
      if (this._readableState) {
        this._readableState.flowing = state;
      }
    }
  });
  Readable2._fromList = fromList;
  Object.defineProperty(Readable2.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get() {
      return this._readableState.length;
    }
  });
  function fromList(n6, state) {
    if (state.length === 0) return null;
    var ret;
    if (state.objectMode) ret = state.buffer.shift();
    else if (!n6 || n6 >= state.length) {
      if (state.decoder) ret = state.buffer.join("");
      else if (state.buffer.length === 1) ret = state.buffer.first();
      else ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = state.buffer.consume(n6, state.decoder);
    }
    return ret;
  }
  function endReadable(stream) {
    var state = stream._readableState;
    debug("endReadable", state.endEmitted);
    if (!state.endEmitted) {
      state.ended = true;
      process$1.nextTick(endReadableNT, state, stream);
    }
  }
  function endReadableNT(state, stream) {
    debug("endReadableNT", state.endEmitted, state.length);
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
      if (state.autoDestroy) {
        var wState = stream._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream.destroy();
        }
      }
    }
  }
  if (typeof Symbol === "function") {
    Readable2.from = function(iterable, opts) {
      if (from === void 0) {
        from = dew$4();
      }
      return from(Readable2, iterable, opts);
    };
  }
  function indexOf(xs, x5) {
    for (var i5 = 0, l5 = xs.length; i5 < l5; i5++) {
      if (xs[i5] === x5) return i5;
    }
    return -1;
  }
  return exports$3;
}
var exports$23 = {};
var _dewExec$22 = false;
function dew$22() {
  if (_dewExec$22) return exports$23;
  _dewExec$22 = true;
  exports$23 = Transform;
  var _require$codes = dew$b().codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
  var Duplex = dew$7();
  dew$f()(Transform, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) {
      return this.emit("error", new ERR_MULTIPLE_CALLBACK());
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform)) return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function") this._transform = options.transform;
      if (typeof options.flush === "function") this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n6) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
    });
  };
  function done(stream, er, data) {
    if (er) return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream.push(null);
  }
  return exports$23;
}
var exports$13 = {};
var _dewExec$13 = false;
function dew$13() {
  if (_dewExec$13) return exports$13;
  _dewExec$13 = true;
  exports$13 = PassThrough;
  var Transform = dew$22();
  dew$f()(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  return exports$13;
}
var exports5 = {};
var _dewExec4 = false;
function dew4() {
  if (_dewExec4) return exports5;
  _dewExec4 = true;
  var eos;
  function once3(callback) {
    var called = false;
    return function() {
      if (called) return;
      called = true;
      callback.apply(void 0, arguments);
    };
  }
  var _require$codes = dew$b().codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  function noop3(err) {
    if (err) throw err;
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function destroyer(stream, reading, writing, callback) {
    callback = once3(callback);
    var closed = false;
    stream.on("close", function() {
      closed = true;
    });
    if (eos === void 0) eos = dew$6();
    eos(stream, {
      readable: reading,
      writable: writing
    }, function(err) {
      if (err) return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed) return;
      if (destroyed) return;
      destroyed = true;
      if (isRequest(stream)) return stream.abort();
      if (typeof stream.destroy === "function") return stream.destroy();
      callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
  }
  function call(fn) {
    fn();
  }
  function pipe(from, to) {
    return from.pipe(to);
  }
  function popCallback(streams) {
    if (!streams.length) return noop3;
    if (typeof streams[streams.length - 1] !== "function") return noop3;
    return streams.pop();
  }
  function pipeline() {
    for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
      streams[_key] = arguments[_key];
    }
    var callback = popCallback(streams);
    if (Array.isArray(streams[0])) streams = streams[0];
    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    var error;
    var destroys = streams.map(function(stream, i5) {
      var reading = i5 < streams.length - 1;
      var writing = i5 > 0;
      return destroyer(stream, reading, writing, function(err) {
        if (!error) error = err;
        if (err) destroys.forEach(call);
        if (reading) return;
        destroys.forEach(call);
        callback(error);
      });
    });
    return streams.reduce(pipe);
  }
  exports5 = pipeline;
  return exports5;
}

// node_modules/@jspm/core/nodelibs/browser/chunk-B6-G-Ftj.js
var exports$14 = {};
var _dewExec5 = false;
var _global3 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
function dew5() {
  if (_dewExec5) return exports$14;
  _dewExec5 = true;
  exports$14 = Stream;
  var EE = y5.EventEmitter;
  var inherits = dew$f();
  inherits(Stream, EE);
  Stream.Readable = dew$3();
  Stream.Writable = dew$8();
  Stream.Duplex = dew$7();
  Stream.Transform = dew$22();
  Stream.PassThrough = dew$13();
  Stream.finished = dew$6();
  Stream.pipeline = dew4();
  Stream.Stream = Stream;
  function Stream() {
    EE.call(this || _global3);
  }
  Stream.prototype.pipe = function(dest, options) {
    var source = this || _global3;
    function ondata(chunk) {
      if (dest.writable) {
        if (false === dest.write(chunk) && source.pause) {
          source.pause();
        }
      }
    }
    source.on("data", ondata);
    function ondrain() {
      if (source.readable && source.resume) {
        source.resume();
      }
    }
    dest.on("drain", ondrain);
    if (!dest._isStdio && (!options || options.end !== false)) {
      source.on("end", onend);
      source.on("close", onclose);
    }
    var didOnEnd = false;
    function onend() {
      if (didOnEnd) return;
      didOnEnd = true;
      dest.end();
    }
    function onclose() {
      if (didOnEnd) return;
      didOnEnd = true;
      if (typeof dest.destroy === "function") dest.destroy();
    }
    function onerror(er) {
      cleanup();
      if (EE.listenerCount(this || _global3, "error") === 0) {
        throw er;
      }
    }
    source.on("error", onerror);
    dest.on("error", onerror);
    function cleanup() {
      source.removeListener("data", ondata);
      dest.removeListener("drain", ondrain);
      source.removeListener("end", onend);
      source.removeListener("close", onclose);
      source.removeListener("error", onerror);
      dest.removeListener("error", onerror);
      source.removeListener("end", cleanup);
      source.removeListener("close", cleanup);
      dest.removeListener("close", cleanup);
    }
    source.on("end", cleanup);
    source.on("close", cleanup);
    dest.on("close", cleanup);
    dest.emit("pipe", source);
    return dest;
  };
  return exports$14;
}
var exports6 = dew5();
var Readable = exports6.Readable;
Readable.wrap = function(src, options) {
  options = Object.assign({ objectMode: src.readableObjectMode != null || src.objectMode != null || true }, options);
  options.destroy = function(err, callback) {
    src.destroy(err);
    callback(err);
  };
  return new Readable(options).wrap(src);
};
exports6.Writable;
exports6.Duplex;
exports6.Transform;
exports6.PassThrough;
exports6.finished;
exports6.pipeline;
exports6.Stream;
({
  finished: promisify2(exports6.finished),
  pipeline: promisify2(exports6.pipeline)
});

// node_modules/@jspm/core/nodelibs/browser/punycode.js
var exports$15 = {};
var _dewExec6 = false;
function dew6() {
  if (_dewExec6) return exports$15;
  _dewExec6 = true;
  const maxInt = 2147483647;
  const base = 36;
  const tMin = 1;
  const tMax = 26;
  const skew = 38;
  const damp = 700;
  const initialBias = 72;
  const initialN = 128;
  const delimiter2 = "-";
  const regexPunycode = /^xn--/;
  const regexNonASCII = /[^\0-\x7F]/;
  const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
  const errors = {
    "overflow": "Overflow: input needs wider integers to process",
    "not-basic": "Illegal input >= 0x80 (not a basic code point)",
    "invalid-input": "Invalid input"
  };
  const baseMinusTMin = base - tMin;
  const floor = Math.floor;
  const stringFromCharCode = String.fromCharCode;
  function error(type) {
    throw new RangeError(errors[type]);
  }
  function map(array, callback) {
    const result = [];
    let length = array.length;
    while (length--) {
      result[length] = callback(array[length]);
    }
    return result;
  }
  function mapDomain(domain3, callback) {
    const parts = domain3.split("@");
    let result = "";
    if (parts.length > 1) {
      result = parts[0] + "@";
      domain3 = parts[1];
    }
    domain3 = domain3.replace(regexSeparators, ".");
    const labels = domain3.split(".");
    const encoded = map(labels, callback).join(".");
    return result + encoded;
  }
  function ucs2decode(string) {
    const output = [];
    let counter = 0;
    const length = string.length;
    while (counter < length) {
      const value = string.charCodeAt(counter++);
      if (value >= 55296 && value <= 56319 && counter < length) {
        const extra = string.charCodeAt(counter++);
        if ((extra & 64512) == 56320) {
          output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
        } else {
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }
    return output;
  }
  const ucs2encode = (codePoints) => String.fromCodePoint(...codePoints);
  const basicToDigit = function(codePoint) {
    if (codePoint >= 48 && codePoint < 58) {
      return 26 + (codePoint - 48);
    }
    if (codePoint >= 65 && codePoint < 91) {
      return codePoint - 65;
    }
    if (codePoint >= 97 && codePoint < 123) {
      return codePoint - 97;
    }
    return base;
  };
  const digitToBasic = function(digit, flag) {
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
  };
  const adapt = function(delta, numPoints, firstTime) {
    let k5 = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);
    for (; delta > baseMinusTMin * tMax >> 1; k5 += base) {
      delta = floor(delta / baseMinusTMin);
    }
    return floor(k5 + (baseMinusTMin + 1) * delta / (delta + skew));
  };
  const decode2 = function(input) {
    const output = [];
    const inputLength = input.length;
    let i5 = 0;
    let n6 = initialN;
    let bias = initialBias;
    let basic = input.lastIndexOf(delimiter2);
    if (basic < 0) {
      basic = 0;
    }
    for (let j4 = 0; j4 < basic; ++j4) {
      if (input.charCodeAt(j4) >= 128) {
        error("not-basic");
      }
      output.push(input.charCodeAt(j4));
    }
    for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
      const oldi = i5;
      for (let w5 = 1, k5 = base; ; k5 += base) {
        if (index >= inputLength) {
          error("invalid-input");
        }
        const digit = basicToDigit(input.charCodeAt(index++));
        if (digit >= base) {
          error("invalid-input");
        }
        if (digit > floor((maxInt - i5) / w5)) {
          error("overflow");
        }
        i5 += digit * w5;
        const t6 = k5 <= bias ? tMin : k5 >= bias + tMax ? tMax : k5 - bias;
        if (digit < t6) {
          break;
        }
        const baseMinusT = base - t6;
        if (w5 > floor(maxInt / baseMinusT)) {
          error("overflow");
        }
        w5 *= baseMinusT;
      }
      const out = output.length + 1;
      bias = adapt(i5 - oldi, out, oldi == 0);
      if (floor(i5 / out) > maxInt - n6) {
        error("overflow");
      }
      n6 += floor(i5 / out);
      i5 %= out;
      output.splice(i5++, 0, n6);
    }
    return String.fromCodePoint(...output);
  };
  const encode2 = function(input) {
    const output = [];
    input = ucs2decode(input);
    const inputLength = input.length;
    let n6 = initialN;
    let delta = 0;
    let bias = initialBias;
    for (const currentValue of input) {
      if (currentValue < 128) {
        output.push(stringFromCharCode(currentValue));
      }
    }
    const basicLength = output.length;
    let handledCPCount = basicLength;
    if (basicLength) {
      output.push(delimiter2);
    }
    while (handledCPCount < inputLength) {
      let m7 = maxInt;
      for (const currentValue of input) {
        if (currentValue >= n6 && currentValue < m7) {
          m7 = currentValue;
        }
      }
      const handledCPCountPlusOne = handledCPCount + 1;
      if (m7 - n6 > floor((maxInt - delta) / handledCPCountPlusOne)) {
        error("overflow");
      }
      delta += (m7 - n6) * handledCPCountPlusOne;
      n6 = m7;
      for (const currentValue of input) {
        if (currentValue < n6 && ++delta > maxInt) {
          error("overflow");
        }
        if (currentValue === n6) {
          let q6 = delta;
          for (let k5 = base; ; k5 += base) {
            const t6 = k5 <= bias ? tMin : k5 >= bias + tMax ? tMax : k5 - bias;
            if (q6 < t6) {
              break;
            }
            const qMinusT = q6 - t6;
            const baseMinusT = base - t6;
            output.push(stringFromCharCode(digitToBasic(t6 + qMinusT % baseMinusT, 0)));
            q6 = floor(qMinusT / baseMinusT);
          }
          output.push(stringFromCharCode(digitToBasic(q6, 0)));
          bias = adapt(delta, handledCPCountPlusOne, handledCPCount === basicLength);
          delta = 0;
          ++handledCPCount;
        }
      }
      ++delta;
      ++n6;
    }
    return output.join("");
  };
  const toUnicode2 = function(input) {
    return mapDomain(input, function(string) {
      return regexPunycode.test(string) ? decode2(string.slice(4).toLowerCase()) : string;
    });
  };
  const toASCII2 = function(input) {
    return mapDomain(input, function(string) {
      return regexNonASCII.test(string) ? "xn--" + encode2(string) : string;
    });
  };
  const punycode = {
    /**
     * A string representing the current Punycode.js version number.
     * @memberOf punycode
     * @type String
     */
    "version": "2.3.1",
    /**
     * An object of methods to convert from JavaScript's internal character
     * representation (UCS-2) to Unicode code points, and back.
     * @see <https://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode
     * @type Object
     */
    "ucs2": {
      "decode": ucs2decode,
      "encode": ucs2encode
    },
    "decode": decode2,
    "encode": encode2,
    "toASCII": toASCII2,
    "toUnicode": toUnicode2
  };
  exports$15 = punycode;
  return exports$15;
}
var exports7 = dew6();
var decode = exports7.decode;
var encode = exports7.encode;
var toASCII = exports7.toASCII;
var toUnicode = exports7.toUnicode;
var ucs2 = exports7.ucs2;
var version3 = exports7.version;

// node_modules/@jspm/core/nodelibs/browser/chunk-DtcTpLWz.js
var exports$k = {};
var _dewExec$k = false;
function dew$k() {
  if (_dewExec$k) return exports$k;
  _dewExec$k = true;
  exports$k = function hasSymbols() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (sym in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
  return exports$k;
}
var exports$j = {};
var _dewExec$j = false;
function dew$j() {
  if (_dewExec$j) return exports$j;
  _dewExec$j = true;
  exports$j = Error;
  return exports$j;
}
var exports$i = {};
var _dewExec$i = false;
function dew$i() {
  if (_dewExec$i) return exports$i;
  _dewExec$i = true;
  exports$i = EvalError;
  return exports$i;
}
var exports$h = {};
var _dewExec$h = false;
function dew$h() {
  if (_dewExec$h) return exports$h;
  _dewExec$h = true;
  exports$h = RangeError;
  return exports$h;
}
var exports$g2 = {};
var _dewExec$g2 = false;
function dew$g2() {
  if (_dewExec$g2) return exports$g2;
  _dewExec$g2 = true;
  exports$g2 = ReferenceError;
  return exports$g2;
}
var exports$f2 = {};
var _dewExec$f2 = false;
function dew$f2() {
  if (_dewExec$f2) return exports$f2;
  _dewExec$f2 = true;
  exports$f2 = SyntaxError;
  return exports$f2;
}
var exports$e2 = {};
var _dewExec$e2 = false;
function dew$e2() {
  if (_dewExec$e2) return exports$e2;
  _dewExec$e2 = true;
  exports$e2 = TypeError;
  return exports$e2;
}
var exports$d2 = {};
var _dewExec$d2 = false;
function dew$d2() {
  if (_dewExec$d2) return exports$d2;
  _dewExec$d2 = true;
  exports$d2 = URIError;
  return exports$d2;
}
var exports$c2 = {};
var _dewExec$c2 = false;
function dew$c2() {
  if (_dewExec$c2) return exports$c2;
  _dewExec$c2 = true;
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = dew$k();
  exports$c2 = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
  return exports$c2;
}
var exports$b2 = {};
var _dewExec$b2 = false;
function dew$b2() {
  if (_dewExec$b2) return exports$b2;
  _dewExec$b2 = true;
  var test = {
    __proto__: null,
    foo: {}
  };
  var $Object = Object;
  exports$b2 = function hasProto() {
    return {
      __proto__: test
    }.foo === test.foo && !(test instanceof $Object);
  };
  return exports$b2;
}
var exports$a2 = {};
var _dewExec$a2 = false;
function dew$a2() {
  if (_dewExec$a2) return exports$a2;
  _dewExec$a2 = true;
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty2(a5, b6) {
    var arr = [];
    for (var i5 = 0; i5 < a5.length; i5 += 1) {
      arr[i5] = a5[i5];
    }
    for (var j4 = 0; j4 < b6.length; j4 += 1) {
      arr[j4 + a5.length] = b6[j4];
    }
    return arr;
  };
  var slicy = function slicy2(arrLike, offset) {
    var arr = [];
    for (var i5 = offset, j4 = 0; i5 < arrLike.length; i5 += 1, j4 += 1) {
      arr[j4] = arrLike[i5];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str = "";
    for (var i5 = 0; i5 < arr.length; i5 += 1) {
      str += arr[i5];
      if (i5 + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  exports$a2 = function bind(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(this, concatty(args, arguments));
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(that, concatty(args, arguments));
    };
    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i5 = 0; i5 < boundLength; i5++) {
      boundArgs[i5] = "$" + i5;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound;
  };
  return exports$a2;
}
var exports$92 = {};
var _dewExec$92 = false;
function dew$92() {
  if (_dewExec$92) return exports$92;
  _dewExec$92 = true;
  var implementation = dew$a2();
  exports$92 = Function.prototype.bind || implementation;
  return exports$92;
}
var exports$82 = {};
var _dewExec$82 = false;
function dew$82() {
  if (_dewExec$82) return exports$82;
  _dewExec$82 = true;
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind = dew$92();
  exports$82 = bind.call(call, $hasOwn);
  return exports$82;
}
var exports$72 = {};
var _dewExec$72 = false;
function dew$72() {
  if (_dewExec$72) return exports$72;
  _dewExec$72 = true;
  var undefined$1;
  var $Error = dew$j();
  var $EvalError = dew$i();
  var $RangeError = dew$h();
  var $ReferenceError = dew$g2();
  var $SyntaxError = dew$f2();
  var $TypeError = dew$e2();
  var $URIError = dew$d2();
  var $Function = Function;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e7) {
    }
  };
  var $gOPD = Object.getOwnPropertyDescriptor;
  if ($gOPD) {
    try {
      $gOPD({}, "");
    } catch (e7) {
      $gOPD = null;
    }
  }
  var throwTypeError = function() {
    throw new $TypeError();
  };
  var ThrowTypeError = $gOPD ? function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  }() : throwTypeError;
  var hasSymbols = dew$c2()();
  var hasProto = dew$b2()();
  var getProto = Object.getPrototypeOf || (hasProto ? function(x5) {
    return x5.__proto__;
  } : null);
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined$1 : getProto(Uint8Array);
  var INTRINSICS = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
    "%AsyncFromSyncIteratorPrototype%": undefined$1,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": $Error,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": $EvalError,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
    "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
    "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
    "%RangeError%": $RangeError,
    "%ReferenceError%": $ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined$1,
    "%Symbol%": hasSymbols ? Symbol : undefined$1,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
    "%URIError%": $URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
  };
  if (getProto) {
    try {
      null.error;
    } catch (e7) {
      var errorProto = getProto(getProto(e7));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
  }
  var doEval = function doEval2(name2) {
    var value;
    if (name2 === "%AsyncFunction%") {
      value = getEvalledConstructor("async function () {}");
    } else if (name2 === "%GeneratorFunction%") {
      value = getEvalledConstructor("function* () {}");
    } else if (name2 === "%AsyncGeneratorFunction%") {
      value = getEvalledConstructor("async function* () {}");
    } else if (name2 === "%AsyncGenerator%") {
      var fn = doEval2("%AsyncGeneratorFunction%");
      if (fn) {
        value = fn.prototype;
      }
    } else if (name2 === "%AsyncIteratorPrototype%") {
      var gen = doEval2("%AsyncGenerator%");
      if (gen && getProto) {
        value = getProto(gen.prototype);
      }
    }
    INTRINSICS[name2] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind = dew$92();
  var hasOwn = dew$82();
  var $concat = bind.call(Function.call, Array.prototype.concat);
  var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
  var $replace = bind.call(Function.call, String.prototype.replace);
  var $strSlice = bind.call(Function.call, String.prototype.slice);
  var $exec = bind.call(Function.call, RegExp.prototype.exec);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath2(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === "%" && last !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last === "%" && first !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace(string, rePropName, function(match, number, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
    var intrinsicName = name2;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name2 + " does not exist!");
  };
  exports$72 = function GetIntrinsic(name2, allowMissing) {
    if (typeof name2 !== "string" || name2.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name2) === null) {
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts = stringToPath(name2);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i5 = 1, isOwn = true; i5 < parts.length; i5 += 1) {
      var part = parts[i5];
      var first = $strSlice(part, 0, 1);
      var last = $strSlice(part, -1);
      if ((first === '"' || first === "'" || first === "`" || last === '"' || last === "'" || last === "`") && first !== last) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError("base intrinsic for " + name2 + " exists, but the property is not available.");
          }
          return void 0;
        }
        if ($gOPD && i5 + 1 >= parts.length) {
          var desc = $gOPD(value, part);
          isOwn = !!desc;
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
  return exports$72;
}
var exports$62 = {};
var _dewExec$62 = false;
function dew$62() {
  if (_dewExec$62) return exports$62;
  _dewExec$62 = true;
  var GetIntrinsic = dew$72();
  var $defineProperty = GetIntrinsic("%Object.defineProperty%", true) || false;
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", {
        value: 1
      });
    } catch (e7) {
      $defineProperty = false;
    }
  }
  exports$62 = $defineProperty;
  return exports$62;
}
var exports$52 = {};
var _dewExec$52 = false;
function dew$52() {
  if (_dewExec$52) return exports$52;
  _dewExec$52 = true;
  var GetIntrinsic = dew$72();
  var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e7) {
      $gOPD = null;
    }
  }
  exports$52 = $gOPD;
  return exports$52;
}
var exports$42 = {};
var _dewExec$42 = false;
function dew$42() {
  if (_dewExec$42) return exports$42;
  _dewExec$42 = true;
  var $defineProperty = dew$62();
  var $SyntaxError = dew$f2();
  var $TypeError = dew$e2();
  var gopd = dew$52();
  exports$42 = function defineDataProperty(obj, property, value) {
    if (!obj || typeof obj !== "object" && typeof obj !== "function") {
      throw new $TypeError("`obj` must be an object or a function`");
    }
    if (typeof property !== "string" && typeof property !== "symbol") {
      throw new $TypeError("`property` must be a string or a symbol`");
    }
    if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
      throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
      throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
      throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
      throw new $TypeError("`loose`, if provided, must be a boolean");
    }
    var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
    var nonWritable = arguments.length > 4 ? arguments[4] : null;
    var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
    var loose = arguments.length > 6 ? arguments[6] : false;
    var desc = !!gopd && gopd(obj, property);
    if ($defineProperty) {
      $defineProperty(obj, property, {
        configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
        enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
        value,
        writable: nonWritable === null && desc ? desc.writable : !nonWritable
      });
    } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
      obj[property] = value;
    } else {
      throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
    }
  };
  return exports$42;
}
var exports$32 = {};
var _dewExec$32 = false;
function dew$32() {
  if (_dewExec$32) return exports$32;
  _dewExec$32 = true;
  var $defineProperty = dew$62();
  var hasPropertyDescriptors = function hasPropertyDescriptors2() {
    return !!$defineProperty;
  };
  hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
    if (!$defineProperty) {
      return null;
    }
    try {
      return $defineProperty([], "length", {
        value: 1
      }).length !== 1;
    } catch (e7) {
      return true;
    }
  };
  exports$32 = hasPropertyDescriptors;
  return exports$32;
}
var exports$24 = {};
var _dewExec$23 = false;
function dew$23() {
  if (_dewExec$23) return exports$24;
  _dewExec$23 = true;
  var GetIntrinsic = dew$72();
  var define = dew$42();
  var hasDescriptors = dew$32()();
  var gOPD = dew$52();
  var $TypeError = dew$e2();
  var $floor = GetIntrinsic("%Math.floor%");
  exports$24 = function setFunctionLength(fn, length) {
    if (typeof fn !== "function") {
      throw new $TypeError("`fn` is not a function");
    }
    if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
      throw new $TypeError("`length` must be a positive 32-bit integer");
    }
    var loose = arguments.length > 2 && !!arguments[2];
    var functionLengthIsConfigurable = true;
    var functionLengthIsWritable = true;
    if ("length" in fn && gOPD) {
      var desc = gOPD(fn, "length");
      if (desc && !desc.configurable) {
        functionLengthIsConfigurable = false;
      }
      if (desc && !desc.writable) {
        functionLengthIsWritable = false;
      }
    }
    if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
      if (hasDescriptors) {
        define(
          /** @type {Parameters<define>[0]} */
          fn,
          "length",
          length,
          true,
          true
        );
      } else {
        define(
          /** @type {Parameters<define>[0]} */
          fn,
          "length",
          length
        );
      }
    }
    return fn;
  };
  return exports$24;
}
var exports$16 = {};
var _dewExec$14 = false;
function dew$14() {
  if (_dewExec$14) return exports$16;
  _dewExec$14 = true;
  var bind = dew$92();
  var GetIntrinsic = dew$72();
  var setFunctionLength = dew$23();
  var $TypeError = dew$e2();
  var $apply = GetIntrinsic("%Function.prototype.apply%");
  var $call = GetIntrinsic("%Function.prototype.call%");
  var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
  var $defineProperty = dew$62();
  var $max = GetIntrinsic("%Math.max%");
  exports$16 = function callBind(originalFunction) {
    if (typeof originalFunction !== "function") {
      throw new $TypeError("a function is required");
    }
    var func = $reflectApply(bind, $call, arguments);
    return setFunctionLength(func, 1 + $max(0, originalFunction.length - (arguments.length - 1)), true);
  };
  var applyBind = function applyBind2() {
    return $reflectApply(bind, $apply, arguments);
  };
  if ($defineProperty) {
    $defineProperty(exports$16, "apply", {
      value: applyBind
    });
  } else {
    exports$16.apply = applyBind;
  }
  return exports$16;
}
var exports8 = {};
var _dewExec7 = false;
function dew7() {
  if (_dewExec7) return exports8;
  _dewExec7 = true;
  var GetIntrinsic = dew$72();
  var callBind = dew$14();
  var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
  exports8 = function callBoundIntrinsic(name2, allowMissing) {
    var intrinsic = GetIntrinsic(name2, !!allowMissing);
    if (typeof intrinsic === "function" && $indexOf(name2, ".prototype.") > -1) {
      return callBind(intrinsic);
    }
    return intrinsic;
  };
  return exports8;
}

// node_modules/@jspm/core/nodelibs/browser/chunk-BlJi4mNy.js
var exports$17 = {};
var _dewExec8 = false;
function dew8() {
  if (_dewExec8) return exports$17;
  _dewExec8 = true;
  var process$1 = process3;
  function assertPath(path2) {
    if (typeof path2 !== "string") {
      throw new TypeError("Path must be a string. Received " + JSON.stringify(path2));
    }
  }
  function normalizeStringPosix(path2, allowAboveRoot) {
    var res = "";
    var lastSegmentLength = 0;
    var lastSlash = -1;
    var dots = 0;
    var code;
    for (var i5 = 0; i5 <= path2.length; ++i5) {
      if (i5 < path2.length) code = path2.charCodeAt(i5);
      else if (code === 47) break;
      else code = 47;
      if (code === 47) {
        if (lastSlash === i5 - 1 || dots === 1) ;
        else if (lastSlash !== i5 - 1 && dots === 2) {
          if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {
            if (res.length > 2) {
              var lastSlashIndex = res.lastIndexOf("/");
              if (lastSlashIndex !== res.length - 1) {
                if (lastSlashIndex === -1) {
                  res = "";
                  lastSegmentLength = 0;
                } else {
                  res = res.slice(0, lastSlashIndex);
                  lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
                }
                lastSlash = i5;
                dots = 0;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSegmentLength = 0;
              lastSlash = i5;
              dots = 0;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0) res += "/..";
            else res = "..";
            lastSegmentLength = 2;
          }
        } else {
          if (res.length > 0) res += "/" + path2.slice(lastSlash + 1, i5);
          else res = path2.slice(lastSlash + 1, i5);
          lastSegmentLength = i5 - lastSlash - 1;
        }
        lastSlash = i5;
        dots = 0;
      } else if (code === 46 && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }
  function _format(sep2, pathObject) {
    var dir = pathObject.dir || pathObject.root;
    var base = pathObject.base || (pathObject.name || "") + (pathObject.ext || "");
    if (!dir) {
      return base;
    }
    if (dir === pathObject.root) {
      return dir + base;
    }
    return dir + sep2 + base;
  }
  var posix2 = {
    // path.resolve([from ...], to)
    resolve: function resolve3() {
      var resolvedPath = "";
      var resolvedAbsolute = false;
      var cwd3;
      for (var i5 = arguments.length - 1; i5 >= -1 && !resolvedAbsolute; i5--) {
        var path2;
        if (i5 >= 0) path2 = arguments[i5];
        else {
          if (cwd3 === void 0) cwd3 = process$1.cwd();
          path2 = cwd3;
        }
        assertPath(path2);
        if (path2.length === 0) {
          continue;
        }
        resolvedPath = path2 + "/" + resolvedPath;
        resolvedAbsolute = path2.charCodeAt(0) === 47;
      }
      resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
      if (resolvedAbsolute) {
        if (resolvedPath.length > 0) return "/" + resolvedPath;
        else return "/";
      } else if (resolvedPath.length > 0) {
        return resolvedPath;
      } else {
        return ".";
      }
    },
    normalize: function normalize2(path2) {
      assertPath(path2);
      if (path2.length === 0) return ".";
      var isAbsolute2 = path2.charCodeAt(0) === 47;
      var trailingSeparator = path2.charCodeAt(path2.length - 1) === 47;
      path2 = normalizeStringPosix(path2, !isAbsolute2);
      if (path2.length === 0 && !isAbsolute2) path2 = ".";
      if (path2.length > 0 && trailingSeparator) path2 += "/";
      if (isAbsolute2) return "/" + path2;
      return path2;
    },
    isAbsolute: function isAbsolute2(path2) {
      assertPath(path2);
      return path2.length > 0 && path2.charCodeAt(0) === 47;
    },
    join: function join2() {
      if (arguments.length === 0) return ".";
      var joined;
      for (var i5 = 0; i5 < arguments.length; ++i5) {
        var arg = arguments[i5];
        assertPath(arg);
        if (arg.length > 0) {
          if (joined === void 0) joined = arg;
          else joined += "/" + arg;
        }
      }
      if (joined === void 0) return ".";
      return posix2.normalize(joined);
    },
    relative: function relative2(from, to) {
      assertPath(from);
      assertPath(to);
      if (from === to) return "";
      from = posix2.resolve(from);
      to = posix2.resolve(to);
      if (from === to) return "";
      var fromStart = 1;
      for (; fromStart < from.length; ++fromStart) {
        if (from.charCodeAt(fromStart) !== 47) break;
      }
      var fromEnd = from.length;
      var fromLen = fromEnd - fromStart;
      var toStart = 1;
      for (; toStart < to.length; ++toStart) {
        if (to.charCodeAt(toStart) !== 47) break;
      }
      var toEnd = to.length;
      var toLen = toEnd - toStart;
      var length = fromLen < toLen ? fromLen : toLen;
      var lastCommonSep = -1;
      var i5 = 0;
      for (; i5 <= length; ++i5) {
        if (i5 === length) {
          if (toLen > length) {
            if (to.charCodeAt(toStart + i5) === 47) {
              return to.slice(toStart + i5 + 1);
            } else if (i5 === 0) {
              return to.slice(toStart + i5);
            }
          } else if (fromLen > length) {
            if (from.charCodeAt(fromStart + i5) === 47) {
              lastCommonSep = i5;
            } else if (i5 === 0) {
              lastCommonSep = 0;
            }
          }
          break;
        }
        var fromCode = from.charCodeAt(fromStart + i5);
        var toCode = to.charCodeAt(toStart + i5);
        if (fromCode !== toCode) break;
        else if (fromCode === 47) lastCommonSep = i5;
      }
      var out = "";
      for (i5 = fromStart + lastCommonSep + 1; i5 <= fromEnd; ++i5) {
        if (i5 === fromEnd || from.charCodeAt(i5) === 47) {
          if (out.length === 0) out += "..";
          else out += "/..";
        }
      }
      if (out.length > 0) return out + to.slice(toStart + lastCommonSep);
      else {
        toStart += lastCommonSep;
        if (to.charCodeAt(toStart) === 47) ++toStart;
        return to.slice(toStart);
      }
    },
    _makeLong: function _makeLong2(path2) {
      return path2;
    },
    dirname: function dirname2(path2) {
      assertPath(path2);
      if (path2.length === 0) return ".";
      var code = path2.charCodeAt(0);
      var hasRoot = code === 47;
      var end = -1;
      var matchedSlash = true;
      for (var i5 = path2.length - 1; i5 >= 1; --i5) {
        code = path2.charCodeAt(i5);
        if (code === 47) {
          if (!matchedSlash) {
            end = i5;
            break;
          }
        } else {
          matchedSlash = false;
        }
      }
      if (end === -1) return hasRoot ? "/" : ".";
      if (hasRoot && end === 1) return "//";
      return path2.slice(0, end);
    },
    basename: function basename2(path2, ext) {
      if (ext !== void 0 && typeof ext !== "string") throw new TypeError('"ext" argument must be a string');
      assertPath(path2);
      var start = 0;
      var end = -1;
      var matchedSlash = true;
      var i5;
      if (ext !== void 0 && ext.length > 0 && ext.length <= path2.length) {
        if (ext.length === path2.length && ext === path2) return "";
        var extIdx = ext.length - 1;
        var firstNonSlashEnd = -1;
        for (i5 = path2.length - 1; i5 >= 0; --i5) {
          var code = path2.charCodeAt(i5);
          if (code === 47) {
            if (!matchedSlash) {
              start = i5 + 1;
              break;
            }
          } else {
            if (firstNonSlashEnd === -1) {
              matchedSlash = false;
              firstNonSlashEnd = i5 + 1;
            }
            if (extIdx >= 0) {
              if (code === ext.charCodeAt(extIdx)) {
                if (--extIdx === -1) {
                  end = i5;
                }
              } else {
                extIdx = -1;
                end = firstNonSlashEnd;
              }
            }
          }
        }
        if (start === end) end = firstNonSlashEnd;
        else if (end === -1) end = path2.length;
        return path2.slice(start, end);
      } else {
        for (i5 = path2.length - 1; i5 >= 0; --i5) {
          if (path2.charCodeAt(i5) === 47) {
            if (!matchedSlash) {
              start = i5 + 1;
              break;
            }
          } else if (end === -1) {
            matchedSlash = false;
            end = i5 + 1;
          }
        }
        if (end === -1) return "";
        return path2.slice(start, end);
      }
    },
    extname: function extname2(path2) {
      assertPath(path2);
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var preDotState = 0;
      for (var i5 = path2.length - 1; i5 >= 0; --i5) {
        var code = path2.charCodeAt(i5);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i5 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i5 + 1;
        }
        if (code === 46) {
          if (startDot === -1) startDot = i5;
          else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return "";
      }
      return path2.slice(startDot, end);
    },
    format: function format3(pathObject) {
      if (pathObject === null || typeof pathObject !== "object") {
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
      }
      return _format("/", pathObject);
    },
    parse: function parse3(path2) {
      assertPath(path2);
      var ret = {
        root: "",
        dir: "",
        base: "",
        ext: "",
        name: ""
      };
      if (path2.length === 0) return ret;
      var code = path2.charCodeAt(0);
      var isAbsolute2 = code === 47;
      var start;
      if (isAbsolute2) {
        ret.root = "/";
        start = 1;
      } else {
        start = 0;
      }
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      var i5 = path2.length - 1;
      var preDotState = 0;
      for (; i5 >= start; --i5) {
        code = path2.charCodeAt(i5);
        if (code === 47) {
          if (!matchedSlash) {
            startPart = i5 + 1;
            break;
          }
          continue;
        }
        if (end === -1) {
          matchedSlash = false;
          end = i5 + 1;
        }
        if (code === 46) {
          if (startDot === -1) startDot = i5;
          else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
          preDotState = -1;
        }
      }
      if (startDot === -1 || end === -1 || // We saw a non-dot character immediately before the dot
      preDotState === 0 || // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        if (end !== -1) {
          if (startPart === 0 && isAbsolute2) ret.base = ret.name = path2.slice(1, end);
          else ret.base = ret.name = path2.slice(startPart, end);
        }
      } else {
        if (startPart === 0 && isAbsolute2) {
          ret.name = path2.slice(1, startDot);
          ret.base = path2.slice(1, end);
        } else {
          ret.name = path2.slice(startPart, startDot);
          ret.base = path2.slice(startPart, end);
        }
        ret.ext = path2.slice(startDot, end);
      }
      if (startPart > 0) ret.dir = path2.slice(0, startPart - 1);
      else if (isAbsolute2) ret.dir = "/";
      return ret;
    },
    sep: "/",
    delimiter: ":",
    win32: null,
    posix: null
  };
  posix2.posix = posix2;
  exports$17 = posix2;
  return exports$17;
}
var exports9 = dew8();

// node_modules/@jspm/core/nodelibs/browser/url.js
var empty = Object.freeze(/* @__PURE__ */ Object.create(null));
var exports$83 = {};
var _dewExec$73 = false;
var _global4 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
function dew$73() {
  if (_dewExec$73) return exports$83;
  _dewExec$73 = true;
  var hasMap = typeof Map === "function" && Map.prototype;
  var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
  var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
  var mapForEach = hasMap && Map.prototype.forEach;
  var hasSet = typeof Set === "function" && Set.prototype;
  var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
  var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
  var setForEach = hasSet && Set.prototype.forEach;
  var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
  var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
  var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
  var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
  var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
  var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
  var booleanValueOf = Boolean.prototype.valueOf;
  var objectToString = Object.prototype.toString;
  var functionToString = Function.prototype.toString;
  var $match = String.prototype.match;
  var $slice = String.prototype.slice;
  var $replace = String.prototype.replace;
  var $toUpperCase = String.prototype.toUpperCase;
  var $toLowerCase = String.prototype.toLowerCase;
  var $test = RegExp.prototype.test;
  var $concat = Array.prototype.concat;
  var $join = Array.prototype.join;
  var $arrSlice = Array.prototype.slice;
  var $floor = Math.floor;
  var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
  var gOPS = Object.getOwnPropertySymbols;
  var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
  var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
  var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
  var isEnumerable = Object.prototype.propertyIsEnumerable;
  var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O6) {
    return O6.__proto__;
  } : null);
  function addNumericSeparator(num2, str) {
    if (num2 === Infinity || num2 === -Infinity || num2 !== num2 || num2 && num2 > -1e3 && num2 < 1e3 || $test.call(/e/, str)) {
      return str;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num2 === "number") {
      var int = num2 < 0 ? -$floor(-num2) : $floor(num2);
      if (int !== num2) {
        var intStr = String(int);
        var dec = $slice.call(str, intStr.length + 1);
        return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
      }
    }
    return $replace.call(str, sepRegex, "$&_");
  }
  var utilInspect = empty;
  var inspectCustom = utilInspect.custom;
  var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
  exports$83 = function inspect_(obj, options, depth, seen) {
    var opts = options || {};
    if (has(opts, "quoteStyle") && opts.quoteStyle !== "single" && opts.quoteStyle !== "double") {
      throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
      throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
    if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
      throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    }
    if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
      throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
      throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;
    if (typeof obj === "undefined") {
      return "undefined";
    }
    if (obj === null) {
      return "null";
    }
    if (typeof obj === "boolean") {
      return obj ? "true" : "false";
    }
    if (typeof obj === "string") {
      return inspectString(obj, opts);
    }
    if (typeof obj === "number") {
      if (obj === 0) {
        return Infinity / obj > 0 ? "0" : "-0";
      }
      var str = String(obj);
      return numericSeparator ? addNumericSeparator(obj, str) : str;
    }
    if (typeof obj === "bigint") {
      var bigIntStr = String(obj) + "n";
      return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }
    var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
    if (typeof depth === "undefined") {
      depth = 0;
    }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
      return isArray8(obj) ? "[Array]" : "[Object]";
    }
    var indent = getIndent(opts, depth);
    if (typeof seen === "undefined") {
      seen = [];
    } else if (indexOf(seen, obj) >= 0) {
      return "[Circular]";
    }
    function inspect(value, from, noIndent) {
      if (from) {
        seen = $arrSlice.call(seen);
        seen.push(from);
      }
      if (noIndent) {
        var newOpts = {
          depth: opts.depth
        };
        if (has(opts, "quoteStyle")) {
          newOpts.quoteStyle = opts.quoteStyle;
        }
        return inspect_(value, newOpts, depth + 1, seen);
      }
      return inspect_(value, opts, depth + 1, seen);
    }
    if (typeof obj === "function" && !isRegExp(obj)) {
      var name2 = nameOf(obj);
      var keys = arrObjKeys(obj, inspect);
      return "[Function" + (name2 ? ": " + name2 : " (anonymous)") + "]" + (keys.length > 0 ? " { " + $join.call(keys, ", ") + " }" : "");
    }
    if (isSymbol(obj)) {
      var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
      return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
      var s5 = "<" + $toLowerCase.call(String(obj.nodeName));
      var attrs = obj.attributes || [];
      for (var i5 = 0; i5 < attrs.length; i5++) {
        s5 += " " + attrs[i5].name + "=" + wrapQuotes(quote(attrs[i5].value), "double", opts);
      }
      s5 += ">";
      if (obj.childNodes && obj.childNodes.length) {
        s5 += "...";
      }
      s5 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
      return s5;
    }
    if (isArray8(obj)) {
      if (obj.length === 0) {
        return "[]";
      }
      var xs = arrObjKeys(obj, inspect);
      if (indent && !singleLineValues(xs)) {
        return "[" + indentedJoin(xs, indent) + "]";
      }
      return "[ " + $join.call(xs, ", ") + " ]";
    }
    if (isError(obj)) {
      var parts = arrObjKeys(obj, inspect);
      if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
        return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
      }
      if (parts.length === 0) {
        return "[" + String(obj) + "]";
      }
      return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
    }
    if (typeof obj === "object" && customInspect) {
      if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
        return utilInspect(obj, {
          depth: maxDepth - depth
        });
      } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
        return obj.inspect();
      }
    }
    if (isMap(obj)) {
      var mapParts = [];
      if (mapForEach) {
        mapForEach.call(obj, function(value, key) {
          mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
        });
      }
      return collectionOf("Map", mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
      var setParts = [];
      if (setForEach) {
        setForEach.call(obj, function(value) {
          setParts.push(inspect(value, obj));
        });
      }
      return collectionOf("Set", setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
      return weakCollectionOf("WeakMap");
    }
    if (isWeakSet(obj)) {
      return weakCollectionOf("WeakSet");
    }
    if (isWeakRef(obj)) {
      return weakCollectionOf("WeakRef");
    }
    if (isNumber23(obj)) {
      return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
      return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean20(obj)) {
      return markBoxed(booleanValueOf.call(obj));
    }
    if (isString17(obj)) {
      return markBoxed(inspect(String(obj)));
    }
    if (typeof window !== "undefined" && obj === window) {
      return "{ [object Window] }";
    }
    if (typeof globalThis !== "undefined" && obj === globalThis || typeof _global4 !== "undefined" && obj === _global4) {
      return "{ [object globalThis] }";
    }
    if (!isDate(obj) && !isRegExp(obj)) {
      var ys = arrObjKeys(obj, inspect);
      var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
      var protoTag = obj instanceof Object ? "" : "null prototype";
      var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
      var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
      var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
      if (ys.length === 0) {
        return tag + "{}";
      }
      if (indent) {
        return tag + "{" + indentedJoin(ys, indent) + "}";
      }
      return tag + "{ " + $join.call(ys, ", ") + " }";
    }
    return String(obj);
  };
  function wrapQuotes(s5, defaultStyle, opts) {
    var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
    return quoteChar + s5 + quoteChar;
  }
  function quote(s5) {
    return $replace.call(String(s5), /"/g, "&quot;");
  }
  function isArray8(obj) {
    return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isDate(obj) {
    return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isRegExp(obj) {
    return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isError(obj) {
    return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isString17(obj) {
    return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isNumber23(obj) {
    return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isBoolean20(obj) {
    return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isSymbol(obj) {
    if (hasShammedSymbols) {
      return obj && typeof obj === "object" && obj instanceof Symbol;
    }
    if (typeof obj === "symbol") {
      return true;
    }
    if (!obj || typeof obj !== "object" || !symToString) {
      return false;
    }
    try {
      symToString.call(obj);
      return true;
    } catch (e7) {
    }
    return false;
  }
  function isBigInt(obj) {
    if (!obj || typeof obj !== "object" || !bigIntValueOf) {
      return false;
    }
    try {
      bigIntValueOf.call(obj);
      return true;
    } catch (e7) {
    }
    return false;
  }
  var hasOwn = Object.prototype.hasOwnProperty || function(key) {
    return key in (this || _global4);
  };
  function has(obj, key) {
    return hasOwn.call(obj, key);
  }
  function toStr(obj) {
    return objectToString.call(obj);
  }
  function nameOf(f5) {
    if (f5.name) {
      return f5.name;
    }
    var m7 = $match.call(functionToString.call(f5), /^function\s*([\w$]+)/);
    if (m7) {
      return m7[1];
    }
    return null;
  }
  function indexOf(xs, x5) {
    if (xs.indexOf) {
      return xs.indexOf(x5);
    }
    for (var i5 = 0, l5 = xs.length; i5 < l5; i5++) {
      if (xs[i5] === x5) {
        return i5;
      }
    }
    return -1;
  }
  function isMap(x5) {
    if (!mapSize || !x5 || typeof x5 !== "object") {
      return false;
    }
    try {
      mapSize.call(x5);
      try {
        setSize.call(x5);
      } catch (s5) {
        return true;
      }
      return x5 instanceof Map;
    } catch (e7) {
    }
    return false;
  }
  function isWeakMap(x5) {
    if (!weakMapHas || !x5 || typeof x5 !== "object") {
      return false;
    }
    try {
      weakMapHas.call(x5, weakMapHas);
      try {
        weakSetHas.call(x5, weakSetHas);
      } catch (s5) {
        return true;
      }
      return x5 instanceof WeakMap;
    } catch (e7) {
    }
    return false;
  }
  function isWeakRef(x5) {
    if (!weakRefDeref || !x5 || typeof x5 !== "object") {
      return false;
    }
    try {
      weakRefDeref.call(x5);
      return true;
    } catch (e7) {
    }
    return false;
  }
  function isSet(x5) {
    if (!setSize || !x5 || typeof x5 !== "object") {
      return false;
    }
    try {
      setSize.call(x5);
      try {
        mapSize.call(x5);
      } catch (m7) {
        return true;
      }
      return x5 instanceof Set;
    } catch (e7) {
    }
    return false;
  }
  function isWeakSet(x5) {
    if (!weakSetHas || !x5 || typeof x5 !== "object") {
      return false;
    }
    try {
      weakSetHas.call(x5, weakSetHas);
      try {
        weakMapHas.call(x5, weakMapHas);
      } catch (s5) {
        return true;
      }
      return x5 instanceof WeakSet;
    } catch (e7) {
    }
    return false;
  }
  function isElement(x5) {
    if (!x5 || typeof x5 !== "object") {
      return false;
    }
    if (typeof HTMLElement !== "undefined" && x5 instanceof HTMLElement) {
      return true;
    }
    return typeof x5.nodeName === "string" && typeof x5.getAttribute === "function";
  }
  function inspectString(str, opts) {
    if (str.length > opts.maxStringLength) {
      var remaining = str.length - opts.maxStringLength;
      var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
      return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
    }
    var s5 = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s5, "single", opts);
  }
  function lowbyte(c5) {
    var n6 = c5.charCodeAt(0);
    var x5 = {
      8: "b",
      9: "t",
      10: "n",
      12: "f",
      13: "r"
    }[n6];
    if (x5) {
      return "\\" + x5;
    }
    return "\\x" + (n6 < 16 ? "0" : "") + $toUpperCase.call(n6.toString(16));
  }
  function markBoxed(str) {
    return "Object(" + str + ")";
  }
  function weakCollectionOf(type) {
    return type + " { ? }";
  }
  function collectionOf(type, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
    return type + " (" + size + ") {" + joinedEntries + "}";
  }
  function singleLineValues(xs) {
    for (var i5 = 0; i5 < xs.length; i5++) {
      if (indexOf(xs[i5], "\n") >= 0) {
        return false;
      }
    }
    return true;
  }
  function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === "	") {
      baseIndent = "	";
    } else if (typeof opts.indent === "number" && opts.indent > 0) {
      baseIndent = $join.call(Array(opts.indent + 1), " ");
    } else {
      return null;
    }
    return {
      base: baseIndent,
      prev: $join.call(Array(depth + 1), baseIndent)
    };
  }
  function indentedJoin(xs, indent) {
    if (xs.length === 0) {
      return "";
    }
    var lineJoiner = "\n" + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
  }
  function arrObjKeys(obj, inspect) {
    var isArr = isArray8(obj);
    var xs = [];
    if (isArr) {
      xs.length = obj.length;
      for (var i5 = 0; i5 < obj.length; i5++) {
        xs[i5] = has(obj, i5) ? inspect(obj[i5], obj) : "";
      }
    }
    var syms = typeof gOPS === "function" ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
      symMap = {};
      for (var k5 = 0; k5 < syms.length; k5++) {
        symMap["$" + syms[k5]] = syms[k5];
      }
    }
    for (var key in obj) {
      if (!has(obj, key)) {
        continue;
      }
      if (isArr && String(Number(key)) === key && key < obj.length) {
        continue;
      }
      if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
        continue;
      } else if ($test.call(/[^\w$]/, key)) {
        xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
      } else {
        xs.push(key + ": " + inspect(obj[key], obj));
      }
    }
    if (typeof gOPS === "function") {
      for (var j4 = 0; j4 < syms.length; j4++) {
        if (isEnumerable.call(obj, syms[j4])) {
          xs.push("[" + inspect(syms[j4]) + "]: " + inspect(obj[syms[j4]], obj));
        }
      }
    }
    return xs;
  }
  return exports$83;
}
var exports$73 = {};
var _dewExec$63 = false;
function dew$63() {
  if (_dewExec$63) return exports$73;
  _dewExec$63 = true;
  var GetIntrinsic = dew$72();
  var callBound = dew7();
  var inspect = dew$73();
  var $TypeError = dew$e2();
  var $WeakMap = GetIntrinsic("%WeakMap%", true);
  var $Map = GetIntrinsic("%Map%", true);
  var $weakMapGet = callBound("WeakMap.prototype.get", true);
  var $weakMapSet = callBound("WeakMap.prototype.set", true);
  var $weakMapHas = callBound("WeakMap.prototype.has", true);
  var $mapGet = callBound("Map.prototype.get", true);
  var $mapSet = callBound("Map.prototype.set", true);
  var $mapHas = callBound("Map.prototype.has", true);
  var listGetNode = function(list, key) {
    var prev = list;
    var curr;
    for (; (curr = prev.next) !== null; prev = curr) {
      if (curr.key === key) {
        prev.next = curr.next;
        curr.next = /** @type {NonNullable<typeof list.next>} */
        list.next;
        list.next = curr;
        return curr;
      }
    }
  };
  var listGet = function(objects, key) {
    var node = listGetNode(objects, key);
    return node && node.value;
  };
  var listSet = function(objects, key, value) {
    var node = listGetNode(objects, key);
    if (node) {
      node.value = value;
    } else {
      objects.next = /** @type {import('.').ListNode<typeof value>} */
      {
        // eslint-disable-line no-param-reassign, no-extra-parens
        key,
        next: objects.next,
        value
      };
    }
  };
  var listHas = function(objects, key) {
    return !!listGetNode(objects, key);
  };
  exports$73 = function getSideChannel() {
    var $wm;
    var $m;
    var $o;
    var channel = {
      assert: function(key) {
        if (!channel.has(key)) {
          throw new $TypeError("Side channel does not contain " + inspect(key));
        }
      },
      get: function(key) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if ($wm) {
            return $weakMapGet($wm, key);
          }
        } else if ($Map) {
          if ($m) {
            return $mapGet($m, key);
          }
        } else {
          if ($o) {
            return listGet($o, key);
          }
        }
      },
      has: function(key) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if ($wm) {
            return $weakMapHas($wm, key);
          }
        } else if ($Map) {
          if ($m) {
            return $mapHas($m, key);
          }
        } else {
          if ($o) {
            return listHas($o, key);
          }
        }
        return false;
      },
      set: function(key, value) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if (!$wm) {
            $wm = new $WeakMap();
          }
          $weakMapSet($wm, key, value);
        } else if ($Map) {
          if (!$m) {
            $m = new $Map();
          }
          $mapSet($m, key, value);
        } else {
          if (!$o) {
            $o = {
              key: {},
              next: null
            };
          }
          listSet($o, key, value);
        }
      }
    };
    return channel;
  };
  return exports$73;
}
var exports$63 = {};
var _dewExec$53 = false;
function dew$53() {
  if (_dewExec$53) return exports$63;
  _dewExec$53 = true;
  var replace = String.prototype.replace;
  var percentTwenties = /%20/g;
  var Format = {
    RFC1738: "RFC1738",
    RFC3986: "RFC3986"
  };
  exports$63 = {
    "default": Format.RFC3986,
    formatters: {
      RFC1738: function(value) {
        return replace.call(value, percentTwenties, "+");
      },
      RFC3986: function(value) {
        return String(value);
      }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
  };
  return exports$63;
}
var exports$53 = {};
var _dewExec$43 = false;
function dew$43() {
  if (_dewExec$43) return exports$53;
  _dewExec$43 = true;
  var formats = dew$53();
  var has = Object.prototype.hasOwnProperty;
  var isArray8 = Array.isArray;
  var hexTable = function() {
    var array = [];
    for (var i5 = 0; i5 < 256; ++i5) {
      array.push("%" + ((i5 < 16 ? "0" : "") + i5.toString(16)).toUpperCase());
    }
    return array;
  }();
  var compactQueue = function compactQueue2(queue3) {
    while (queue3.length > 1) {
      var item = queue3.pop();
      var obj = item.obj[item.prop];
      if (isArray8(obj)) {
        var compacted = [];
        for (var j4 = 0; j4 < obj.length; ++j4) {
          if (typeof obj[j4] !== "undefined") {
            compacted.push(obj[j4]);
          }
        }
        item.obj[item.prop] = compacted;
      }
    }
  };
  var arrayToObject = function arrayToObject2(source, options) {
    var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
    for (var i5 = 0; i5 < source.length; ++i5) {
      if (typeof source[i5] !== "undefined") {
        obj[i5] = source[i5];
      }
    }
    return obj;
  };
  var merge3 = function merge4(target, source, options) {
    if (!source) {
      return target;
    }
    if (typeof source !== "object") {
      if (isArray8(target)) {
        target.push(source);
      } else if (target && typeof target === "object") {
        if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
          target[source] = true;
        }
      } else {
        return [target, source];
      }
      return target;
    }
    if (!target || typeof target !== "object") {
      return [target].concat(source);
    }
    var mergeTarget = target;
    if (isArray8(target) && !isArray8(source)) {
      mergeTarget = arrayToObject(target, options);
    }
    if (isArray8(target) && isArray8(source)) {
      source.forEach(function(item, i5) {
        if (has.call(target, i5)) {
          var targetItem = target[i5];
          if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
            target[i5] = merge4(targetItem, item, options);
          } else {
            target.push(item);
          }
        } else {
          target[i5] = item;
        }
      });
      return target;
    }
    return Object.keys(source).reduce(function(acc, key) {
      var value = source[key];
      if (has.call(acc, key)) {
        acc[key] = merge4(acc[key], value, options);
      } else {
        acc[key] = value;
      }
      return acc;
    }, mergeTarget);
  };
  var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function(acc, key) {
      acc[key] = source[key];
      return acc;
    }, target);
  };
  var decode2 = function(str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, " ");
    if (charset === "iso-8859-1") {
      return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    try {
      return decodeURIComponent(strWithoutPlus);
    } catch (e7) {
      return strWithoutPlus;
    }
  };
  var limit = 1024;
  var encode2 = function encode3(str, defaultEncoder, charset, kind, format3) {
    if (str.length === 0) {
      return str;
    }
    var string = str;
    if (typeof str === "symbol") {
      string = Symbol.prototype.toString.call(str);
    } else if (typeof str !== "string") {
      string = String(str);
    }
    if (charset === "iso-8859-1") {
      return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
        return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
      });
    }
    var out = "";
    for (var j4 = 0; j4 < string.length; j4 += limit) {
      var segment = string.length >= limit ? string.slice(j4, j4 + limit) : string;
      var arr = [];
      for (var i5 = 0; i5 < segment.length; ++i5) {
        var c5 = segment.charCodeAt(i5);
        if (c5 === 45 || c5 === 46 || c5 === 95 || c5 === 126 || c5 >= 48 && c5 <= 57 || c5 >= 65 && c5 <= 90 || c5 >= 97 && c5 <= 122 || format3 === formats.RFC1738 && (c5 === 40 || c5 === 41)) {
          arr[arr.length] = segment.charAt(i5);
          continue;
        }
        if (c5 < 128) {
          arr[arr.length] = hexTable[c5];
          continue;
        }
        if (c5 < 2048) {
          arr[arr.length] = hexTable[192 | c5 >> 6] + hexTable[128 | c5 & 63];
          continue;
        }
        if (c5 < 55296 || c5 >= 57344) {
          arr[arr.length] = hexTable[224 | c5 >> 12] + hexTable[128 | c5 >> 6 & 63] + hexTable[128 | c5 & 63];
          continue;
        }
        i5 += 1;
        c5 = 65536 + ((c5 & 1023) << 10 | segment.charCodeAt(i5) & 1023);
        arr[arr.length] = hexTable[240 | c5 >> 18] + hexTable[128 | c5 >> 12 & 63] + hexTable[128 | c5 >> 6 & 63] + hexTable[128 | c5 & 63];
      }
      out += arr.join("");
    }
    return out;
  };
  var compact = function compact2(value) {
    var queue3 = [{
      obj: {
        o: value
      },
      prop: "o"
    }];
    var refs = [];
    for (var i5 = 0; i5 < queue3.length; ++i5) {
      var item = queue3[i5];
      var obj = item.obj[item.prop];
      var keys = Object.keys(obj);
      for (var j4 = 0; j4 < keys.length; ++j4) {
        var key = keys[j4];
        var val = obj[key];
        if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
          queue3.push({
            obj,
            prop: key
          });
          refs.push(val);
        }
      }
    }
    compactQueue(queue3);
    return value;
  };
  var isRegExp = function isRegExp2(obj) {
    return Object.prototype.toString.call(obj) === "[object RegExp]";
  };
  var isBuffer = function isBuffer2(obj) {
    if (!obj || typeof obj !== "object") {
      return false;
    }
    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
  };
  var combine = function combine2(a5, b6) {
    return [].concat(a5, b6);
  };
  var maybeMap = function maybeMap2(val, fn) {
    if (isArray8(val)) {
      var mapped = [];
      for (var i5 = 0; i5 < val.length; i5 += 1) {
        mapped.push(fn(val[i5]));
      }
      return mapped;
    }
    return fn(val);
  };
  exports$53 = {
    arrayToObject,
    assign,
    combine,
    compact,
    decode: decode2,
    encode: encode2,
    isBuffer,
    isRegExp,
    maybeMap,
    merge: merge3
  };
  return exports$53;
}
var exports$43 = {};
var _dewExec$33 = false;
function dew$33() {
  if (_dewExec$33) return exports$43;
  _dewExec$33 = true;
  var getSideChannel = dew$63();
  var utils = dew$43();
  var formats = dew$53();
  var has = Object.prototype.hasOwnProperty;
  var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
      return prefix + "[]";
    },
    comma: "comma",
    indices: function indices(prefix, key) {
      return prefix + "[" + key + "]";
    },
    repeat: function repeat(prefix) {
      return prefix;
    }
  };
  var isArray8 = Array.isArray;
  var push = Array.prototype.push;
  var pushToArray = function(arr, valueOrArray) {
    push.apply(arr, isArray8(valueOrArray) ? valueOrArray : [valueOrArray]);
  };
  var toISO = Date.prototype.toISOString;
  var defaultFormat = formats["default"];
  var defaults20 = {
    addQueryPrefix: false,
    allowDots: false,
    allowEmptyArrays: false,
    arrayFormat: "indices",
    charset: "utf-8",
    charsetSentinel: false,
    delimiter: "&",
    encode: true,
    encodeDotInKeys: false,
    encoder: utils.encode,
    encodeValuesOnly: false,
    format: defaultFormat,
    formatter: formats.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
      return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
  };
  var isNonNullishPrimitive = function isNonNullishPrimitive2(v11) {
    return typeof v11 === "string" || typeof v11 === "number" || typeof v11 === "boolean" || typeof v11 === "symbol" || typeof v11 === "bigint";
  };
  var sentinel = {};
  var stringify = function stringify2(object, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format3, formatter, encodeValuesOnly, charset, sideChannel) {
    var obj = object;
    var tmpSc = sideChannel;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
      var pos = tmpSc.get(object);
      step += 1;
      if (typeof pos !== "undefined") {
        if (pos === step) {
          throw new RangeError("Cyclic object value");
        } else {
          findFlag = true;
        }
      }
      if (typeof tmpSc.get(sentinel) === "undefined") {
        step = 0;
      }
    }
    if (typeof filter === "function") {
      obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
      obj = serializeDate(obj);
    } else if (generateArrayPrefix === "comma" && isArray8(obj)) {
      obj = utils.maybeMap(obj, function(value2) {
        if (value2 instanceof Date) {
          return serializeDate(value2);
        }
        return value2;
      });
    }
    if (obj === null) {
      if (strictNullHandling) {
        return encoder && !encodeValuesOnly ? encoder(prefix, defaults20.encoder, charset, "key", format3) : prefix;
      }
      obj = "";
    }
    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
      if (encoder) {
        var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults20.encoder, charset, "key", format3);
        return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults20.encoder, charset, "value", format3))];
      }
      return [formatter(prefix) + "=" + formatter(String(obj))];
    }
    var values = [];
    if (typeof obj === "undefined") {
      return values;
    }
    var objKeys;
    if (generateArrayPrefix === "comma" && isArray8(obj)) {
      if (encodeValuesOnly && encoder) {
        obj = utils.maybeMap(obj, encoder);
      }
      objKeys = [{
        value: obj.length > 0 ? obj.join(",") || null : void 0
      }];
    } else if (isArray8(filter)) {
      objKeys = filter;
    } else {
      var keys = Object.keys(obj);
      objKeys = sort ? keys.sort(sort) : keys;
    }
    var encodedPrefix = encodeDotInKeys ? prefix.replace(/\./g, "%2E") : prefix;
    var adjustedPrefix = commaRoundTrip && isArray8(obj) && obj.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
    if (allowEmptyArrays && isArray8(obj) && obj.length === 0) {
      return adjustedPrefix + "[]";
    }
    for (var j4 = 0; j4 < objKeys.length; ++j4) {
      var key = objKeys[j4];
      var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
      if (skipNulls && value === null) {
        continue;
      }
      var encodedKey = allowDots && encodeDotInKeys ? key.replace(/\./g, "%2E") : key;
      var keyPrefix = isArray8(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
      sideChannel.set(object, step);
      var valueSideChannel = getSideChannel();
      valueSideChannel.set(sentinel, sideChannel);
      pushToArray(values, stringify2(value, keyPrefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, generateArrayPrefix === "comma" && encodeValuesOnly && isArray8(obj) ? null : encoder, filter, sort, allowDots, serializeDate, format3, formatter, encodeValuesOnly, charset, valueSideChannel));
    }
    return values;
  };
  var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
    if (!opts) {
      return defaults20;
    }
    if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
      throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    }
    if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
      throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
    }
    if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
      throw new TypeError("Encoder has to be a function.");
    }
    var charset = opts.charset || defaults20.charset;
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    var format3 = formats["default"];
    if (typeof opts.format !== "undefined") {
      if (!has.call(formats.formatters, opts.format)) {
        throw new TypeError("Unknown format option provided.");
      }
      format3 = opts.format;
    }
    var formatter = formats.formatters[format3];
    var filter = defaults20.filter;
    if (typeof opts.filter === "function" || isArray8(opts.filter)) {
      filter = opts.filter;
    }
    var arrayFormat;
    if (opts.arrayFormat in arrayPrefixGenerators) {
      arrayFormat = opts.arrayFormat;
    } else if ("indices" in opts) {
      arrayFormat = opts.indices ? "indices" : "repeat";
    } else {
      arrayFormat = defaults20.arrayFormat;
    }
    if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
      throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    }
    var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults20.allowDots : !!opts.allowDots;
    return {
      addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults20.addQueryPrefix,
      allowDots,
      allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults20.allowEmptyArrays,
      arrayFormat,
      charset,
      charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults20.charsetSentinel,
      commaRoundTrip: opts.commaRoundTrip,
      delimiter: typeof opts.delimiter === "undefined" ? defaults20.delimiter : opts.delimiter,
      encode: typeof opts.encode === "boolean" ? opts.encode : defaults20.encode,
      encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults20.encodeDotInKeys,
      encoder: typeof opts.encoder === "function" ? opts.encoder : defaults20.encoder,
      encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults20.encodeValuesOnly,
      filter,
      format: format3,
      formatter,
      serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults20.serializeDate,
      skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults20.skipNulls,
      sort: typeof opts.sort === "function" ? opts.sort : null,
      strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults20.strictNullHandling
    };
  };
  exports$43 = function(object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);
    var objKeys;
    var filter;
    if (typeof options.filter === "function") {
      filter = options.filter;
      obj = filter("", obj);
    } else if (isArray8(options.filter)) {
      filter = options.filter;
      objKeys = filter;
    }
    var keys = [];
    if (typeof obj !== "object" || obj === null) {
      return "";
    }
    var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
    var commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
    if (!objKeys) {
      objKeys = Object.keys(obj);
    }
    if (options.sort) {
      objKeys.sort(options.sort);
    }
    var sideChannel = getSideChannel();
    for (var i5 = 0; i5 < objKeys.length; ++i5) {
      var key = objKeys[i5];
      if (options.skipNulls && obj[key] === null) {
        continue;
      }
      pushToArray(keys, stringify(obj[key], key, generateArrayPrefix, commaRoundTrip, options.allowEmptyArrays, options.strictNullHandling, options.skipNulls, options.encodeDotInKeys, options.encode ? options.encoder : null, options.filter, options.sort, options.allowDots, options.serializeDate, options.format, options.formatter, options.encodeValuesOnly, options.charset, sideChannel));
    }
    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? "?" : "";
    if (options.charsetSentinel) {
      if (options.charset === "iso-8859-1") {
        prefix += "utf8=%26%2310003%3B&";
      } else {
        prefix += "utf8=%E2%9C%93&";
      }
    }
    return joined.length > 0 ? prefix + joined : "";
  };
  return exports$43;
}
var exports$33 = {};
var _dewExec$24 = false;
function dew$24() {
  if (_dewExec$24) return exports$33;
  _dewExec$24 = true;
  var utils = dew$43();
  var has = Object.prototype.hasOwnProperty;
  var isArray8 = Array.isArray;
  var defaults20 = {
    allowDots: false,
    allowEmptyArrays: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: "utf-8",
    charsetSentinel: false,
    comma: false,
    decodeDotInKeys: false,
    decoder: utils.decode,
    delimiter: "&",
    depth: 5,
    duplicates: "combine",
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1e3,
    parseArrays: true,
    plainObjects: false,
    strictDepth: false,
    strictNullHandling: false
  };
  var interpretNumericEntities = function(str) {
    return str.replace(/&#(\d+);/g, function($0, numberStr) {
      return String.fromCharCode(parseInt(numberStr, 10));
    });
  };
  var parseArrayValue = function(val, options) {
    if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
      return val.split(",");
    }
    return val;
  };
  var isoSentinel = "utf8=%26%2310003%3B";
  var charsetSentinel = "utf8=%E2%9C%93";
  var parseValues = function parseQueryStringValues(str, options) {
    var obj = {
      __proto__: null
    };
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
    cleanStr = cleanStr.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1;
    var i5;
    var charset = options.charset;
    if (options.charsetSentinel) {
      for (i5 = 0; i5 < parts.length; ++i5) {
        if (parts[i5].indexOf("utf8=") === 0) {
          if (parts[i5] === charsetSentinel) {
            charset = "utf-8";
          } else if (parts[i5] === isoSentinel) {
            charset = "iso-8859-1";
          }
          skipIndex = i5;
          i5 = parts.length;
        }
      }
    }
    for (i5 = 0; i5 < parts.length; ++i5) {
      if (i5 === skipIndex) {
        continue;
      }
      var part = parts[i5];
      var bracketEqualsPos = part.indexOf("]=");
      var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
      var key, val;
      if (pos === -1) {
        key = options.decoder(part, defaults20.decoder, charset, "key");
        val = options.strictNullHandling ? null : "";
      } else {
        key = options.decoder(part.slice(0, pos), defaults20.decoder, charset, "key");
        val = utils.maybeMap(parseArrayValue(part.slice(pos + 1), options), function(encodedVal) {
          return options.decoder(encodedVal, defaults20.decoder, charset, "value");
        });
      }
      if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
        val = interpretNumericEntities(val);
      }
      if (part.indexOf("[]=") > -1) {
        val = isArray8(val) ? [val] : val;
      }
      var existing = has.call(obj, key);
      if (existing && options.duplicates === "combine") {
        obj[key] = utils.combine(obj[key], val);
      } else if (!existing || options.duplicates === "last") {
        obj[key] = val;
      }
    }
    return obj;
  };
  var parseObject = function(chain, val, options, valuesParsed) {
    var leaf = valuesParsed ? val : parseArrayValue(val, options);
    for (var i5 = chain.length - 1; i5 >= 0; --i5) {
      var obj;
      var root = chain[i5];
      if (root === "[]" && options.parseArrays) {
        obj = options.allowEmptyArrays && (leaf === "" || options.strictNullHandling && leaf === null) ? [] : [].concat(leaf);
      } else {
        obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
        var cleanRoot = root.charAt(0) === "[" && root.charAt(root.length - 1) === "]" ? root.slice(1, -1) : root;
        var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
        var index = parseInt(decodedRoot, 10);
        if (!options.parseArrays && decodedRoot === "") {
          obj = {
            0: leaf
          };
        } else if (!isNaN(index) && root !== decodedRoot && String(index) === decodedRoot && index >= 0 && options.parseArrays && index <= options.arrayLimit) {
          obj = [];
          obj[index] = leaf;
        } else if (decodedRoot !== "__proto__") {
          obj[decodedRoot] = leaf;
        }
      }
      leaf = obj;
    }
    return leaf;
  };
  var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
      return;
    }
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;
    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;
    var keys = [];
    if (parent) {
      if (!options.plainObjects && has.call(Object.prototype, parent)) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(parent);
    }
    var i5 = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i5 < options.depth) {
      i5 += 1;
      if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys.push(segment[1]);
    }
    if (segment) {
      if (options.strictDepth === true) {
        throw new RangeError("Input depth exceeded depth option of " + options.depth + " and strictDepth is true");
      }
      keys.push("[" + key.slice(segment.index) + "]");
    }
    return parseObject(keys, val, options, valuesParsed);
  };
  var normalizeParseOptions = function normalizeParseOptions2(opts) {
    if (!opts) {
      return defaults20;
    }
    if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
      throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    }
    if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") {
      throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
    }
    if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") {
      throw new TypeError("Decoder has to be a function.");
    }
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    var charset = typeof opts.charset === "undefined" ? defaults20.charset : opts.charset;
    var duplicates = typeof opts.duplicates === "undefined" ? defaults20.duplicates : opts.duplicates;
    if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") {
      throw new TypeError("The duplicates option must be either combine, first, or last");
    }
    var allowDots = typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults20.allowDots : !!opts.allowDots;
    return {
      allowDots,
      allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults20.allowEmptyArrays,
      allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults20.allowPrototypes,
      allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults20.allowSparse,
      arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults20.arrayLimit,
      charset,
      charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults20.charsetSentinel,
      comma: typeof opts.comma === "boolean" ? opts.comma : defaults20.comma,
      decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults20.decodeDotInKeys,
      decoder: typeof opts.decoder === "function" ? opts.decoder : defaults20.decoder,
      delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults20.delimiter,
      // eslint-disable-next-line no-implicit-coercion, no-extra-parens
      depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults20.depth,
      duplicates,
      ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
      interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults20.interpretNumericEntities,
      parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults20.parameterLimit,
      parseArrays: opts.parseArrays !== false,
      plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults20.plainObjects,
      strictDepth: typeof opts.strictDepth === "boolean" ? !!opts.strictDepth : defaults20.strictDepth,
      strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults20.strictNullHandling
    };
  };
  exports$33 = function(str, opts) {
    var options = normalizeParseOptions(opts);
    if (str === "" || str === null || typeof str === "undefined") {
      return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
    }
    var tempObj = typeof str === "string" ? parseValues(str, options) : str;
    var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
    var keys = Object.keys(tempObj);
    for (var i5 = 0; i5 < keys.length; ++i5) {
      var key = keys[i5];
      var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
      obj = utils.merge(obj, newObj, options);
    }
    if (options.allowSparse === true) {
      return obj;
    }
    return utils.compact(obj);
  };
  return exports$33;
}
var exports$25 = {};
var _dewExec$15 = false;
function dew$15() {
  if (_dewExec$15) return exports$25;
  _dewExec$15 = true;
  var stringify = dew$33();
  var parse3 = dew$24();
  var formats = dew$53();
  exports$25 = {
    formats,
    parse: parse3,
    stringify
  };
  return exports$25;
}
var exports$18 = {};
var _dewExec9 = false;
function dew9() {
  if (_dewExec9) return exports$18;
  _dewExec9 = true;
  var punycode = exports7;
  function Url2() {
    this.protocol = null;
    this.slashes = null;
    this.auth = null;
    this.host = null;
    this.port = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.query = null;
    this.pathname = null;
    this.path = null;
    this.href = null;
  }
  var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/, delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"], unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape), hostEndingChars = ["/", "?", "#"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {
    javascript: true,
    "javascript:": true
  }, hostlessProtocol = {
    javascript: true,
    "javascript:": true
  }, slashedProtocol = {
    http: true,
    https: true,
    ftp: true,
    gopher: true,
    file: true,
    "http:": true,
    "https:": true,
    "ftp:": true,
    "gopher:": true,
    "file:": true
  }, querystring = dew$15();
  function urlParse(url, parseQueryString, slashesDenoteHost) {
    if (url && typeof url === "object" && url instanceof Url2) {
      return url;
    }
    var u5 = new Url2();
    u5.parse(url, parseQueryString, slashesDenoteHost);
    return u5;
  }
  Url2.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
    if (typeof url !== "string") {
      throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
    }
    var queryIndex = url.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter), slashRegex = /\\/g;
    uSplit[0] = uSplit[0].replace(slashRegex, "/");
    url = uSplit.join(splitter);
    var rest = url;
    rest = rest.trim();
    if (!slashesDenoteHost && url.split("#").length === 1) {
      var simplePath = simplePathPattern.exec(rest);
      if (simplePath) {
        this.path = rest;
        this.href = rest;
        this.pathname = simplePath[1];
        if (simplePath[2]) {
          this.search = simplePath[2];
          if (parseQueryString) {
            this.query = querystring.parse(this.search.substr(1));
          } else {
            this.query = this.search.substr(1);
          }
        } else if (parseQueryString) {
          this.search = "";
          this.query = {};
        }
        return this;
      }
    }
    var proto = protocolPattern.exec(rest);
    if (proto) {
      proto = proto[0];
      var lowerProto = proto.toLowerCase();
      this.protocol = lowerProto;
      rest = rest.substr(proto.length);
    }
    if (slashesDenoteHost || proto || rest.match(/^\/\/[^@/]+@[^@/]+/)) {
      var slashes = rest.substr(0, 2) === "//";
      if (slashes && !(proto && hostlessProtocol[proto])) {
        rest = rest.substr(2);
        this.slashes = true;
      }
    }
    if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
      var hostEnd = -1;
      for (var i5 = 0; i5 < hostEndingChars.length; i5++) {
        var hec = rest.indexOf(hostEndingChars[i5]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
          hostEnd = hec;
        }
      }
      var auth, atSign;
      if (hostEnd === -1) {
        atSign = rest.lastIndexOf("@");
      } else {
        atSign = rest.lastIndexOf("@", hostEnd);
      }
      if (atSign !== -1) {
        auth = rest.slice(0, atSign);
        rest = rest.slice(atSign + 1);
        this.auth = decodeURIComponent(auth);
      }
      hostEnd = -1;
      for (var i5 = 0; i5 < nonHostChars.length; i5++) {
        var hec = rest.indexOf(nonHostChars[i5]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
          hostEnd = hec;
        }
      }
      if (hostEnd === -1) {
        hostEnd = rest.length;
      }
      this.host = rest.slice(0, hostEnd);
      rest = rest.slice(hostEnd);
      this.parseHost();
      this.hostname = this.hostname || "";
      var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
      if (!ipv6Hostname) {
        var hostparts = this.hostname.split(/\./);
        for (var i5 = 0, l5 = hostparts.length; i5 < l5; i5++) {
          var part = hostparts[i5];
          if (!part) {
            continue;
          }
          if (!part.match(hostnamePartPattern)) {
            var newpart = "";
            for (var j4 = 0, k5 = part.length; j4 < k5; j4++) {
              if (part.charCodeAt(j4) > 127) {
                newpart += "x";
              } else {
                newpart += part[j4];
              }
            }
            if (!newpart.match(hostnamePartPattern)) {
              var validParts = hostparts.slice(0, i5);
              var notHost = hostparts.slice(i5 + 1);
              var bit = part.match(hostnamePartStart);
              if (bit) {
                validParts.push(bit[1]);
                notHost.unshift(bit[2]);
              }
              if (notHost.length) {
                rest = "/" + notHost.join(".") + rest;
              }
              this.hostname = validParts.join(".");
              break;
            }
          }
        }
      }
      if (this.hostname.length > hostnameMaxLen) {
        this.hostname = "";
      } else {
        this.hostname = this.hostname.toLowerCase();
      }
      if (!ipv6Hostname) {
        this.hostname = punycode.toASCII(this.hostname);
      }
      var p5 = this.port ? ":" + this.port : "";
      var h6 = this.hostname || "";
      this.host = h6 + p5;
      this.href += this.host;
      if (ipv6Hostname) {
        this.hostname = this.hostname.substr(1, this.hostname.length - 2);
        if (rest[0] !== "/") {
          rest = "/" + rest;
        }
      }
    }
    if (!unsafeProtocol[lowerProto]) {
      for (var i5 = 0, l5 = autoEscape.length; i5 < l5; i5++) {
        var ae2 = autoEscape[i5];
        if (rest.indexOf(ae2) === -1) {
          continue;
        }
        var esc = encodeURIComponent(ae2);
        if (esc === ae2) {
          esc = escape(ae2);
        }
        rest = rest.split(ae2).join(esc);
      }
    }
    var hash = rest.indexOf("#");
    if (hash !== -1) {
      this.hash = rest.substr(hash);
      rest = rest.slice(0, hash);
    }
    var qm = rest.indexOf("?");
    if (qm !== -1) {
      this.search = rest.substr(qm);
      this.query = rest.substr(qm + 1);
      if (parseQueryString) {
        this.query = querystring.parse(this.query);
      }
      rest = rest.slice(0, qm);
    } else if (parseQueryString) {
      this.search = "";
      this.query = {};
    }
    if (rest) {
      this.pathname = rest;
    }
    if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
      this.pathname = "/";
    }
    if (this.pathname || this.search) {
      var p5 = this.pathname || "";
      var s5 = this.search || "";
      this.path = p5 + s5;
    }
    this.href = this.format();
    return this;
  };
  function urlFormat(obj) {
    if (typeof obj === "string") {
      obj = urlParse(obj);
    }
    if (!(obj instanceof Url2)) {
      return Url2.prototype.format.call(obj);
    }
    return obj.format();
  }
  Url2.prototype.format = function() {
    var auth = this.auth || "";
    if (auth) {
      auth = encodeURIComponent(auth);
      auth = auth.replace(/%3A/i, ":");
      auth += "@";
    }
    var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
    if (this.host) {
      host = auth + this.host;
    } else if (this.hostname) {
      host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
      if (this.port) {
        host += ":" + this.port;
      }
    }
    if (this.query && typeof this.query === "object" && Object.keys(this.query).length) {
      query = querystring.stringify(this.query, {
        arrayFormat: "repeat",
        addQueryPrefix: false
      });
    }
    var search = this.search || query && "?" + query || "";
    if (protocol && protocol.substr(-1) !== ":") {
      protocol += ":";
    }
    if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
      host = "//" + (host || "");
      if (pathname && pathname.charAt(0) !== "/") {
        pathname = "/" + pathname;
      }
    } else if (!host) {
      host = "";
    }
    if (hash && hash.charAt(0) !== "#") {
      hash = "#" + hash;
    }
    if (search && search.charAt(0) !== "?") {
      search = "?" + search;
    }
    pathname = pathname.replace(/[?#]/g, function(match) {
      return encodeURIComponent(match);
    });
    search = search.replace("#", "%23");
    return protocol + host + pathname + search + hash;
  };
  function urlResolve(source, relative2) {
    return urlParse(source, false, true).resolve(relative2);
  }
  Url2.prototype.resolve = function(relative2) {
    return this.resolveObject(urlParse(relative2, false, true)).format();
  };
  function urlResolveObject(source, relative2) {
    if (!source) {
      return relative2;
    }
    return urlParse(source, false, true).resolveObject(relative2);
  }
  Url2.prototype.resolveObject = function(relative2) {
    if (typeof relative2 === "string") {
      var rel = new Url2();
      rel.parse(relative2, false, true);
      relative2 = rel;
    }
    var result = new Url2();
    var tkeys = Object.keys(this);
    for (var tk = 0; tk < tkeys.length; tk++) {
      var tkey = tkeys[tk];
      result[tkey] = this[tkey];
    }
    result.hash = relative2.hash;
    if (relative2.href === "") {
      result.href = result.format();
      return result;
    }
    if (relative2.slashes && !relative2.protocol) {
      var rkeys = Object.keys(relative2);
      for (var rk = 0; rk < rkeys.length; rk++) {
        var rkey = rkeys[rk];
        if (rkey !== "protocol") {
          result[rkey] = relative2[rkey];
        }
      }
      if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
        result.pathname = "/";
        result.path = result.pathname;
      }
      result.href = result.format();
      return result;
    }
    if (relative2.protocol && relative2.protocol !== result.protocol) {
      if (!slashedProtocol[relative2.protocol]) {
        var keys = Object.keys(relative2);
        for (var v11 = 0; v11 < keys.length; v11++) {
          var k5 = keys[v11];
          result[k5] = relative2[k5];
        }
        result.href = result.format();
        return result;
      }
      result.protocol = relative2.protocol;
      if (!relative2.host && !hostlessProtocol[relative2.protocol]) {
        var relPath = (relative2.pathname || "").split("/");
        while (relPath.length && !(relative2.host = relPath.shift())) {
        }
        if (!relative2.host) {
          relative2.host = "";
        }
        if (!relative2.hostname) {
          relative2.hostname = "";
        }
        if (relPath[0] !== "") {
          relPath.unshift("");
        }
        if (relPath.length < 2) {
          relPath.unshift("");
        }
        result.pathname = relPath.join("/");
      } else {
        result.pathname = relative2.pathname;
      }
      result.search = relative2.search;
      result.query = relative2.query;
      result.host = relative2.host || "";
      result.auth = relative2.auth;
      result.hostname = relative2.hostname || relative2.host;
      result.port = relative2.port;
      if (result.pathname || result.search) {
        var p5 = result.pathname || "";
        var s5 = result.search || "";
        result.path = p5 + s5;
      }
      result.slashes = result.slashes || relative2.slashes;
      result.href = result.format();
      return result;
    }
    var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative2.host || relative2.pathname && relative2.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative2.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative2.pathname && relative2.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
    if (psychotic) {
      result.hostname = "";
      result.port = null;
      if (result.host) {
        if (srcPath[0] === "") {
          srcPath[0] = result.host;
        } else {
          srcPath.unshift(result.host);
        }
      }
      result.host = "";
      if (relative2.protocol) {
        relative2.hostname = null;
        relative2.port = null;
        if (relative2.host) {
          if (relPath[0] === "") {
            relPath[0] = relative2.host;
          } else {
            relPath.unshift(relative2.host);
          }
        }
        relative2.host = null;
      }
      mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
    }
    if (isRelAbs) {
      result.host = relative2.host || relative2.host === "" ? relative2.host : result.host;
      result.hostname = relative2.hostname || relative2.hostname === "" ? relative2.hostname : result.hostname;
      result.search = relative2.search;
      result.query = relative2.query;
      srcPath = relPath;
    } else if (relPath.length) {
      if (!srcPath) {
        srcPath = [];
      }
      srcPath.pop();
      srcPath = srcPath.concat(relPath);
      result.search = relative2.search;
      result.query = relative2.query;
    } else if (relative2.search != null) {
      if (psychotic) {
        result.host = srcPath.shift();
        result.hostname = result.host;
        var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.hostname = authInHost.shift();
          result.host = result.hostname;
        }
      }
      result.search = relative2.search;
      result.query = relative2.query;
      if (result.pathname !== null || result.search !== null) {
        result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
      }
      result.href = result.format();
      return result;
    }
    if (!srcPath.length) {
      result.pathname = null;
      if (result.search) {
        result.path = "/" + result.search;
      } else {
        result.path = null;
      }
      result.href = result.format();
      return result;
    }
    var last = srcPath.slice(-1)[0];
    var hasTrailingSlash = (result.host || relative2.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
    var up2 = 0;
    for (var i5 = srcPath.length; i5 >= 0; i5--) {
      last = srcPath[i5];
      if (last === ".") {
        srcPath.splice(i5, 1);
      } else if (last === "..") {
        srcPath.splice(i5, 1);
        up2++;
      } else if (up2) {
        srcPath.splice(i5, 1);
        up2--;
      }
    }
    if (!mustEndAbs && !removeAllDots) {
      for (; up2--; up2) {
        srcPath.unshift("..");
      }
    }
    if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
      srcPath.unshift("");
    }
    if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
      srcPath.push("");
    }
    var isAbsolute2 = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
    if (psychotic) {
      result.hostname = isAbsolute2 ? "" : srcPath.length ? srcPath.shift() : "";
      result.host = result.hostname;
      var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.hostname = authInHost.shift();
        result.host = result.hostname;
      }
    }
    mustEndAbs = mustEndAbs || result.host && srcPath.length;
    if (mustEndAbs && !isAbsolute2) {
      srcPath.unshift("");
    }
    if (srcPath.length > 0) {
      result.pathname = srcPath.join("/");
    } else {
      result.pathname = null;
      result.path = null;
    }
    if (result.pathname !== null || result.search !== null) {
      result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
    }
    result.auth = relative2.auth || result.auth;
    result.slashes = result.slashes || relative2.slashes;
    result.href = result.format();
    return result;
  };
  Url2.prototype.parseHost = function() {
    var host = this.host;
    var port = portPattern.exec(host);
    if (port) {
      port = port[0];
      if (port !== ":") {
        this.port = port.substr(1);
      }
      host = host.substr(0, host.length - port.length);
    }
    if (host) {
      this.hostname = host;
    }
  };
  exports$18.parse = urlParse;
  exports$18.resolve = urlResolve;
  exports$18.resolveObject = urlResolveObject;
  exports$18.format = urlFormat;
  exports$18.Url = Url2;
  return exports$18;
}
var exports10 = dew9();
exports10["parse"];
exports10["resolve"];
exports10["resolveObject"];
exports10["format"];
exports10["Url"];
var processPlatform2 = typeof Deno !== "undefined" ? Deno.build.os === "windows" ? "win32" : Deno.build.os : void 0;
exports10.URL = typeof URL !== "undefined" ? URL : null;
exports10.pathToFileURL = pathToFileURL2;
exports10.fileURLToPath = fileURLToPath2;
var Url = exports10.Url;
var format = exports10.format;
var resolve = exports10.resolve;
var resolveObject = exports10.resolveObject;
var parse = exports10.parse;
var _URL = exports10.URL;
var CHAR_BACKWARD_SLASH2 = 92;
var CHAR_FORWARD_SLASH2 = 47;
var CHAR_LOWERCASE_A2 = 97;
var CHAR_LOWERCASE_Z2 = 122;
var isWindows2 = processPlatform2 === "win32";
var forwardSlashRegEx2 = /\//g;
var percentRegEx2 = /%/g;
var backslashRegEx2 = /\\/g;
var newlineRegEx2 = /\n/g;
var carriageReturnRegEx2 = /\r/g;
var tabRegEx2 = /\t/g;
function fileURLToPath2(path2) {
  if (typeof path2 === "string") path2 = new URL(path2);
  else if (!(path2 instanceof URL)) {
    throw new Deno.errors.InvalidData(
      "invalid argument path , must be a string or URL"
    );
  }
  if (path2.protocol !== "file:") {
    throw new Deno.errors.InvalidData("invalid url scheme");
  }
  return isWindows2 ? getPathFromURLWin2(path2) : getPathFromURLPosix2(path2);
}
function getPathFromURLWin2(url) {
  const hostname = url.hostname;
  let pathname = url.pathname;
  for (let n6 = 0; n6 < pathname.length; n6++) {
    if (pathname[n6] === "%") {
      const third = pathname.codePointAt(n6 + 2) || 32;
      if (pathname[n6 + 1] === "2" && third === 102 || // 2f 2F /
      pathname[n6 + 1] === "5" && third === 99) {
        throw new Deno.errors.InvalidData(
          "must not include encoded \\ or / characters"
        );
      }
    }
  }
  pathname = pathname.replace(forwardSlashRegEx2, "\\");
  pathname = decodeURIComponent(pathname);
  if (hostname !== "") {
    return `\\\\${hostname}${pathname}`;
  } else {
    const letter = pathname.codePointAt(1) | 32;
    const sep2 = pathname[2];
    if (letter < CHAR_LOWERCASE_A2 || letter > CHAR_LOWERCASE_Z2 || // a..z A..Z
    sep2 !== ":") {
      throw new Deno.errors.InvalidData("file url path must be absolute");
    }
    return pathname.slice(1);
  }
}
function getPathFromURLPosix2(url) {
  if (url.hostname !== "") {
    throw new Deno.errors.InvalidData("invalid file url hostname");
  }
  const pathname = url.pathname;
  for (let n6 = 0; n6 < pathname.length; n6++) {
    if (pathname[n6] === "%") {
      const third = pathname.codePointAt(n6 + 2) || 32;
      if (pathname[n6 + 1] === "2" && third === 102) {
        throw new Deno.errors.InvalidData(
          "must not include encoded / characters"
        );
      }
    }
  }
  return decodeURIComponent(pathname);
}
function pathToFileURL2(filepath) {
  let resolved = exports9.resolve(filepath);
  const filePathLast = filepath.charCodeAt(filepath.length - 1);
  if ((filePathLast === CHAR_FORWARD_SLASH2 || isWindows2 && filePathLast === CHAR_BACKWARD_SLASH2) && resolved[resolved.length - 1] !== exports9.sep) {
    resolved += "/";
  }
  const outURL = new URL("file://");
  if (resolved.includes("%")) resolved = resolved.replace(percentRegEx2, "%25");
  if (!isWindows2 && resolved.includes("\\")) {
    resolved = resolved.replace(backslashRegEx2, "%5C");
  }
  if (resolved.includes("\n")) resolved = resolved.replace(newlineRegEx2, "%0A");
  if (resolved.includes("\r")) {
    resolved = resolved.replace(carriageReturnRegEx2, "%0D");
  }
  if (resolved.includes("	")) resolved = resolved.replace(tabRegEx2, "%09");
  outURL.pathname = resolved;
  return outURL;
}

// node_modules/@jspm/core/nodelibs/browser/fs.js
var exports$h2 = {};
var _dewExec$f3 = false;
function dew$f3() {
  if (_dewExec$f3) return exports$h2;
  _dewExec$f3 = true;
  Object.defineProperty(exports$h2, "__esModule", {
    value: true
  });
  exports$h2.constants = void 0;
  exports$h2.constants = {
    O_RDONLY: 0,
    O_WRONLY: 1,
    O_RDWR: 2,
    S_IFMT: 61440,
    S_IFREG: 32768,
    S_IFDIR: 16384,
    S_IFCHR: 8192,
    S_IFBLK: 24576,
    S_IFIFO: 4096,
    S_IFLNK: 40960,
    S_IFSOCK: 49152,
    O_CREAT: 64,
    O_EXCL: 128,
    O_NOCTTY: 256,
    O_TRUNC: 512,
    O_APPEND: 1024,
    O_DIRECTORY: 65536,
    O_NOATIME: 262144,
    O_NOFOLLOW: 131072,
    O_SYNC: 1052672,
    O_DIRECT: 16384,
    O_NONBLOCK: 2048,
    S_IRWXU: 448,
    S_IRUSR: 256,
    S_IWUSR: 128,
    S_IXUSR: 64,
    S_IRWXG: 56,
    S_IRGRP: 32,
    S_IWGRP: 16,
    S_IXGRP: 8,
    S_IRWXO: 7,
    S_IROTH: 4,
    S_IWOTH: 2,
    S_IXOTH: 1,
    F_OK: 0,
    R_OK: 4,
    W_OK: 2,
    X_OK: 1,
    UV_FS_SYMLINK_DIR: 1,
    UV_FS_SYMLINK_JUNCTION: 2,
    UV_FS_COPYFILE_EXCL: 1,
    UV_FS_COPYFILE_FICLONE: 2,
    UV_FS_COPYFILE_FICLONE_FORCE: 4,
    COPYFILE_EXCL: 1,
    COPYFILE_FICLONE: 2,
    COPYFILE_FICLONE_FORCE: 4
  };
  return exports$h2;
}
var exports$g3 = {};
var _dewExec$e3 = false;
function dew$e3() {
  if (_dewExec$e3) return exports$g3;
  _dewExec$e3 = true;
  if (typeof BigInt === "function") exports$g3.default = BigInt;
  else exports$g3.default = function BigIntNotSupported() {
    throw new Error("BigInt is not supported in this environment.");
  };
  return exports$g3;
}
var exports$f3 = {};
var _dewExec$d3 = false;
function dew$d3() {
  if (_dewExec$d3) return exports$f3;
  _dewExec$d3 = true;
  Object.defineProperty(exports$f3, "__esModule", {
    value: true
  });
  exports$f3.Stats = void 0;
  var constants_1 = dew$f3();
  var getBigInt_1 = dew$e3();
  var S_IFMT = constants_1.constants.S_IFMT, S_IFDIR = constants_1.constants.S_IFDIR, S_IFREG = constants_1.constants.S_IFREG, S_IFBLK = constants_1.constants.S_IFBLK, S_IFCHR = constants_1.constants.S_IFCHR, S_IFLNK = constants_1.constants.S_IFLNK, S_IFIFO = constants_1.constants.S_IFIFO, S_IFSOCK = constants_1.constants.S_IFSOCK;
  var Stats3 = (
    /** @class */
    function() {
      function Stats4() {
      }
      Stats4.build = function(node, bigint) {
        if (bigint === void 0) {
          bigint = false;
        }
        var stats = new Stats4();
        var uid = node.uid, gid = node.gid, atime = node.atime, mtime = node.mtime, ctime = node.ctime;
        var getStatNumber = !bigint ? function(number) {
          return number;
        } : getBigInt_1.default;
        stats.uid = getStatNumber(uid);
        stats.gid = getStatNumber(gid);
        stats.rdev = getStatNumber(0);
        stats.blksize = getStatNumber(4096);
        stats.ino = getStatNumber(node.ino);
        stats.size = getStatNumber(node.getSize());
        stats.blocks = getStatNumber(1);
        stats.atime = atime;
        stats.mtime = mtime;
        stats.ctime = ctime;
        stats.birthtime = ctime;
        stats.atimeMs = getStatNumber(atime.getTime());
        stats.mtimeMs = getStatNumber(mtime.getTime());
        var ctimeMs = getStatNumber(ctime.getTime());
        stats.ctimeMs = ctimeMs;
        stats.birthtimeMs = ctimeMs;
        stats.dev = getStatNumber(0);
        stats.mode = getStatNumber(node.mode);
        stats.nlink = getStatNumber(node.nlink);
        return stats;
      };
      Stats4.prototype._checkModeProperty = function(property) {
        return (Number(this.mode) & S_IFMT) === property;
      };
      Stats4.prototype.isDirectory = function() {
        return this._checkModeProperty(S_IFDIR);
      };
      Stats4.prototype.isFile = function() {
        return this._checkModeProperty(S_IFREG);
      };
      Stats4.prototype.isBlockDevice = function() {
        return this._checkModeProperty(S_IFBLK);
      };
      Stats4.prototype.isCharacterDevice = function() {
        return this._checkModeProperty(S_IFCHR);
      };
      Stats4.prototype.isSymbolicLink = function() {
        return this._checkModeProperty(S_IFLNK);
      };
      Stats4.prototype.isFIFO = function() {
        return this._checkModeProperty(S_IFIFO);
      };
      Stats4.prototype.isSocket = function() {
        return this._checkModeProperty(S_IFSOCK);
      };
      return Stats4;
    }()
  );
  exports$f3.Stats = Stats3;
  exports$f3.default = Stats3;
  return exports$f3;
}
var exports$e3 = {};
var _dewExec$c3 = false;
function dew$c3() {
  if (_dewExec$c3) return exports$e3;
  _dewExec$c3 = true;
  var __spreadArray = exports$e3 && exports$e3.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) for (var i5 = 0, l5 = from.length, ar; i5 < l5; i5++) {
      if (ar || !(i5 in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i5);
        ar[i5] = from[i5];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  Object.defineProperty(exports$e3, "__esModule", {
    value: true
  });
  exports$e3.bufferFrom = exports$e3.bufferAllocUnsafe = exports$e3.Buffer = void 0;
  var buffer_1 = dew();
  Object.defineProperty(exports$e3, "Buffer", {
    enumerable: true,
    get: function() {
      return buffer_1.Buffer;
    }
  });
  function bufferV0P12Ponyfill(arg0) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    return new (buffer_1.Buffer.bind.apply(buffer_1.Buffer, __spreadArray([void 0, arg0], args, false)))();
  }
  var bufferAllocUnsafe = buffer_1.Buffer.allocUnsafe || bufferV0P12Ponyfill;
  exports$e3.bufferAllocUnsafe = bufferAllocUnsafe;
  var bufferFrom = buffer_1.Buffer.from || bufferV0P12Ponyfill;
  exports$e3.bufferFrom = bufferFrom;
  return exports$e3;
}
var exports$d3 = {};
var _dewExec$b3 = false;
var _global$3 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
function dew$b3() {
  if (_dewExec$b3) return exports$d3;
  _dewExec$b3 = true;
  var __extends = exports$d3 && exports$d3.__extends || /* @__PURE__ */ function() {
    var extendStatics = function(d5, b6) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function(d6, b7) {
        d6.__proto__ = b7;
      } || function(d6, b7) {
        for (var p5 in b7) if (Object.prototype.hasOwnProperty.call(b7, p5)) d6[p5] = b7[p5];
      };
      return extendStatics(d5, b6);
    };
    return function(d5, b6) {
      if (typeof b6 !== "function" && b6 !== null) throw new TypeError("Class extends value " + String(b6) + " is not a constructor or null");
      extendStatics(d5, b6);
      function __() {
        this.constructor = d5;
      }
      d5.prototype = b6 === null ? Object.create(b6) : (__.prototype = b6.prototype, new __());
    };
  }();
  Object.defineProperty(exports$d3, "__esModule", {
    value: true
  });
  exports$d3.E = exports$d3.AssertionError = exports$d3.message = exports$d3.RangeError = exports$d3.TypeError = exports$d3.Error = void 0;
  var assert3 = et;
  var util = X;
  var kCode = typeof Symbol === "undefined" ? "_kCode" : Symbol("code");
  var messages = {};
  function makeNodeError(Base) {
    return (
      /** @class */
      function(_super) {
        __extends(NodeError, _super);
        function NodeError(key) {
          var args = [];
          for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
          }
          var _this = _super.call(this, message(key, args)) || this;
          _this.code = key;
          _this[kCode] = key;
          _this.name = "".concat(_super.prototype.name, " [").concat(_this[kCode], "]");
          return _this;
        }
        return NodeError;
      }(Base)
    );
  }
  var g5 = typeof globalThis !== "undefined" ? globalThis : _global$3;
  var AssertionError = (
    /** @class */
    function(_super) {
      __extends(AssertionError2, _super);
      function AssertionError2(options) {
        var _this = this;
        if (typeof options !== "object" || options === null) {
          throw new exports$d3.TypeError("ERR_INVALID_ARG_TYPE", "options", "object");
        }
        if (options.message) {
          _this = _super.call(this, options.message) || this;
        } else {
          _this = _super.call(this, "".concat(util.inspect(options.actual).slice(0, 128), " ") + "".concat(options.operator, " ").concat(util.inspect(options.expected).slice(0, 128))) || this;
        }
        _this.generatedMessage = !options.message;
        _this.name = "AssertionError [ERR_ASSERTION]";
        _this.code = "ERR_ASSERTION";
        _this.actual = options.actual;
        _this.expected = options.expected;
        _this.operator = options.operator;
        exports$d3.Error.captureStackTrace(_this, options.stackStartFunction);
        return _this;
      }
      return AssertionError2;
    }(g5.Error)
  );
  exports$d3.AssertionError = AssertionError;
  function message(key, args) {
    assert3.strictEqual(typeof key, "string");
    var msg = messages[key];
    assert3(msg, "An invalid error message key was used: ".concat(key, "."));
    var fmt;
    if (typeof msg === "function") {
      fmt = msg;
    } else {
      fmt = util.format;
      if (args === void 0 || args.length === 0) return msg;
      args.unshift(msg);
    }
    return String(fmt.apply(null, args));
  }
  exports$d3.message = message;
  function E4(sym, val) {
    messages[sym] = typeof val === "function" ? val : String(val);
  }
  exports$d3.E = E4;
  exports$d3.Error = makeNodeError(g5.Error);
  exports$d3.TypeError = makeNodeError(g5.TypeError);
  exports$d3.RangeError = makeNodeError(g5.RangeError);
  E4("ERR_ARG_NOT_ITERABLE", "%s must be iterable");
  E4("ERR_ASSERTION", "%s");
  E4("ERR_BUFFER_OUT_OF_BOUNDS", bufferOutOfBounds);
  E4("ERR_CHILD_CLOSED_BEFORE_REPLY", "Child closed before reply received");
  E4("ERR_CONSOLE_WRITABLE_STREAM", "Console expects a writable stream instance for %s");
  E4("ERR_CPU_USAGE", "Unable to obtain cpu usage %s");
  E4("ERR_DNS_SET_SERVERS_FAILED", function(err, servers) {
    return 'c-ares failed to set servers: "'.concat(err, '" [').concat(servers, "]");
  });
  E4("ERR_FALSY_VALUE_REJECTION", "Promise was rejected with falsy value");
  E4("ERR_ENCODING_NOT_SUPPORTED", function(enc) {
    return 'The "'.concat(enc, '" encoding is not supported');
  });
  E4("ERR_ENCODING_INVALID_ENCODED_DATA", function(enc) {
    return "The encoded data was not valid for encoding ".concat(enc);
  });
  E4("ERR_HTTP_HEADERS_SENT", "Cannot render headers after they are sent to the client");
  E4("ERR_HTTP_INVALID_STATUS_CODE", "Invalid status code: %s");
  E4("ERR_HTTP_TRAILER_INVALID", "Trailers are invalid with this transfer encoding");
  E4("ERR_INDEX_OUT_OF_RANGE", "Index out of range");
  E4("ERR_INVALID_ARG_TYPE", invalidArgType);
  E4("ERR_INVALID_ARRAY_LENGTH", function(name2, len, actual) {
    assert3.strictEqual(typeof actual, "number");
    return 'The array "'.concat(name2, '" (length ').concat(actual, ") must be of length ").concat(len, ".");
  });
  E4("ERR_INVALID_BUFFER_SIZE", "Buffer size must be a multiple of %s");
  E4("ERR_INVALID_CALLBACK", "Callback must be a function");
  E4("ERR_INVALID_CHAR", "Invalid character in %s");
  E4("ERR_INVALID_CURSOR_POS", "Cannot set cursor row without setting its column");
  E4("ERR_INVALID_FD", '"fd" must be a positive integer: %s');
  E4("ERR_INVALID_FILE_URL_HOST", 'File URL host must be "localhost" or empty on %s');
  E4("ERR_INVALID_FILE_URL_PATH", "File URL path %s");
  E4("ERR_INVALID_HANDLE_TYPE", "This handle type cannot be sent");
  E4("ERR_INVALID_IP_ADDRESS", "Invalid IP address: %s");
  E4("ERR_INVALID_OPT_VALUE", function(name2, value) {
    return 'The value "'.concat(String(value), '" is invalid for option "').concat(name2, '"');
  });
  E4("ERR_INVALID_OPT_VALUE_ENCODING", function(value) {
    return 'The value "'.concat(String(value), '" is invalid for option "encoding"');
  });
  E4("ERR_INVALID_REPL_EVAL_CONFIG", 'Cannot specify both "breakEvalOnSigint" and "eval" for REPL');
  E4("ERR_INVALID_SYNC_FORK_INPUT", "Asynchronous forks do not support Buffer, Uint8Array or string input: %s");
  E4("ERR_INVALID_THIS", 'Value of "this" must be of type %s');
  E4("ERR_INVALID_TUPLE", "%s must be an iterable %s tuple");
  E4("ERR_INVALID_URL", "Invalid URL: %s");
  E4("ERR_INVALID_URL_SCHEME", function(expected) {
    return "The URL must be ".concat(oneOf(expected, "scheme"));
  });
  E4("ERR_IPC_CHANNEL_CLOSED", "Channel closed");
  E4("ERR_IPC_DISCONNECTED", "IPC channel is already disconnected");
  E4("ERR_IPC_ONE_PIPE", "Child process can have only one IPC pipe");
  E4("ERR_IPC_SYNC_FORK", "IPC cannot be used with synchronous forks");
  E4("ERR_MISSING_ARGS", missingArgs);
  E4("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  E4("ERR_NAPI_CONS_FUNCTION", "Constructor must be a function");
  E4("ERR_NAPI_CONS_PROTOTYPE_OBJECT", "Constructor.prototype must be an object");
  E4("ERR_NO_CRYPTO", "Node.js is not compiled with OpenSSL crypto support");
  E4("ERR_NO_LONGER_SUPPORTED", "%s is no longer supported");
  E4("ERR_PARSE_HISTORY_DATA", "Could not parse history data in %s");
  E4("ERR_SOCKET_ALREADY_BOUND", "Socket is already bound");
  E4("ERR_SOCKET_BAD_PORT", "Port should be > 0 and < 65536");
  E4("ERR_SOCKET_BAD_TYPE", "Bad socket type specified. Valid types are: udp4, udp6");
  E4("ERR_SOCKET_CANNOT_SEND", "Unable to send data");
  E4("ERR_SOCKET_CLOSED", "Socket is closed");
  E4("ERR_SOCKET_DGRAM_NOT_RUNNING", "Not running");
  E4("ERR_STDERR_CLOSE", "process.stderr cannot be closed");
  E4("ERR_STDOUT_CLOSE", "process.stdout cannot be closed");
  E4("ERR_STREAM_WRAP", "Stream has StringDecoder set or is in objectMode");
  E4("ERR_TLS_CERT_ALTNAME_INVALID", "Hostname/IP does not match certificate's altnames: %s");
  E4("ERR_TLS_DH_PARAM_SIZE", function(size) {
    return "DH parameter size ".concat(size, " is less than 2048");
  });
  E4("ERR_TLS_HANDSHAKE_TIMEOUT", "TLS handshake timeout");
  E4("ERR_TLS_RENEGOTIATION_FAILED", "Failed to renegotiate");
  E4("ERR_TLS_REQUIRED_SERVER_NAME", '"servername" is required parameter for Server.addContext');
  E4("ERR_TLS_SESSION_ATTACK", "TSL session renegotiation attack detected");
  E4("ERR_TRANSFORM_ALREADY_TRANSFORMING", "Calling transform done when still transforming");
  E4("ERR_TRANSFORM_WITH_LENGTH_0", "Calling transform done when writableState.length != 0");
  E4("ERR_UNKNOWN_ENCODING", "Unknown encoding: %s");
  E4("ERR_UNKNOWN_SIGNAL", "Unknown signal: %s");
  E4("ERR_UNKNOWN_STDIN_TYPE", "Unknown stdin file type");
  E4("ERR_UNKNOWN_STREAM_TYPE", "Unknown stream file type");
  E4("ERR_V8BREAKITERATOR", "Full ICU data not installed. See https://github.com/nodejs/node/wiki/Intl");
  function invalidArgType(name2, expected, actual) {
    assert3(name2, "name is required");
    var determiner;
    if (expected.includes("not ")) {
      determiner = "must not be";
      expected = expected.split("not ")[1];
    } else {
      determiner = "must be";
    }
    var msg;
    if (Array.isArray(name2)) {
      var names2 = name2.map(function(val) {
        return '"'.concat(val, '"');
      }).join(", ");
      msg = "The ".concat(names2, " arguments ").concat(determiner, " ").concat(oneOf(expected, "type"));
    } else if (name2.includes(" argument")) {
      msg = "The ".concat(name2, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    } else {
      var type = name2.includes(".") ? "property" : "argument";
      msg = 'The "'.concat(name2, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    }
    if (arguments.length >= 3) {
      msg += ". Received type ".concat(actual !== null ? typeof actual : "null");
    }
    return msg;
  }
  function missingArgs() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    assert3(args.length > 0, "At least one arg needs to be specified");
    var msg = "The ";
    var len = args.length;
    args = args.map(function(a5) {
      return '"'.concat(a5, '"');
    });
    switch (len) {
      case 1:
        msg += "".concat(args[0], " argument");
        break;
      case 2:
        msg += "".concat(args[0], " and ").concat(args[1], " arguments");
        break;
      default:
        msg += args.slice(0, len - 1).join(", ");
        msg += ", and ".concat(args[len - 1], " arguments");
        break;
    }
    return "".concat(msg, " must be specified");
  }
  function oneOf(expected, thing) {
    assert3(expected, "expected is required");
    assert3(typeof thing === "string", "thing is required");
    if (Array.isArray(expected)) {
      var len = expected.length;
      assert3(len > 0, "At least one expected value needs to be specified");
      expected = expected.map(function(i5) {
        return String(i5);
      });
      if (len > 2) {
        return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
      } else if (len === 2) {
        return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
      } else {
        return "of ".concat(thing, " ").concat(expected[0]);
      }
    } else {
      return "of ".concat(thing, " ").concat(String(expected));
    }
  }
  function bufferOutOfBounds(name2, isWriting) {
    if (isWriting) {
      return "Attempt to write outside buffer bounds";
    } else {
      return '"'.concat(name2, '" is outside of buffer bounds');
    }
  }
  return exports$d3;
}
var exports$c3 = {};
var _dewExec$a3 = false;
function dew$a3() {
  if (_dewExec$a3) return exports$c3;
  _dewExec$a3 = true;
  Object.defineProperty(exports$c3, "__esModule", {
    value: true
  });
  exports$c3.strToEncoding = exports$c3.assertEncoding = exports$c3.ENCODING_UTF8 = void 0;
  var buffer_1 = dew$c3();
  var errors = dew$b3();
  exports$c3.ENCODING_UTF8 = "utf8";
  function assertEncoding(encoding) {
    if (encoding && !buffer_1.Buffer.isEncoding(encoding)) throw new errors.TypeError("ERR_INVALID_OPT_VALUE_ENCODING", encoding);
  }
  exports$c3.assertEncoding = assertEncoding;
  function strToEncoding(str, encoding) {
    if (!encoding || encoding === exports$c3.ENCODING_UTF8) return str;
    if (encoding === "buffer") return new buffer_1.Buffer(str);
    return new buffer_1.Buffer(str).toString(encoding);
  }
  exports$c3.strToEncoding = strToEncoding;
  return exports$c3;
}
var exports$b3 = {};
var _dewExec$93 = false;
function dew$93() {
  if (_dewExec$93) return exports$b3;
  _dewExec$93 = true;
  Object.defineProperty(exports$b3, "__esModule", {
    value: true
  });
  exports$b3.Dirent = void 0;
  var constants_1 = dew$f3();
  var encoding_1 = dew$a3();
  var S_IFMT = constants_1.constants.S_IFMT, S_IFDIR = constants_1.constants.S_IFDIR, S_IFREG = constants_1.constants.S_IFREG, S_IFBLK = constants_1.constants.S_IFBLK, S_IFCHR = constants_1.constants.S_IFCHR, S_IFLNK = constants_1.constants.S_IFLNK, S_IFIFO = constants_1.constants.S_IFIFO, S_IFSOCK = constants_1.constants.S_IFSOCK;
  var Dirent2 = (
    /** @class */
    function() {
      function Dirent3() {
        this.name = "";
        this.mode = 0;
      }
      Dirent3.build = function(link3, encoding) {
        var dirent = new Dirent3();
        var mode = link3.getNode().mode;
        dirent.name = (0, encoding_1.strToEncoding)(link3.getName(), encoding);
        dirent.mode = mode;
        return dirent;
      };
      Dirent3.prototype._checkModeProperty = function(property) {
        return (this.mode & S_IFMT) === property;
      };
      Dirent3.prototype.isDirectory = function() {
        return this._checkModeProperty(S_IFDIR);
      };
      Dirent3.prototype.isFile = function() {
        return this._checkModeProperty(S_IFREG);
      };
      Dirent3.prototype.isBlockDevice = function() {
        return this._checkModeProperty(S_IFBLK);
      };
      Dirent3.prototype.isCharacterDevice = function() {
        return this._checkModeProperty(S_IFCHR);
      };
      Dirent3.prototype.isSymbolicLink = function() {
        return this._checkModeProperty(S_IFLNK);
      };
      Dirent3.prototype.isFIFO = function() {
        return this._checkModeProperty(S_IFIFO);
      };
      Dirent3.prototype.isSocket = function() {
        return this._checkModeProperty(S_IFSOCK);
      };
      return Dirent3;
    }()
  );
  exports$b3.Dirent = Dirent2;
  exports$b3.default = Dirent2;
  return exports$b3;
}
exports$22._makeLong;
exports$22.basename;
exports$22.delimiter;
exports$22.dirname;
exports$22.extname;
exports$22.format;
exports$22.isAbsolute;
exports$22.join;
exports$22.normalize;
exports$22.parse;
exports$22.posix;
exports$22.relative;
exports$22.resolve;
exports$22.sep;
exports$22.win32;
var exports$a3 = {};
var _dewExec$83 = false;
var _global$22 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
function dew$83() {
  if (_dewExec$83) return exports$a3;
  _dewExec$83 = true;
  var process$1 = process3;
  Object.defineProperty(exports$a3, "__esModule", {
    value: true
  });
  var _setImmediate;
  if (typeof process$1.nextTick === "function") _setImmediate = process$1.nextTick.bind(typeof globalThis !== "undefined" ? globalThis : _global$22);
  else _setImmediate = setTimeout.bind(typeof globalThis !== "undefined" ? globalThis : _global$22);
  exports$a3.default = _setImmediate;
  return exports$a3;
}
var exports$93 = {};
var _dewExec$74 = false;
function dew$74() {
  if (_dewExec$74) return exports$93;
  _dewExec$74 = true;
  var process$1 = process3;
  Object.defineProperty(exports$93, "__esModule", {
    value: true
  });
  exports$93.createProcess = void 0;
  var maybeReturnProcess = function() {
    if (typeof process$1 !== "undefined") {
      return process$1;
    }
    try {
      return process3;
    } catch (_a) {
      return void 0;
    }
  };
  function createProcess() {
    var p5 = maybeReturnProcess() || {};
    if (!p5.cwd) p5.cwd = function() {
      return "/";
    };
    if (!p5.nextTick) p5.nextTick = dew$83().default;
    if (!p5.emitWarning) p5.emitWarning = function(message, type) {
      console.warn("".concat(type).concat(type ? ": " : "").concat(message));
    };
    if (!p5.env) p5.env = {};
    return p5;
  }
  exports$93.createProcess = createProcess;
  exports$93.default = createProcess();
  return exports$93;
}
var exports$84 = {};
var _dewExec$64 = false;
function dew$64() {
  if (_dewExec$64) return exports$84;
  _dewExec$64 = true;
  var __extends = exports$84 && exports$84.__extends || /* @__PURE__ */ function() {
    var extendStatics = function(d5, b6) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function(d6, b7) {
        d6.__proto__ = b7;
      } || function(d6, b7) {
        for (var p5 in b7) if (Object.prototype.hasOwnProperty.call(b7, p5)) d6[p5] = b7[p5];
      };
      return extendStatics(d5, b6);
    };
    return function(d5, b6) {
      if (typeof b6 !== "function" && b6 !== null) throw new TypeError("Class extends value " + String(b6) + " is not a constructor or null");
      extendStatics(d5, b6);
      function __() {
        this.constructor = d5;
      }
      d5.prototype = b6 === null ? Object.create(b6) : (__.prototype = b6.prototype, new __());
    };
  }();
  Object.defineProperty(exports$84, "__esModule", {
    value: true
  });
  exports$84.File = exports$84.Link = exports$84.Node = exports$84.SEP = void 0;
  var process_1 = dew$74();
  var buffer_1 = dew$c3();
  var constants_1 = dew$f3();
  var events_1 = y5;
  var Stats_1 = dew$d3();
  var S_IFMT = constants_1.constants.S_IFMT, S_IFDIR = constants_1.constants.S_IFDIR, S_IFREG = constants_1.constants.S_IFREG, S_IFLNK = constants_1.constants.S_IFLNK, O_APPEND = constants_1.constants.O_APPEND;
  var getuid = function() {
    var _a, _b;
    return (_b = (_a = process_1.default.getuid) === null || _a === void 0 ? void 0 : _a.call(process_1.default)) !== null && _b !== void 0 ? _b : 0;
  };
  var getgid = function() {
    var _a, _b;
    return (_b = (_a = process_1.default.getgid) === null || _a === void 0 ? void 0 : _a.call(process_1.default)) !== null && _b !== void 0 ? _b : 0;
  };
  exports$84.SEP = "/";
  var Node2 = (
    /** @class */
    function(_super) {
      __extends(Node3, _super);
      function Node3(ino, perm) {
        if (perm === void 0) {
          perm = 438;
        }
        var _this = _super.call(this) || this;
        _this._uid = getuid();
        _this._gid = getgid();
        _this._atime = /* @__PURE__ */ new Date();
        _this._mtime = /* @__PURE__ */ new Date();
        _this._ctime = /* @__PURE__ */ new Date();
        _this._perm = 438;
        _this.mode = S_IFREG;
        _this._nlink = 1;
        _this._perm = perm;
        _this.mode |= perm;
        _this.ino = ino;
        return _this;
      }
      Object.defineProperty(Node3.prototype, "ctime", {
        get: function() {
          return this._ctime;
        },
        set: function(ctime) {
          this._ctime = ctime;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Node3.prototype, "uid", {
        get: function() {
          return this._uid;
        },
        set: function(uid) {
          this._uid = uid;
          this.ctime = /* @__PURE__ */ new Date();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Node3.prototype, "gid", {
        get: function() {
          return this._gid;
        },
        set: function(gid) {
          this._gid = gid;
          this.ctime = /* @__PURE__ */ new Date();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Node3.prototype, "atime", {
        get: function() {
          return this._atime;
        },
        set: function(atime) {
          this._atime = atime;
          this.ctime = /* @__PURE__ */ new Date();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Node3.prototype, "mtime", {
        get: function() {
          return this._mtime;
        },
        set: function(mtime) {
          this._mtime = mtime;
          this.ctime = /* @__PURE__ */ new Date();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Node3.prototype, "perm", {
        get: function() {
          return this._perm;
        },
        set: function(perm) {
          this._perm = perm;
          this.ctime = /* @__PURE__ */ new Date();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Node3.prototype, "nlink", {
        get: function() {
          return this._nlink;
        },
        set: function(nlink) {
          this._nlink = nlink;
          this.ctime = /* @__PURE__ */ new Date();
        },
        enumerable: false,
        configurable: true
      });
      Node3.prototype.getString = function(encoding) {
        if (encoding === void 0) {
          encoding = "utf8";
        }
        this.atime = /* @__PURE__ */ new Date();
        return this.getBuffer().toString(encoding);
      };
      Node3.prototype.setString = function(str) {
        this.buf = (0, buffer_1.bufferFrom)(str, "utf8");
        this.touch();
      };
      Node3.prototype.getBuffer = function() {
        this.atime = /* @__PURE__ */ new Date();
        if (!this.buf) this.setBuffer((0, buffer_1.bufferAllocUnsafe)(0));
        return (0, buffer_1.bufferFrom)(this.buf);
      };
      Node3.prototype.setBuffer = function(buf) {
        this.buf = (0, buffer_1.bufferFrom)(buf);
        this.touch();
      };
      Node3.prototype.getSize = function() {
        return this.buf ? this.buf.length : 0;
      };
      Node3.prototype.setModeProperty = function(property) {
        this.mode = this.mode & ~S_IFMT | property;
      };
      Node3.prototype.setIsFile = function() {
        this.setModeProperty(S_IFREG);
      };
      Node3.prototype.setIsDirectory = function() {
        this.setModeProperty(S_IFDIR);
      };
      Node3.prototype.setIsSymlink = function() {
        this.setModeProperty(S_IFLNK);
      };
      Node3.prototype.isFile = function() {
        return (this.mode & S_IFMT) === S_IFREG;
      };
      Node3.prototype.isDirectory = function() {
        return (this.mode & S_IFMT) === S_IFDIR;
      };
      Node3.prototype.isSymlink = function() {
        return (this.mode & S_IFMT) === S_IFLNK;
      };
      Node3.prototype.makeSymlink = function(steps) {
        this.symlink = steps;
        this.setIsSymlink();
      };
      Node3.prototype.write = function(buf, off3, len, pos) {
        if (off3 === void 0) {
          off3 = 0;
        }
        if (len === void 0) {
          len = buf.length;
        }
        if (pos === void 0) {
          pos = 0;
        }
        if (!this.buf) this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
        if (pos + len > this.buf.length) {
          var newBuf = (0, buffer_1.bufferAllocUnsafe)(pos + len);
          this.buf.copy(newBuf, 0, 0, this.buf.length);
          this.buf = newBuf;
        }
        buf.copy(this.buf, pos, off3, off3 + len);
        this.touch();
        return len;
      };
      Node3.prototype.read = function(buf, off3, len, pos) {
        if (off3 === void 0) {
          off3 = 0;
        }
        if (len === void 0) {
          len = buf.byteLength;
        }
        if (pos === void 0) {
          pos = 0;
        }
        this.atime = /* @__PURE__ */ new Date();
        if (!this.buf) this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
        var actualLen = len;
        if (actualLen > buf.byteLength) {
          actualLen = buf.byteLength;
        }
        if (actualLen + pos > this.buf.length) {
          actualLen = this.buf.length - pos;
        }
        this.buf.copy(buf, off3, pos, pos + actualLen);
        return actualLen;
      };
      Node3.prototype.truncate = function(len) {
        if (len === void 0) {
          len = 0;
        }
        if (!len) this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
        else {
          if (!this.buf) this.buf = (0, buffer_1.bufferAllocUnsafe)(0);
          if (len <= this.buf.length) {
            this.buf = this.buf.slice(0, len);
          } else {
            var buf = (0, buffer_1.bufferAllocUnsafe)(len);
            this.buf.copy(buf);
            buf.fill(0, this.buf.length);
            this.buf = buf;
          }
        }
        this.touch();
      };
      Node3.prototype.chmod = function(perm) {
        this.perm = perm;
        this.mode = this.mode & ~511 | perm;
        this.touch();
      };
      Node3.prototype.chown = function(uid, gid) {
        this.uid = uid;
        this.gid = gid;
        this.touch();
      };
      Node3.prototype.touch = function() {
        this.mtime = /* @__PURE__ */ new Date();
        this.emit("change", this);
      };
      Node3.prototype.canRead = function(uid, gid) {
        if (uid === void 0) {
          uid = getuid();
        }
        if (gid === void 0) {
          gid = getgid();
        }
        if (this.perm & 4) {
          return true;
        }
        if (gid === this.gid) {
          if (this.perm & 32) {
            return true;
          }
        }
        if (uid === this.uid) {
          if (this.perm & 256) {
            return true;
          }
        }
        return false;
      };
      Node3.prototype.canWrite = function(uid, gid) {
        if (uid === void 0) {
          uid = getuid();
        }
        if (gid === void 0) {
          gid = getgid();
        }
        if (this.perm & 2) {
          return true;
        }
        if (gid === this.gid) {
          if (this.perm & 16) {
            return true;
          }
        }
        if (uid === this.uid) {
          if (this.perm & 128) {
            return true;
          }
        }
        return false;
      };
      Node3.prototype.del = function() {
        this.emit("delete", this);
      };
      Node3.prototype.toJSON = function() {
        return {
          ino: this.ino,
          uid: this.uid,
          gid: this.gid,
          atime: this.atime.getTime(),
          mtime: this.mtime.getTime(),
          ctime: this.ctime.getTime(),
          perm: this.perm,
          mode: this.mode,
          nlink: this.nlink,
          symlink: this.symlink,
          data: this.getString()
        };
      };
      return Node3;
    }(events_1.EventEmitter)
  );
  exports$84.Node = Node2;
  var Link = (
    /** @class */
    function(_super) {
      __extends(Link2, _super);
      function Link2(vol2, parent, name2) {
        var _this = _super.call(this) || this;
        _this.children = {};
        _this._steps = [];
        _this.ino = 0;
        _this.length = 0;
        _this.vol = vol2;
        _this.parent = parent;
        _this.name = name2;
        _this.syncSteps();
        return _this;
      }
      Object.defineProperty(Link2.prototype, "steps", {
        get: function() {
          return this._steps;
        },
        // Recursively sync children steps, e.g. in case of dir rename
        set: function(val) {
          this._steps = val;
          for (var _i = 0, _a = Object.entries(this.children); _i < _a.length; _i++) {
            var _b = _a[_i], child = _b[0], link3 = _b[1];
            if (child === "." || child === "..") {
              continue;
            }
            link3 === null || link3 === void 0 ? void 0 : link3.syncSteps();
          }
        },
        enumerable: false,
        configurable: true
      });
      Link2.prototype.setNode = function(node) {
        this.node = node;
        this.ino = node.ino;
      };
      Link2.prototype.getNode = function() {
        return this.node;
      };
      Link2.prototype.createChild = function(name2, node) {
        if (node === void 0) {
          node = this.vol.createNode();
        }
        var link3 = new Link2(this.vol, this, name2);
        link3.setNode(node);
        if (node.isDirectory()) {
          link3.children["."] = link3;
          link3.getNode().nlink++;
        }
        this.setChild(name2, link3);
        return link3;
      };
      Link2.prototype.setChild = function(name2, link3) {
        if (link3 === void 0) {
          link3 = new Link2(this.vol, this, name2);
        }
        this.children[name2] = link3;
        link3.parent = this;
        this.length++;
        var node = link3.getNode();
        if (node.isDirectory()) {
          link3.children[".."] = this;
          this.getNode().nlink++;
        }
        this.getNode().mtime = /* @__PURE__ */ new Date();
        this.emit("child:add", link3, this);
        return link3;
      };
      Link2.prototype.deleteChild = function(link3) {
        var node = link3.getNode();
        if (node.isDirectory()) {
          delete link3.children[".."];
          this.getNode().nlink--;
        }
        delete this.children[link3.getName()];
        this.length--;
        this.getNode().mtime = /* @__PURE__ */ new Date();
        this.emit("child:delete", link3, this);
      };
      Link2.prototype.getChild = function(name2) {
        this.getNode().mtime = /* @__PURE__ */ new Date();
        if (Object.hasOwnProperty.call(this.children, name2)) {
          return this.children[name2];
        }
      };
      Link2.prototype.getPath = function() {
        return this.steps.join(exports$84.SEP);
      };
      Link2.prototype.getName = function() {
        return this.steps[this.steps.length - 1];
      };
      Link2.prototype.walk = function(steps, stop, i5) {
        if (stop === void 0) {
          stop = steps.length;
        }
        if (i5 === void 0) {
          i5 = 0;
        }
        if (i5 >= steps.length) return this;
        if (i5 >= stop) return this;
        var step = steps[i5];
        var link3 = this.getChild(step);
        if (!link3) return null;
        return link3.walk(steps, stop, i5 + 1);
      };
      Link2.prototype.toJSON = function() {
        return {
          steps: this.steps,
          ino: this.ino,
          children: Object.keys(this.children)
        };
      };
      Link2.prototype.syncSteps = function() {
        this.steps = this.parent ? this.parent.steps.concat([this.name]) : [this.name];
      };
      return Link2;
    }(events_1.EventEmitter)
  );
  exports$84.Link = Link;
  var File2 = (
    /** @class */
    function() {
      function File3(link3, node, flags, fd) {
        this.position = 0;
        this.link = link3;
        this.node = node;
        this.flags = flags;
        this.fd = fd;
      }
      File3.prototype.getString = function(encoding) {
        return this.node.getString();
      };
      File3.prototype.setString = function(str) {
        this.node.setString(str);
      };
      File3.prototype.getBuffer = function() {
        return this.node.getBuffer();
      };
      File3.prototype.setBuffer = function(buf) {
        this.node.setBuffer(buf);
      };
      File3.prototype.getSize = function() {
        return this.node.getSize();
      };
      File3.prototype.truncate = function(len) {
        this.node.truncate(len);
      };
      File3.prototype.seekTo = function(position) {
        this.position = position;
      };
      File3.prototype.stats = function() {
        return Stats_1.default.build(this.node);
      };
      File3.prototype.write = function(buf, offset, length, position) {
        if (offset === void 0) {
          offset = 0;
        }
        if (length === void 0) {
          length = buf.length;
        }
        if (typeof position !== "number") position = this.position;
        if (this.flags & O_APPEND) position = this.getSize();
        var bytes = this.node.write(buf, offset, length, position);
        this.position = position + bytes;
        return bytes;
      };
      File3.prototype.read = function(buf, offset, length, position) {
        if (offset === void 0) {
          offset = 0;
        }
        if (length === void 0) {
          length = buf.byteLength;
        }
        if (typeof position !== "number") position = this.position;
        var bytes = this.node.read(buf, offset, length, position);
        this.position = position + bytes;
        return bytes;
      };
      File3.prototype.chmod = function(perm) {
        this.node.chmod(perm);
      };
      File3.prototype.chown = function(uid, gid) {
        this.node.chown(uid, gid);
      };
      return File3;
    }()
  );
  exports$84.File = File2;
  return exports$84;
}
var exports$74 = {};
var _dewExec$54 = false;
var _global$12 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
function dew$54() {
  if (_dewExec$54) return exports$74;
  _dewExec$54 = true;
  Object.defineProperty(exports$74, "__esModule", {
    value: true
  });
  function setTimeoutUnref(callback, time, args) {
    var ref = setTimeout.apply(typeof globalThis !== "undefined" ? globalThis : _global$12, arguments);
    if (ref && typeof ref === "object" && typeof ref.unref === "function") ref.unref();
    return ref;
  }
  exports$74.default = setTimeoutUnref;
  return exports$74;
}
var exports$64 = {};
var _dewExec$44 = false;
function dew$44() {
  if (_dewExec$44) return exports$64;
  _dewExec$44 = true;
  var __spreadArray = exports$64 && exports$64.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) for (var i5 = 0, l5 = from.length, ar; i5 < l5; i5++) {
      if (ar || !(i5 in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i5);
        ar[i5] = from[i5];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  Object.defineProperty(exports$64, "__esModule", {
    value: true
  });
  exports$64.FileHandle = void 0;
  function promisify3(vol2, fn, getResult) {
    if (getResult === void 0) {
      getResult = function(input) {
        return input;
      };
    }
    return function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return new Promise(function(resolve3, reject) {
        vol2[fn].bind(vol2).apply(void 0, __spreadArray(__spreadArray([], args, false), [function(error, result) {
          if (error) return reject(error);
          return resolve3(getResult(result));
        }], false));
      });
    };
  }
  var FileHandle = (
    /** @class */
    function() {
      function FileHandle2(vol2, fd) {
        this.vol = vol2;
        this.fd = fd;
      }
      FileHandle2.prototype.appendFile = function(data, options) {
        return promisify3(this.vol, "appendFile")(this.fd, data, options);
      };
      FileHandle2.prototype.chmod = function(mode) {
        return promisify3(this.vol, "fchmod")(this.fd, mode);
      };
      FileHandle2.prototype.chown = function(uid, gid) {
        return promisify3(this.vol, "fchown")(this.fd, uid, gid);
      };
      FileHandle2.prototype.close = function() {
        return promisify3(this.vol, "close")(this.fd);
      };
      FileHandle2.prototype.datasync = function() {
        return promisify3(this.vol, "fdatasync")(this.fd);
      };
      FileHandle2.prototype.read = function(buffer2, offset, length, position) {
        return promisify3(this.vol, "read", function(bytesRead) {
          return {
            bytesRead,
            buffer: buffer2
          };
        })(this.fd, buffer2, offset, length, position);
      };
      FileHandle2.prototype.readFile = function(options) {
        return promisify3(this.vol, "readFile")(this.fd, options);
      };
      FileHandle2.prototype.stat = function(options) {
        return promisify3(this.vol, "fstat")(this.fd, options);
      };
      FileHandle2.prototype.sync = function() {
        return promisify3(this.vol, "fsync")(this.fd);
      };
      FileHandle2.prototype.truncate = function(len) {
        return promisify3(this.vol, "ftruncate")(this.fd, len);
      };
      FileHandle2.prototype.utimes = function(atime, mtime) {
        return promisify3(this.vol, "futimes")(this.fd, atime, mtime);
      };
      FileHandle2.prototype.write = function(buffer2, offset, length, position) {
        return promisify3(this.vol, "write", function(bytesWritten) {
          return {
            bytesWritten,
            buffer: buffer2
          };
        })(this.fd, buffer2, offset, length, position);
      };
      FileHandle2.prototype.writeFile = function(data, options) {
        return promisify3(this.vol, "writeFile")(this.fd, data, options);
      };
      return FileHandle2;
    }()
  );
  exports$64.FileHandle = FileHandle;
  function createPromisesApi(vol2) {
    if (typeof Promise === "undefined") return null;
    return {
      FileHandle,
      access: function(path2, mode) {
        return promisify3(vol2, "access")(path2, mode);
      },
      appendFile: function(path2, data, options) {
        return promisify3(vol2, "appendFile")(path2 instanceof FileHandle ? path2.fd : path2, data, options);
      },
      chmod: function(path2, mode) {
        return promisify3(vol2, "chmod")(path2, mode);
      },
      chown: function(path2, uid, gid) {
        return promisify3(vol2, "chown")(path2, uid, gid);
      },
      copyFile: function(src, dest, flags) {
        return promisify3(vol2, "copyFile")(src, dest, flags);
      },
      lchmod: function(path2, mode) {
        return promisify3(vol2, "lchmod")(path2, mode);
      },
      lchown: function(path2, uid, gid) {
        return promisify3(vol2, "lchown")(path2, uid, gid);
      },
      link: function(existingPath, newPath) {
        return promisify3(vol2, "link")(existingPath, newPath);
      },
      lstat: function(path2, options) {
        return promisify3(vol2, "lstat")(path2, options);
      },
      mkdir: function(path2, options) {
        return promisify3(vol2, "mkdir")(path2, options);
      },
      mkdtemp: function(prefix, options) {
        return promisify3(vol2, "mkdtemp")(prefix, options);
      },
      open: function(path2, flags, mode) {
        return promisify3(vol2, "open", function(fd) {
          return new FileHandle(vol2, fd);
        })(path2, flags, mode);
      },
      readdir: function(path2, options) {
        return promisify3(vol2, "readdir")(path2, options);
      },
      readFile: function(id, options) {
        return promisify3(vol2, "readFile")(id instanceof FileHandle ? id.fd : id, options);
      },
      readlink: function(path2, options) {
        return promisify3(vol2, "readlink")(path2, options);
      },
      realpath: function(path2, options) {
        return promisify3(vol2, "realpath")(path2, options);
      },
      rename: function(oldPath, newPath) {
        return promisify3(vol2, "rename")(oldPath, newPath);
      },
      rmdir: function(path2) {
        return promisify3(vol2, "rmdir")(path2);
      },
      rm: function(path2, options) {
        return promisify3(vol2, "rm")(path2, options);
      },
      stat: function(path2, options) {
        return promisify3(vol2, "stat")(path2, options);
      },
      symlink: function(target, path2, type) {
        return promisify3(vol2, "symlink")(target, path2, type);
      },
      truncate: function(path2, len) {
        return promisify3(vol2, "truncate")(path2, len);
      },
      unlink: function(path2) {
        return promisify3(vol2, "unlink")(path2);
      },
      utimes: function(path2, atime, mtime) {
        return promisify3(vol2, "utimes")(path2, atime, mtime);
      },
      writeFile: function(id, data, options) {
        return promisify3(vol2, "writeFile")(id instanceof FileHandle ? id.fd : id, data, options);
      }
    };
  }
  exports$64.default = createPromisesApi;
  return exports$64;
}
var exports$54 = {};
var _dewExec$34 = false;
function dew$34() {
  if (_dewExec$34) return exports$54;
  _dewExec$34 = true;
  var process$1 = process3;
  Object.defineProperty(exports$54, "__esModule", {
    value: true
  });
  exports$54.correctPath = correctPath;
  exports$54.unixify = unixify;
  var isWin = process$1.platform === "win32";
  function removeTrailingSeparator(str) {
    var i5 = str.length - 1;
    if (i5 < 2) {
      return str;
    }
    while (isSeparator(str, i5)) {
      i5--;
    }
    return str.substr(0, i5 + 1);
  }
  function isSeparator(str, i5) {
    var _char = str[i5];
    return i5 > 0 && (_char === "/" || isWin && _char === "\\");
  }
  function normalizePath(str, stripTrailing) {
    if (typeof str !== "string") {
      throw new TypeError("expected a string");
    }
    str = str.replace(/[\\\/]+/g, "/");
    if (stripTrailing !== false) {
      str = removeTrailingSeparator(str);
    }
    return str;
  }
  function unixify(filepath) {
    var stripTrailing = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    if (isWin) {
      filepath = normalizePath(filepath, stripTrailing);
      return filepath.replace(/^([a-zA-Z]+:|\.\/)/, "");
    }
    return filepath;
  }
  function correctPath(filepath) {
    return unixify(filepath.replace(/^\\\\\?\\.:\\/, "\\"));
  }
  return exports$54;
}
var exports$44 = {};
var _dewExec$25 = false;
var _global5 = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : global;
function dew$25() {
  if (_dewExec$25) return exports$44;
  _dewExec$25 = true;
  var __extends = exports$44 && exports$44.__extends || /* @__PURE__ */ function() {
    var extendStatics = function(d5, b6) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function(d6, b7) {
        d6.__proto__ = b7;
      } || function(d6, b7) {
        for (var p5 in b7) if (Object.prototype.hasOwnProperty.call(b7, p5)) d6[p5] = b7[p5];
      };
      return extendStatics(d5, b6);
    };
    return function(d5, b6) {
      if (typeof b6 !== "function" && b6 !== null) throw new TypeError("Class extends value " + String(b6) + " is not a constructor or null");
      extendStatics(d5, b6);
      function __() {
        this.constructor = d5;
      }
      d5.prototype = b6 === null ? Object.create(b6) : (__.prototype = b6.prototype, new __());
    };
  }();
  var __spreadArray = exports$44 && exports$44.__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) for (var i5 = 0, l5 = from.length, ar; i5 < l5; i5++) {
      if (ar || !(i5 in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i5);
        ar[i5] = from[i5];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  Object.defineProperty(exports$44, "__esModule", {
    value: true
  });
  exports$44.FSWatcher = exports$44.StatWatcher = exports$44.Volume = exports$44.toUnixTimestamp = exports$44.bufferToEncoding = exports$44.dataToBuffer = exports$44.dataToStr = exports$44.pathToSteps = exports$44.filenameToSteps = exports$44.pathToFilename = exports$44.flagsToNumber = exports$44.FLAGS = void 0;
  var pathModule = exports$22;
  var node_1 = dew$64();
  var Stats_1 = dew$d3();
  var Dirent_1 = dew$93();
  var buffer_1 = dew$c3();
  var setImmediate_1 = dew$83();
  var process_1 = dew$74();
  var setTimeoutUnref_1 = dew$54();
  var stream_1 = exports6;
  var constants_1 = dew$f3();
  var events_1 = y5;
  var encoding_1 = dew$a3();
  var errors = dew$b3();
  var util = X;
  var promises_1 = dew$44();
  var resolveCrossPlatform = pathModule.resolve;
  var O_RDONLY = constants_1.constants.O_RDONLY, O_WRONLY = constants_1.constants.O_WRONLY, O_RDWR = constants_1.constants.O_RDWR, O_CREAT = constants_1.constants.O_CREAT, O_EXCL = constants_1.constants.O_EXCL, O_TRUNC = constants_1.constants.O_TRUNC, O_APPEND = constants_1.constants.O_APPEND, O_SYNC = constants_1.constants.O_SYNC, O_DIRECTORY = constants_1.constants.O_DIRECTORY, F_OK2 = constants_1.constants.F_OK, COPYFILE_EXCL = constants_1.constants.COPYFILE_EXCL, COPYFILE_FICLONE_FORCE = constants_1.constants.COPYFILE_FICLONE_FORCE;
  var _a = pathModule.posix ? pathModule.posix : pathModule, sep2 = _a.sep, relative2 = _a.relative, join2 = _a.join, dirname2 = _a.dirname;
  var isWin = process_1.default.platform === "win32";
  var kMinPoolSpace = 128;
  var ERRSTR = {
    PATH_STR: "path must be a string or Buffer",
    // FD:             'file descriptor must be a unsigned 32-bit integer',
    FD: "fd must be a file descriptor",
    MODE_INT: "mode must be an int",
    CB: "callback must be a function",
    UID: "uid must be an unsigned int",
    GID: "gid must be an unsigned int",
    LEN: "len must be an integer",
    ATIME: "atime must be an integer",
    MTIME: "mtime must be an integer",
    PREFIX: "filename prefix is required",
    BUFFER: "buffer must be an instance of Buffer or StaticBuffer",
    OFFSET: "offset must be an integer",
    LENGTH: "length must be an integer",
    POSITION: "position must be an integer"
  };
  var ERRSTR_OPTS = function(tipeof) {
    return "Expected options to be either an object or a string, but got ".concat(tipeof, " instead");
  };
  var ENOENT = "ENOENT";
  var EBADF = "EBADF";
  var EINVAL = "EINVAL";
  var EPERM = "EPERM";
  var EPROTO = "EPROTO";
  var EEXIST = "EEXIST";
  var ENOTDIR = "ENOTDIR";
  var EMFILE = "EMFILE";
  var EACCES = "EACCES";
  var EISDIR = "EISDIR";
  var ENOTEMPTY = "ENOTEMPTY";
  var ENOSYS = "ENOSYS";
  var ERR_FS_EISDIR = "ERR_FS_EISDIR";
  function formatError(errorCode, func, path2, path22) {
    if (func === void 0) {
      func = "";
    }
    if (path2 === void 0) {
      path2 = "";
    }
    if (path22 === void 0) {
      path22 = "";
    }
    var pathFormatted = "";
    if (path2) pathFormatted = " '".concat(path2, "'");
    if (path22) pathFormatted += " -> '".concat(path22, "'");
    switch (errorCode) {
      case ENOENT:
        return "ENOENT: no such file or directory, ".concat(func).concat(pathFormatted);
      case EBADF:
        return "EBADF: bad file descriptor, ".concat(func).concat(pathFormatted);
      case EINVAL:
        return "EINVAL: invalid argument, ".concat(func).concat(pathFormatted);
      case EPERM:
        return "EPERM: operation not permitted, ".concat(func).concat(pathFormatted);
      case EPROTO:
        return "EPROTO: protocol error, ".concat(func).concat(pathFormatted);
      case EEXIST:
        return "EEXIST: file already exists, ".concat(func).concat(pathFormatted);
      case ENOTDIR:
        return "ENOTDIR: not a directory, ".concat(func).concat(pathFormatted);
      case EISDIR:
        return "EISDIR: illegal operation on a directory, ".concat(func).concat(pathFormatted);
      case EACCES:
        return "EACCES: permission denied, ".concat(func).concat(pathFormatted);
      case ENOTEMPTY:
        return "ENOTEMPTY: directory not empty, ".concat(func).concat(pathFormatted);
      case EMFILE:
        return "EMFILE: too many open files, ".concat(func).concat(pathFormatted);
      case ENOSYS:
        return "ENOSYS: function not implemented, ".concat(func).concat(pathFormatted);
      case ERR_FS_EISDIR:
        return "[ERR_FS_EISDIR]: Path is a directory: ".concat(func, " returned EISDIR (is a directory) ").concat(path2);
      default:
        return "".concat(errorCode, ": error occurred, ").concat(func).concat(pathFormatted);
    }
  }
  function createError(errorCode, func, path2, path22, Constructor) {
    if (func === void 0) {
      func = "";
    }
    if (path2 === void 0) {
      path2 = "";
    }
    if (path22 === void 0) {
      path22 = "";
    }
    if (Constructor === void 0) {
      Constructor = Error;
    }
    var error = new Constructor(formatError(errorCode, func, path2, path22));
    error.code = errorCode;
    if (path2) {
      error.path = path2;
    }
    return error;
  }
  var FLAGS;
  (function(FLAGS2) {
    FLAGS2[FLAGS2["r"] = O_RDONLY] = "r";
    FLAGS2[FLAGS2["r+"] = O_RDWR] = "r+";
    FLAGS2[FLAGS2["rs"] = O_RDONLY | O_SYNC] = "rs";
    FLAGS2[FLAGS2["sr"] = FLAGS2.rs] = "sr";
    FLAGS2[FLAGS2["rs+"] = O_RDWR | O_SYNC] = "rs+";
    FLAGS2[FLAGS2["sr+"] = FLAGS2["rs+"]] = "sr+";
    FLAGS2[FLAGS2["w"] = O_WRONLY | O_CREAT | O_TRUNC] = "w";
    FLAGS2[FLAGS2["wx"] = O_WRONLY | O_CREAT | O_TRUNC | O_EXCL] = "wx";
    FLAGS2[FLAGS2["xw"] = FLAGS2.wx] = "xw";
    FLAGS2[FLAGS2["w+"] = O_RDWR | O_CREAT | O_TRUNC] = "w+";
    FLAGS2[FLAGS2["wx+"] = O_RDWR | O_CREAT | O_TRUNC | O_EXCL] = "wx+";
    FLAGS2[FLAGS2["xw+"] = FLAGS2["wx+"]] = "xw+";
    FLAGS2[FLAGS2["a"] = O_WRONLY | O_APPEND | O_CREAT] = "a";
    FLAGS2[FLAGS2["ax"] = O_WRONLY | O_APPEND | O_CREAT | O_EXCL] = "ax";
    FLAGS2[FLAGS2["xa"] = FLAGS2.ax] = "xa";
    FLAGS2[FLAGS2["a+"] = O_RDWR | O_APPEND | O_CREAT] = "a+";
    FLAGS2[FLAGS2["ax+"] = O_RDWR | O_APPEND | O_CREAT | O_EXCL] = "ax+";
    FLAGS2[FLAGS2["xa+"] = FLAGS2["ax+"]] = "xa+";
  })(FLAGS = exports$44.FLAGS || (exports$44.FLAGS = {}));
  function flagsToNumber(flags) {
    if (typeof flags === "number") return flags;
    if (typeof flags === "string") {
      var flagsNum = FLAGS[flags];
      if (typeof flagsNum !== "undefined") return flagsNum;
    }
    throw new errors.TypeError("ERR_INVALID_OPT_VALUE", "flags", flags);
  }
  exports$44.flagsToNumber = flagsToNumber;
  function getOptions(defaults20, options) {
    var opts;
    if (!options) return defaults20;
    else {
      var tipeof = typeof options;
      switch (tipeof) {
        case "string":
          opts = Object.assign({}, defaults20, {
            encoding: options
          });
          break;
        case "object":
          opts = Object.assign({}, defaults20, options);
          break;
        default:
          throw TypeError(ERRSTR_OPTS(tipeof));
      }
    }
    if (opts.encoding !== "buffer") (0, encoding_1.assertEncoding)(opts.encoding);
    return opts;
  }
  function optsGenerator(defaults20) {
    return function(options) {
      return getOptions(defaults20, options);
    };
  }
  function validateCallback(callback) {
    if (typeof callback !== "function") throw TypeError(ERRSTR.CB);
    return callback;
  }
  function optsAndCbGenerator(getOpts) {
    return function(options, callback) {
      return typeof options === "function" ? [getOpts(), options] : [getOpts(options), validateCallback(callback)];
    };
  }
  var optsDefaults = {
    encoding: "utf8"
  };
  var getDefaultOpts = optsGenerator(optsDefaults);
  var getDefaultOptsAndCb = optsAndCbGenerator(getDefaultOpts);
  var readFileOptsDefaults = {
    flag: "r"
  };
  var getReadFileOptions = optsGenerator(readFileOptsDefaults);
  var writeFileDefaults = {
    encoding: "utf8",
    mode: 438,
    flag: FLAGS[FLAGS.w]
  };
  var getWriteFileOptions = optsGenerator(writeFileDefaults);
  var appendFileDefaults = {
    encoding: "utf8",
    mode: 438,
    flag: FLAGS[FLAGS.a]
  };
  var getAppendFileOpts = optsGenerator(appendFileDefaults);
  var getAppendFileOptsAndCb = optsAndCbGenerator(getAppendFileOpts);
  var realpathDefaults = optsDefaults;
  var getRealpathOptions = optsGenerator(realpathDefaults);
  var getRealpathOptsAndCb = optsAndCbGenerator(getRealpathOptions);
  var mkdirDefaults = {
    mode: 511,
    recursive: false
  };
  var getMkdirOptions = function(options) {
    if (typeof options === "number") return Object.assign({}, mkdirDefaults, {
      mode: options
    });
    return Object.assign({}, mkdirDefaults, options);
  };
  var rmdirDefaults = {
    recursive: false
  };
  var getRmdirOptions = function(options) {
    return Object.assign({}, rmdirDefaults, options);
  };
  var getRmOpts = optsGenerator(optsDefaults);
  var getRmOptsAndCb = optsAndCbGenerator(getRmOpts);
  var readdirDefaults = {
    encoding: "utf8",
    withFileTypes: false
  };
  var getReaddirOptions = optsGenerator(readdirDefaults);
  var getReaddirOptsAndCb = optsAndCbGenerator(getReaddirOptions);
  var statDefaults = {
    bigint: false
  };
  var getStatOptions = function(options) {
    if (options === void 0) {
      options = {};
    }
    return Object.assign({}, statDefaults, options);
  };
  var getStatOptsAndCb = function(options, callback) {
    return typeof options === "function" ? [getStatOptions(), options] : [getStatOptions(options), validateCallback(callback)];
  };
  function getPathFromURLPosix3(url) {
    if (url.hostname !== "") {
      throw new errors.TypeError("ERR_INVALID_FILE_URL_HOST", process_1.default.platform);
    }
    var pathname = url.pathname;
    for (var n6 = 0; n6 < pathname.length; n6++) {
      if (pathname[n6] === "%") {
        var third = pathname.codePointAt(n6 + 2) | 32;
        if (pathname[n6 + 1] === "2" && third === 102) {
          throw new errors.TypeError("ERR_INVALID_FILE_URL_PATH", "must not include encoded / characters");
        }
      }
    }
    return decodeURIComponent(pathname);
  }
  function pathToFilename(path2) {
    if (typeof path2 !== "string" && !buffer_1.Buffer.isBuffer(path2)) {
      try {
        if (!(path2 instanceof h3.URL)) throw new TypeError(ERRSTR.PATH_STR);
      } catch (err) {
        throw new TypeError(ERRSTR.PATH_STR);
      }
      path2 = getPathFromURLPosix3(path2);
    }
    var pathString = String(path2);
    nullCheck(pathString);
    return pathString;
  }
  exports$44.pathToFilename = pathToFilename;
  var resolve3 = function(filename, base) {
    if (base === void 0) {
      base = process_1.default.cwd();
    }
    return resolveCrossPlatform(base, filename);
  };
  if (isWin) {
    var _resolve_1 = resolve3;
    var unixify_1 = dew$34().unixify;
    resolve3 = function(filename, base) {
      return unixify_1(_resolve_1(filename, base));
    };
  }
  function filenameToSteps(filename, base) {
    var fullPath = resolve3(filename, base);
    var fullPathSansSlash = fullPath.substring(1);
    if (!fullPathSansSlash) return [];
    return fullPathSansSlash.split(sep2);
  }
  exports$44.filenameToSteps = filenameToSteps;
  function pathToSteps(path2) {
    return filenameToSteps(pathToFilename(path2));
  }
  exports$44.pathToSteps = pathToSteps;
  function dataToStr(data, encoding) {
    if (encoding === void 0) {
      encoding = encoding_1.ENCODING_UTF8;
    }
    if (buffer_1.Buffer.isBuffer(data)) return data.toString(encoding);
    else if (data instanceof Uint8Array) return (0, buffer_1.bufferFrom)(data).toString(encoding);
    else return String(data);
  }
  exports$44.dataToStr = dataToStr;
  function dataToBuffer(data, encoding) {
    if (encoding === void 0) {
      encoding = encoding_1.ENCODING_UTF8;
    }
    if (buffer_1.Buffer.isBuffer(data)) return data;
    else if (data instanceof Uint8Array) return (0, buffer_1.bufferFrom)(data);
    else return (0, buffer_1.bufferFrom)(String(data), encoding);
  }
  exports$44.dataToBuffer = dataToBuffer;
  function bufferToEncoding(buffer2, encoding) {
    if (!encoding || encoding === "buffer") return buffer2;
    else return buffer2.toString(encoding);
  }
  exports$44.bufferToEncoding = bufferToEncoding;
  function nullCheck(path2, callback) {
    if (("" + path2).indexOf("\0") !== -1) {
      var er = new Error("Path must be a string without null bytes");
      er.code = ENOENT;
      throw er;
    }
    return true;
  }
  function _modeToNumber(mode, def) {
    if (typeof mode === "number") return mode;
    if (typeof mode === "string") return parseInt(mode, 8);
    if (def) return modeToNumber(def);
    return void 0;
  }
  function modeToNumber(mode, def) {
    var result = _modeToNumber(mode, def);
    if (typeof result !== "number" || isNaN(result)) throw new TypeError(ERRSTR.MODE_INT);
    return result;
  }
  function isFd(path2) {
    return path2 >>> 0 === path2;
  }
  function validateFd(fd) {
    if (!isFd(fd)) throw TypeError(ERRSTR.FD);
  }
  function toUnixTimestamp(time) {
    if (typeof time === "string" && +time == time) {
      return +time;
    }
    if (time instanceof Date) {
      return time.getTime() / 1e3;
    }
    if (isFinite(time)) {
      if (time < 0) {
        return Date.now() / 1e3;
      }
      return time;
    }
    throw new Error("Cannot parse time: " + time);
  }
  exports$44.toUnixTimestamp = toUnixTimestamp;
  function validateUid(uid) {
    if (typeof uid !== "number") throw TypeError(ERRSTR.UID);
  }
  function validateGid(gid) {
    if (typeof gid !== "number") throw TypeError(ERRSTR.GID);
  }
  function flattenJSON(nestedJSON) {
    var flatJSON = {};
    function flatten(pathPrefix, node) {
      for (var path2 in node) {
        var contentOrNode = node[path2];
        var joinedPath = join2(pathPrefix, path2);
        if (typeof contentOrNode === "string") {
          flatJSON[joinedPath] = contentOrNode;
        } else if (typeof contentOrNode === "object" && contentOrNode !== null && Object.keys(contentOrNode).length > 0) {
          flatten(joinedPath, contentOrNode);
        } else {
          flatJSON[joinedPath] = null;
        }
      }
    }
    flatten("", nestedJSON);
    return flatJSON;
  }
  var Volume = (
    /** @class */
    function() {
      function Volume2(props) {
        if (props === void 0) {
          props = {};
        }
        this.ino = 0;
        this.inodes = {};
        this.releasedInos = [];
        this.fds = {};
        this.releasedFds = [];
        this.maxFiles = 1e4;
        this.openFiles = 0;
        this.promisesApi = (0, promises_1.default)(this);
        this.statWatchers = {};
        this.props = Object.assign({
          Node: node_1.Node,
          Link: node_1.Link,
          File: node_1.File
        }, props);
        var root = this.createLink();
        root.setNode(this.createNode(true));
        var self2 = this;
        this.StatWatcher = /** @class */
        function(_super) {
          __extends(StatWatcher2, _super);
          function StatWatcher2() {
            return _super.call(this, self2) || this;
          }
          return StatWatcher2;
        }(StatWatcher);
        var _ReadStream = FsReadStream;
        this.ReadStream = /** @class */
        function(_super) {
          __extends(class_1, _super);
          function class_1() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return _super.apply(this, __spreadArray([self2], args, false)) || this;
          }
          return class_1;
        }(_ReadStream);
        var _WriteStream = FsWriteStream;
        this.WriteStream = /** @class */
        function(_super) {
          __extends(class_2, _super);
          function class_2() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            return _super.apply(this, __spreadArray([self2], args, false)) || this;
          }
          return class_2;
        }(_WriteStream);
        this.FSWatcher = /** @class */
        function(_super) {
          __extends(FSWatcher2, _super);
          function FSWatcher2() {
            return _super.call(this, self2) || this;
          }
          return FSWatcher2;
        }(FSWatcher);
        root.setChild(".", root);
        root.getNode().nlink++;
        root.setChild("..", root);
        root.getNode().nlink++;
        this.root = root;
      }
      Volume2.fromJSON = function(json, cwd3) {
        var vol2 = new Volume2();
        vol2.fromJSON(json, cwd3);
        return vol2;
      };
      Volume2.fromNestedJSON = function(json, cwd3) {
        var vol2 = new Volume2();
        vol2.fromNestedJSON(json, cwd3);
        return vol2;
      };
      Object.defineProperty(Volume2.prototype, "promises", {
        get: function() {
          if (this.promisesApi === null) throw new Error("Promise is not supported in this environment.");
          return this.promisesApi;
        },
        enumerable: false,
        configurable: true
      });
      Volume2.prototype.createLink = function(parent, name2, isDirectory, perm) {
        if (isDirectory === void 0) {
          isDirectory = false;
        }
        if (!parent) {
          return new this.props.Link(this, null, "");
        }
        if (!name2) {
          throw new Error("createLink: name cannot be empty");
        }
        return parent.createChild(name2, this.createNode(isDirectory, perm));
      };
      Volume2.prototype.deleteLink = function(link3) {
        var parent = link3.parent;
        if (parent) {
          parent.deleteChild(link3);
          return true;
        }
        return false;
      };
      Volume2.prototype.newInoNumber = function() {
        var releasedFd = this.releasedInos.pop();
        if (releasedFd) return releasedFd;
        else {
          this.ino = (this.ino + 1) % 4294967295;
          return this.ino;
        }
      };
      Volume2.prototype.newFdNumber = function() {
        var releasedFd = this.releasedFds.pop();
        return typeof releasedFd === "number" ? releasedFd : Volume2.fd--;
      };
      Volume2.prototype.createNode = function(isDirectory, perm) {
        if (isDirectory === void 0) {
          isDirectory = false;
        }
        var node = new this.props.Node(this.newInoNumber(), perm);
        if (isDirectory) node.setIsDirectory();
        this.inodes[node.ino] = node;
        return node;
      };
      Volume2.prototype.getNode = function(ino) {
        return this.inodes[ino];
      };
      Volume2.prototype.deleteNode = function(node) {
        node.del();
        delete this.inodes[node.ino];
        this.releasedInos.push(node.ino);
      };
      Volume2.prototype.genRndStr = function() {
        var str = (Math.random() + 1).toString(36).substring(2, 8);
        if (str.length === 6) return str;
        else return this.genRndStr();
      };
      Volume2.prototype.getLink = function(steps) {
        return this.root.walk(steps);
      };
      Volume2.prototype.getLinkOrThrow = function(filename, funcName) {
        var steps = filenameToSteps(filename);
        var link3 = this.getLink(steps);
        if (!link3) throw createError(ENOENT, funcName, filename);
        return link3;
      };
      Volume2.prototype.getResolvedLink = function(filenameOrSteps) {
        var steps = typeof filenameOrSteps === "string" ? filenameToSteps(filenameOrSteps) : filenameOrSteps;
        var link3 = this.root;
        var i5 = 0;
        while (i5 < steps.length) {
          var step = steps[i5];
          link3 = link3.getChild(step);
          if (!link3) return null;
          var node = link3.getNode();
          if (node.isSymlink()) {
            steps = node.symlink.concat(steps.slice(i5 + 1));
            link3 = this.root;
            i5 = 0;
            continue;
          }
          i5++;
        }
        return link3;
      };
      Volume2.prototype.getResolvedLinkOrThrow = function(filename, funcName) {
        var link3 = this.getResolvedLink(filename);
        if (!link3) throw createError(ENOENT, funcName, filename);
        return link3;
      };
      Volume2.prototype.resolveSymlinks = function(link3) {
        return this.getResolvedLink(link3.steps.slice(1));
      };
      Volume2.prototype.getLinkAsDirOrThrow = function(filename, funcName) {
        var link3 = this.getLinkOrThrow(filename, funcName);
        if (!link3.getNode().isDirectory()) throw createError(ENOTDIR, funcName, filename);
        return link3;
      };
      Volume2.prototype.getLinkParent = function(steps) {
        return this.root.walk(steps, steps.length - 1);
      };
      Volume2.prototype.getLinkParentAsDirOrThrow = function(filenameOrSteps, funcName) {
        var steps = filenameOrSteps instanceof Array ? filenameOrSteps : filenameToSteps(filenameOrSteps);
        var link3 = this.getLinkParent(steps);
        if (!link3) throw createError(ENOENT, funcName, sep2 + steps.join(sep2));
        if (!link3.getNode().isDirectory()) throw createError(ENOTDIR, funcName, sep2 + steps.join(sep2));
        return link3;
      };
      Volume2.prototype.getFileByFd = function(fd) {
        return this.fds[String(fd)];
      };
      Volume2.prototype.getFileByFdOrThrow = function(fd, funcName) {
        if (!isFd(fd)) throw TypeError(ERRSTR.FD);
        var file = this.getFileByFd(fd);
        if (!file) throw createError(EBADF, funcName);
        return file;
      };
      Volume2.prototype.wrapAsync = function(method, args, callback) {
        var _this = this;
        validateCallback(callback);
        (0, setImmediate_1.default)(function() {
          var result;
          try {
            result = method.apply(_this, args);
          } catch (err) {
            callback(err);
            return;
          }
          callback(null, result);
        });
      };
      Volume2.prototype._toJSON = function(link3, json, path2) {
        var _a2;
        if (link3 === void 0) {
          link3 = this.root;
        }
        if (json === void 0) {
          json = {};
        }
        var isEmpty = true;
        var children = link3.children;
        if (link3.getNode().isFile()) {
          children = (_a2 = {}, _a2[link3.getName()] = link3.parent.getChild(link3.getName()), _a2);
          link3 = link3.parent;
        }
        for (var name_1 in children) {
          if (name_1 === "." || name_1 === "..") {
            continue;
          }
          isEmpty = false;
          var child = link3.getChild(name_1);
          if (!child) {
            throw new Error("_toJSON: unexpected undefined");
          }
          var node = child.getNode();
          if (node.isFile()) {
            var filename = child.getPath();
            if (path2) filename = relative2(path2, filename);
            json[filename] = node.getString();
          } else if (node.isDirectory()) {
            this._toJSON(child, json, path2);
          }
        }
        var dirPath = link3.getPath();
        if (path2) dirPath = relative2(path2, dirPath);
        if (dirPath && isEmpty) {
          json[dirPath] = null;
        }
        return json;
      };
      Volume2.prototype.toJSON = function(paths, json, isRelative) {
        if (json === void 0) {
          json = {};
        }
        if (isRelative === void 0) {
          isRelative = false;
        }
        var links = [];
        if (paths) {
          if (!(paths instanceof Array)) paths = [paths];
          for (var _i = 0, paths_1 = paths; _i < paths_1.length; _i++) {
            var path2 = paths_1[_i];
            var filename = pathToFilename(path2);
            var link3 = this.getResolvedLink(filename);
            if (!link3) continue;
            links.push(link3);
          }
        } else {
          links.push(this.root);
        }
        if (!links.length) return json;
        for (var _a2 = 0, links_1 = links; _a2 < links_1.length; _a2++) {
          var link3 = links_1[_a2];
          this._toJSON(link3, json, isRelative ? link3.getPath() : "");
        }
        return json;
      };
      Volume2.prototype.fromJSON = function(json, cwd3) {
        if (cwd3 === void 0) {
          cwd3 = process_1.default.cwd();
        }
        for (var filename in json) {
          var data = json[filename];
          filename = resolve3(filename, cwd3);
          if (typeof data === "string") {
            var dir = dirname2(filename);
            this.mkdirpBase(
              dir,
              511
              /* MODE.DIR */
            );
            this.writeFileSync(filename, data);
          } else {
            this.mkdirpBase(
              filename,
              511
              /* MODE.DIR */
            );
          }
        }
      };
      Volume2.prototype.fromNestedJSON = function(json, cwd3) {
        this.fromJSON(flattenJSON(json), cwd3);
      };
      Volume2.prototype.reset = function() {
        this.ino = 0;
        this.inodes = {};
        this.releasedInos = [];
        this.fds = {};
        this.releasedFds = [];
        this.openFiles = 0;
        this.root = this.createLink();
        this.root.setNode(this.createNode(true));
      };
      Volume2.prototype.mountSync = function(mountpoint, json) {
        this.fromJSON(json, mountpoint);
      };
      Volume2.prototype.openLink = function(link3, flagsNum, resolveSymlinks) {
        if (resolveSymlinks === void 0) {
          resolveSymlinks = true;
        }
        if (this.openFiles >= this.maxFiles) {
          throw createError(EMFILE, "open", link3.getPath());
        }
        var realLink = link3;
        if (resolveSymlinks) realLink = this.resolveSymlinks(link3);
        if (!realLink) throw createError(ENOENT, "open", link3.getPath());
        var node = realLink.getNode();
        if (node.isDirectory()) {
          if ((flagsNum & (O_RDONLY | O_RDWR | O_WRONLY)) !== O_RDONLY) throw createError(EISDIR, "open", link3.getPath());
        } else {
          if (flagsNum & O_DIRECTORY) throw createError(ENOTDIR, "open", link3.getPath());
        }
        if (!(flagsNum & O_WRONLY)) {
          if (!node.canRead()) {
            throw createError(EACCES, "open", link3.getPath());
          }
        }
        var file = new this.props.File(link3, node, flagsNum, this.newFdNumber());
        this.fds[file.fd] = file;
        this.openFiles++;
        if (flagsNum & O_TRUNC) file.truncate();
        return file;
      };
      Volume2.prototype.openFile = function(filename, flagsNum, modeNum, resolveSymlinks) {
        if (resolveSymlinks === void 0) {
          resolveSymlinks = true;
        }
        var steps = filenameToSteps(filename);
        var link3 = resolveSymlinks ? this.getResolvedLink(steps) : this.getLink(steps);
        if (link3 && flagsNum & O_EXCL) throw createError(EEXIST, "open", filename);
        if (!link3 && flagsNum & O_CREAT) {
          var dirLink = this.getResolvedLink(steps.slice(0, steps.length - 1));
          if (!dirLink) throw createError(ENOENT, "open", sep2 + steps.join(sep2));
          if (flagsNum & O_CREAT && typeof modeNum === "number") {
            link3 = this.createLink(dirLink, steps[steps.length - 1], false, modeNum);
          }
        }
        if (link3) return this.openLink(link3, flagsNum, resolveSymlinks);
        throw createError(ENOENT, "open", filename);
      };
      Volume2.prototype.openBase = function(filename, flagsNum, modeNum, resolveSymlinks) {
        if (resolveSymlinks === void 0) {
          resolveSymlinks = true;
        }
        var file = this.openFile(filename, flagsNum, modeNum, resolveSymlinks);
        if (!file) throw createError(ENOENT, "open", filename);
        return file.fd;
      };
      Volume2.prototype.openSync = function(path2, flags, mode) {
        if (mode === void 0) {
          mode = 438;
        }
        var modeNum = modeToNumber(mode);
        var fileName = pathToFilename(path2);
        var flagsNum = flagsToNumber(flags);
        return this.openBase(fileName, flagsNum, modeNum);
      };
      Volume2.prototype.open = function(path2, flags, a5, b6) {
        var mode = a5;
        var callback = b6;
        if (typeof a5 === "function") {
          mode = 438;
          callback = a5;
        }
        mode = mode || 438;
        var modeNum = modeToNumber(mode);
        var fileName = pathToFilename(path2);
        var flagsNum = flagsToNumber(flags);
        this.wrapAsync(this.openBase, [fileName, flagsNum, modeNum], callback);
      };
      Volume2.prototype.closeFile = function(file) {
        if (!this.fds[file.fd]) return;
        this.openFiles--;
        delete this.fds[file.fd];
        this.releasedFds.push(file.fd);
      };
      Volume2.prototype.closeSync = function(fd) {
        validateFd(fd);
        var file = this.getFileByFdOrThrow(fd, "close");
        this.closeFile(file);
      };
      Volume2.prototype.close = function(fd, callback) {
        validateFd(fd);
        this.wrapAsync(this.closeSync, [fd], callback);
      };
      Volume2.prototype.openFileOrGetById = function(id, flagsNum, modeNum) {
        if (typeof id === "number") {
          var file = this.fds[id];
          if (!file) throw createError(ENOENT);
          return file;
        } else {
          return this.openFile(pathToFilename(id), flagsNum, modeNum);
        }
      };
      Volume2.prototype.readBase = function(fd, buffer2, offset, length, position) {
        var file = this.getFileByFdOrThrow(fd);
        return file.read(buffer2, Number(offset), Number(length), position);
      };
      Volume2.prototype.readSync = function(fd, buffer2, offset, length, position) {
        validateFd(fd);
        return this.readBase(fd, buffer2, offset, length, position);
      };
      Volume2.prototype.read = function(fd, buffer2, offset, length, position, callback) {
        var _this = this;
        validateCallback(callback);
        if (length === 0) {
          return process_1.default.nextTick(function() {
            if (callback) callback(null, 0, buffer2);
          });
        }
        (0, setImmediate_1.default)(function() {
          try {
            var bytes = _this.readBase(fd, buffer2, offset, length, position);
            callback(null, bytes, buffer2);
          } catch (err) {
            callback(err);
          }
        });
      };
      Volume2.prototype.readFileBase = function(id, flagsNum, encoding) {
        var result;
        var isUserFd = typeof id === "number";
        var userOwnsFd = isUserFd && isFd(id);
        var fd;
        if (userOwnsFd) fd = id;
        else {
          var filename = pathToFilename(id);
          var steps = filenameToSteps(filename);
          var link3 = this.getResolvedLink(steps);
          if (link3) {
            var node = link3.getNode();
            if (node.isDirectory()) throw createError(EISDIR, "open", link3.getPath());
          }
          fd = this.openSync(id, flagsNum);
        }
        try {
          result = bufferToEncoding(this.getFileByFdOrThrow(fd).getBuffer(), encoding);
        } finally {
          if (!userOwnsFd) {
            this.closeSync(fd);
          }
        }
        return result;
      };
      Volume2.prototype.readFileSync = function(file, options) {
        var opts = getReadFileOptions(options);
        var flagsNum = flagsToNumber(opts.flag);
        return this.readFileBase(file, flagsNum, opts.encoding);
      };
      Volume2.prototype.readFile = function(id, a5, b6) {
        var _a2 = optsAndCbGenerator(getReadFileOptions)(a5, b6), opts = _a2[0], callback = _a2[1];
        var flagsNum = flagsToNumber(opts.flag);
        this.wrapAsync(this.readFileBase, [id, flagsNum, opts.encoding], callback);
      };
      Volume2.prototype.writeBase = function(fd, buf, offset, length, position) {
        var file = this.getFileByFdOrThrow(fd, "write");
        return file.write(buf, offset, length, position);
      };
      Volume2.prototype.writeSync = function(fd, a5, b6, c5, d5) {
        validateFd(fd);
        var encoding;
        var offset;
        var length;
        var position;
        var isBuffer = typeof a5 !== "string";
        if (isBuffer) {
          offset = (b6 || 0) | 0;
          length = c5;
          position = d5;
        } else {
          position = b6;
          encoding = c5;
        }
        var buf = dataToBuffer(a5, encoding);
        if (isBuffer) {
          if (typeof length === "undefined") {
            length = buf.length;
          }
        } else {
          offset = 0;
          length = buf.length;
        }
        return this.writeBase(fd, buf, offset, length, position);
      };
      Volume2.prototype.write = function(fd, a5, b6, c5, d5, e7) {
        var _this = this;
        validateFd(fd);
        var offset;
        var length;
        var position;
        var encoding;
        var callback;
        var tipa = typeof a5;
        var tipb = typeof b6;
        var tipc = typeof c5;
        var tipd = typeof d5;
        if (tipa !== "string") {
          if (tipb === "function") {
            callback = b6;
          } else if (tipc === "function") {
            offset = b6 | 0;
            callback = c5;
          } else if (tipd === "function") {
            offset = b6 | 0;
            length = c5;
            callback = d5;
          } else {
            offset = b6 | 0;
            length = c5;
            position = d5;
            callback = e7;
          }
        } else {
          if (tipb === "function") {
            callback = b6;
          } else if (tipc === "function") {
            position = b6;
            callback = c5;
          } else if (tipd === "function") {
            position = b6;
            encoding = c5;
            callback = d5;
          }
        }
        var buf = dataToBuffer(a5, encoding);
        if (tipa !== "string") {
          if (typeof length === "undefined") length = buf.length;
        } else {
          offset = 0;
          length = buf.length;
        }
        var cb = validateCallback(callback);
        (0, setImmediate_1.default)(function() {
          try {
            var bytes = _this.writeBase(fd, buf, offset, length, position);
            if (tipa !== "string") {
              cb(null, bytes, buf);
            } else {
              cb(null, bytes, a5);
            }
          } catch (err) {
            cb(err);
          }
        });
      };
      Volume2.prototype.writeFileBase = function(id, buf, flagsNum, modeNum) {
        var isUserFd = typeof id === "number";
        var fd;
        if (isUserFd) fd = id;
        else {
          fd = this.openBase(pathToFilename(id), flagsNum, modeNum);
        }
        var offset = 0;
        var length = buf.length;
        var position = flagsNum & O_APPEND ? void 0 : 0;
        try {
          while (length > 0) {
            var written = this.writeSync(fd, buf, offset, length, position);
            offset += written;
            length -= written;
            if (position !== void 0) position += written;
          }
        } finally {
          if (!isUserFd) this.closeSync(fd);
        }
      };
      Volume2.prototype.writeFileSync = function(id, data, options) {
        var opts = getWriteFileOptions(options);
        var flagsNum = flagsToNumber(opts.flag);
        var modeNum = modeToNumber(opts.mode);
        var buf = dataToBuffer(data, opts.encoding);
        this.writeFileBase(id, buf, flagsNum, modeNum);
      };
      Volume2.prototype.writeFile = function(id, data, a5, b6) {
        var options = a5;
        var callback = b6;
        if (typeof a5 === "function") {
          options = writeFileDefaults;
          callback = a5;
        }
        var cb = validateCallback(callback);
        var opts = getWriteFileOptions(options);
        var flagsNum = flagsToNumber(opts.flag);
        var modeNum = modeToNumber(opts.mode);
        var buf = dataToBuffer(data, opts.encoding);
        this.wrapAsync(this.writeFileBase, [id, buf, flagsNum, modeNum], cb);
      };
      Volume2.prototype.linkBase = function(filename1, filename2) {
        var steps1 = filenameToSteps(filename1);
        var link1 = this.getLink(steps1);
        if (!link1) throw createError(ENOENT, "link", filename1, filename2);
        var steps2 = filenameToSteps(filename2);
        var dir2 = this.getLinkParent(steps2);
        if (!dir2) throw createError(ENOENT, "link", filename1, filename2);
        var name2 = steps2[steps2.length - 1];
        if (dir2.getChild(name2)) throw createError(EEXIST, "link", filename1, filename2);
        var node = link1.getNode();
        node.nlink++;
        dir2.createChild(name2, node);
      };
      Volume2.prototype.copyFileBase = function(src, dest, flags) {
        var buf = this.readFileSync(src);
        if (flags & COPYFILE_EXCL) {
          if (this.existsSync(dest)) {
            throw createError(EEXIST, "copyFile", src, dest);
          }
        }
        if (flags & COPYFILE_FICLONE_FORCE) {
          throw createError(ENOSYS, "copyFile", src, dest);
        }
        this.writeFileBase(
          dest,
          buf,
          FLAGS.w,
          438
          /* MODE.DEFAULT */
        );
      };
      Volume2.prototype.copyFileSync = function(src, dest, flags) {
        var srcFilename = pathToFilename(src);
        var destFilename = pathToFilename(dest);
        return this.copyFileBase(srcFilename, destFilename, (flags || 0) | 0);
      };
      Volume2.prototype.copyFile = function(src, dest, a5, b6) {
        var srcFilename = pathToFilename(src);
        var destFilename = pathToFilename(dest);
        var flags;
        var callback;
        if (typeof a5 === "function") {
          flags = 0;
          callback = a5;
        } else {
          flags = a5;
          callback = b6;
        }
        validateCallback(callback);
        this.wrapAsync(this.copyFileBase, [srcFilename, destFilename, flags], callback);
      };
      Volume2.prototype.linkSync = function(existingPath, newPath) {
        var existingPathFilename = pathToFilename(existingPath);
        var newPathFilename = pathToFilename(newPath);
        this.linkBase(existingPathFilename, newPathFilename);
      };
      Volume2.prototype.link = function(existingPath, newPath, callback) {
        var existingPathFilename = pathToFilename(existingPath);
        var newPathFilename = pathToFilename(newPath);
        this.wrapAsync(this.linkBase, [existingPathFilename, newPathFilename], callback);
      };
      Volume2.prototype.unlinkBase = function(filename) {
        var steps = filenameToSteps(filename);
        var link3 = this.getLink(steps);
        if (!link3) throw createError(ENOENT, "unlink", filename);
        if (link3.length) throw Error("Dir not empty...");
        this.deleteLink(link3);
        var node = link3.getNode();
        node.nlink--;
        if (node.nlink <= 0) {
          this.deleteNode(node);
        }
      };
      Volume2.prototype.unlinkSync = function(path2) {
        var filename = pathToFilename(path2);
        this.unlinkBase(filename);
      };
      Volume2.prototype.unlink = function(path2, callback) {
        var filename = pathToFilename(path2);
        this.wrapAsync(this.unlinkBase, [filename], callback);
      };
      Volume2.prototype.symlinkBase = function(targetFilename, pathFilename) {
        var pathSteps = filenameToSteps(pathFilename);
        var dirLink = this.getLinkParent(pathSteps);
        if (!dirLink) throw createError(ENOENT, "symlink", targetFilename, pathFilename);
        var name2 = pathSteps[pathSteps.length - 1];
        if (dirLink.getChild(name2)) throw createError(EEXIST, "symlink", targetFilename, pathFilename);
        var symlink3 = dirLink.createChild(name2);
        symlink3.getNode().makeSymlink(filenameToSteps(targetFilename));
        return symlink3;
      };
      Volume2.prototype.symlinkSync = function(target, path2, type) {
        var targetFilename = pathToFilename(target);
        var pathFilename = pathToFilename(path2);
        this.symlinkBase(targetFilename, pathFilename);
      };
      Volume2.prototype.symlink = function(target, path2, a5, b6) {
        var callback = validateCallback(typeof a5 === "function" ? a5 : b6);
        var targetFilename = pathToFilename(target);
        var pathFilename = pathToFilename(path2);
        this.wrapAsync(this.symlinkBase, [targetFilename, pathFilename], callback);
      };
      Volume2.prototype.realpathBase = function(filename, encoding) {
        var steps = filenameToSteps(filename);
        var realLink = this.getResolvedLink(steps);
        if (!realLink) throw createError(ENOENT, "realpath", filename);
        return (0, encoding_1.strToEncoding)(realLink.getPath() || "/", encoding);
      };
      Volume2.prototype.realpathSync = function(path2, options) {
        return this.realpathBase(pathToFilename(path2), getRealpathOptions(options).encoding);
      };
      Volume2.prototype.realpath = function(path2, a5, b6) {
        var _a2 = getRealpathOptsAndCb(a5, b6), opts = _a2[0], callback = _a2[1];
        var pathFilename = pathToFilename(path2);
        this.wrapAsync(this.realpathBase, [pathFilename, opts.encoding], callback);
      };
      Volume2.prototype.lstatBase = function(filename, bigint, throwIfNoEntry) {
        if (bigint === void 0) {
          bigint = false;
        }
        if (throwIfNoEntry === void 0) {
          throwIfNoEntry = false;
        }
        var link3 = this.getLink(filenameToSteps(filename));
        if (link3) {
          return Stats_1.default.build(link3.getNode(), bigint);
        } else if (!throwIfNoEntry) {
          return void 0;
        } else {
          throw createError(ENOENT, "lstat", filename);
        }
      };
      Volume2.prototype.lstatSync = function(path2, options) {
        var _a2 = getStatOptions(options), _b = _a2.throwIfNoEntry, throwIfNoEntry = _b === void 0 ? true : _b, _c = _a2.bigint, bigint = _c === void 0 ? false : _c;
        return this.lstatBase(pathToFilename(path2), bigint, throwIfNoEntry);
      };
      Volume2.prototype.lstat = function(path2, a5, b6) {
        var _a2 = getStatOptsAndCb(a5, b6), _b = _a2[0], _c = _b.throwIfNoEntry, throwIfNoEntry = _c === void 0 ? true : _c, _d = _b.bigint, bigint = _d === void 0 ? false : _d, callback = _a2[1];
        this.wrapAsync(this.lstatBase, [pathToFilename(path2), bigint, throwIfNoEntry], callback);
      };
      Volume2.prototype.statBase = function(filename, bigint, throwIfNoEntry) {
        if (bigint === void 0) {
          bigint = false;
        }
        if (throwIfNoEntry === void 0) {
          throwIfNoEntry = true;
        }
        var link3 = this.getResolvedLink(filenameToSteps(filename));
        if (link3) {
          return Stats_1.default.build(link3.getNode(), bigint);
        } else if (!throwIfNoEntry) {
          return void 0;
        } else {
          throw createError(ENOENT, "stat", filename);
        }
      };
      Volume2.prototype.statSync = function(path2, options) {
        var _a2 = getStatOptions(options), _b = _a2.bigint, bigint = _b === void 0 ? true : _b, _c = _a2.throwIfNoEntry, throwIfNoEntry = _c === void 0 ? true : _c;
        return this.statBase(pathToFilename(path2), bigint, throwIfNoEntry);
      };
      Volume2.prototype.stat = function(path2, a5, b6) {
        var _a2 = getStatOptsAndCb(a5, b6), _b = _a2[0], _c = _b.bigint, bigint = _c === void 0 ? false : _c, _d = _b.throwIfNoEntry, throwIfNoEntry = _d === void 0 ? true : _d, callback = _a2[1];
        this.wrapAsync(this.statBase, [pathToFilename(path2), bigint, throwIfNoEntry], callback);
      };
      Volume2.prototype.fstatBase = function(fd, bigint) {
        if (bigint === void 0) {
          bigint = false;
        }
        var file = this.getFileByFd(fd);
        if (!file) throw createError(EBADF, "fstat");
        return Stats_1.default.build(file.node, bigint);
      };
      Volume2.prototype.fstatSync = function(fd, options) {
        return this.fstatBase(fd, getStatOptions(options).bigint);
      };
      Volume2.prototype.fstat = function(fd, a5, b6) {
        var _a2 = getStatOptsAndCb(a5, b6), opts = _a2[0], callback = _a2[1];
        this.wrapAsync(this.fstatBase, [fd, opts.bigint], callback);
      };
      Volume2.prototype.renameBase = function(oldPathFilename, newPathFilename) {
        var link3 = this.getLink(filenameToSteps(oldPathFilename));
        if (!link3) throw createError(ENOENT, "rename", oldPathFilename, newPathFilename);
        var newPathSteps = filenameToSteps(newPathFilename);
        var newPathDirLink = this.getLinkParent(newPathSteps);
        if (!newPathDirLink) throw createError(ENOENT, "rename", oldPathFilename, newPathFilename);
        var oldLinkParent = link3.parent;
        if (oldLinkParent) {
          oldLinkParent.deleteChild(link3);
        }
        var name2 = newPathSteps[newPathSteps.length - 1];
        link3.name = name2;
        link3.steps = __spreadArray(__spreadArray([], newPathDirLink.steps, true), [name2], false);
        newPathDirLink.setChild(link3.getName(), link3);
      };
      Volume2.prototype.renameSync = function(oldPath, newPath) {
        var oldPathFilename = pathToFilename(oldPath);
        var newPathFilename = pathToFilename(newPath);
        this.renameBase(oldPathFilename, newPathFilename);
      };
      Volume2.prototype.rename = function(oldPath, newPath, callback) {
        var oldPathFilename = pathToFilename(oldPath);
        var newPathFilename = pathToFilename(newPath);
        this.wrapAsync(this.renameBase, [oldPathFilename, newPathFilename], callback);
      };
      Volume2.prototype.existsBase = function(filename) {
        return !!this.statBase(filename);
      };
      Volume2.prototype.existsSync = function(path2) {
        try {
          return this.existsBase(pathToFilename(path2));
        } catch (err) {
          return false;
        }
      };
      Volume2.prototype.exists = function(path2, callback) {
        var _this = this;
        var filename = pathToFilename(path2);
        if (typeof callback !== "function") throw Error(ERRSTR.CB);
        (0, setImmediate_1.default)(function() {
          try {
            callback(_this.existsBase(filename));
          } catch (err) {
            callback(false);
          }
        });
      };
      Volume2.prototype.accessBase = function(filename, mode) {
        this.getLinkOrThrow(filename, "access");
      };
      Volume2.prototype.accessSync = function(path2, mode) {
        if (mode === void 0) {
          mode = F_OK2;
        }
        var filename = pathToFilename(path2);
        mode = mode | 0;
        this.accessBase(filename, mode);
      };
      Volume2.prototype.access = function(path2, a5, b6) {
        var mode = F_OK2;
        var callback;
        if (typeof a5 !== "function") {
          mode = a5 | 0;
          callback = validateCallback(b6);
        } else {
          callback = a5;
        }
        var filename = pathToFilename(path2);
        this.wrapAsync(this.accessBase, [filename, mode], callback);
      };
      Volume2.prototype.appendFileSync = function(id, data, options) {
        if (options === void 0) {
          options = appendFileDefaults;
        }
        var opts = getAppendFileOpts(options);
        if (!opts.flag || isFd(id)) opts.flag = "a";
        this.writeFileSync(id, data, opts);
      };
      Volume2.prototype.appendFile = function(id, data, a5, b6) {
        var _a2 = getAppendFileOptsAndCb(a5, b6), opts = _a2[0], callback = _a2[1];
        if (!opts.flag || isFd(id)) opts.flag = "a";
        this.writeFile(id, data, opts, callback);
      };
      Volume2.prototype.readdirBase = function(filename, options) {
        var steps = filenameToSteps(filename);
        var link3 = this.getResolvedLink(steps);
        if (!link3) throw createError(ENOENT, "readdir", filename);
        var node = link3.getNode();
        if (!node.isDirectory()) throw createError(ENOTDIR, "scandir", filename);
        if (options.withFileTypes) {
          var list_1 = [];
          for (var name_2 in link3.children) {
            var child = link3.getChild(name_2);
            if (!child || name_2 === "." || name_2 === "..") {
              continue;
            }
            list_1.push(Dirent_1.default.build(child, options.encoding));
          }
          if (!isWin && options.encoding !== "buffer") list_1.sort(function(a5, b6) {
            if (a5.name < b6.name) return -1;
            if (a5.name > b6.name) return 1;
            return 0;
          });
          return list_1;
        }
        var list = [];
        for (var name_3 in link3.children) {
          if (name_3 === "." || name_3 === "..") {
            continue;
          }
          list.push((0, encoding_1.strToEncoding)(name_3, options.encoding));
        }
        if (!isWin && options.encoding !== "buffer") list.sort();
        return list;
      };
      Volume2.prototype.readdirSync = function(path2, options) {
        var opts = getReaddirOptions(options);
        var filename = pathToFilename(path2);
        return this.readdirBase(filename, opts);
      };
      Volume2.prototype.readdir = function(path2, a5, b6) {
        var _a2 = getReaddirOptsAndCb(a5, b6), options = _a2[0], callback = _a2[1];
        var filename = pathToFilename(path2);
        this.wrapAsync(this.readdirBase, [filename, options], callback);
      };
      Volume2.prototype.readlinkBase = function(filename, encoding) {
        var link3 = this.getLinkOrThrow(filename, "readlink");
        var node = link3.getNode();
        if (!node.isSymlink()) throw createError(EINVAL, "readlink", filename);
        var str = sep2 + node.symlink.join(sep2);
        return (0, encoding_1.strToEncoding)(str, encoding);
      };
      Volume2.prototype.readlinkSync = function(path2, options) {
        var opts = getDefaultOpts(options);
        var filename = pathToFilename(path2);
        return this.readlinkBase(filename, opts.encoding);
      };
      Volume2.prototype.readlink = function(path2, a5, b6) {
        var _a2 = getDefaultOptsAndCb(a5, b6), opts = _a2[0], callback = _a2[1];
        var filename = pathToFilename(path2);
        this.wrapAsync(this.readlinkBase, [filename, opts.encoding], callback);
      };
      Volume2.prototype.fsyncBase = function(fd) {
        this.getFileByFdOrThrow(fd, "fsync");
      };
      Volume2.prototype.fsyncSync = function(fd) {
        this.fsyncBase(fd);
      };
      Volume2.prototype.fsync = function(fd, callback) {
        this.wrapAsync(this.fsyncBase, [fd], callback);
      };
      Volume2.prototype.fdatasyncBase = function(fd) {
        this.getFileByFdOrThrow(fd, "fdatasync");
      };
      Volume2.prototype.fdatasyncSync = function(fd) {
        this.fdatasyncBase(fd);
      };
      Volume2.prototype.fdatasync = function(fd, callback) {
        this.wrapAsync(this.fdatasyncBase, [fd], callback);
      };
      Volume2.prototype.ftruncateBase = function(fd, len) {
        var file = this.getFileByFdOrThrow(fd, "ftruncate");
        file.truncate(len);
      };
      Volume2.prototype.ftruncateSync = function(fd, len) {
        this.ftruncateBase(fd, len);
      };
      Volume2.prototype.ftruncate = function(fd, a5, b6) {
        var len = typeof a5 === "number" ? a5 : 0;
        var callback = validateCallback(typeof a5 === "number" ? b6 : a5);
        this.wrapAsync(this.ftruncateBase, [fd, len], callback);
      };
      Volume2.prototype.truncateBase = function(path2, len) {
        var fd = this.openSync(path2, "r+");
        try {
          this.ftruncateSync(fd, len);
        } finally {
          this.closeSync(fd);
        }
      };
      Volume2.prototype.truncateSync = function(id, len) {
        if (isFd(id)) return this.ftruncateSync(id, len);
        this.truncateBase(id, len);
      };
      Volume2.prototype.truncate = function(id, a5, b6) {
        var len = typeof a5 === "number" ? a5 : 0;
        var callback = validateCallback(typeof a5 === "number" ? b6 : a5);
        if (isFd(id)) return this.ftruncate(id, len, callback);
        this.wrapAsync(this.truncateBase, [id, len], callback);
      };
      Volume2.prototype.futimesBase = function(fd, atime, mtime) {
        var file = this.getFileByFdOrThrow(fd, "futimes");
        var node = file.node;
        node.atime = new Date(atime * 1e3);
        node.mtime = new Date(mtime * 1e3);
      };
      Volume2.prototype.futimesSync = function(fd, atime, mtime) {
        this.futimesBase(fd, toUnixTimestamp(atime), toUnixTimestamp(mtime));
      };
      Volume2.prototype.futimes = function(fd, atime, mtime, callback) {
        this.wrapAsync(this.futimesBase, [fd, toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);
      };
      Volume2.prototype.utimesBase = function(filename, atime, mtime) {
        var fd = this.openSync(filename, "r");
        try {
          this.futimesBase(fd, atime, mtime);
        } finally {
          this.closeSync(fd);
        }
      };
      Volume2.prototype.utimesSync = function(path2, atime, mtime) {
        this.utimesBase(pathToFilename(path2), toUnixTimestamp(atime), toUnixTimestamp(mtime));
      };
      Volume2.prototype.utimes = function(path2, atime, mtime, callback) {
        this.wrapAsync(this.utimesBase, [pathToFilename(path2), toUnixTimestamp(atime), toUnixTimestamp(mtime)], callback);
      };
      Volume2.prototype.mkdirBase = function(filename, modeNum) {
        var steps = filenameToSteps(filename);
        if (!steps.length) {
          throw createError(EEXIST, "mkdir", filename);
        }
        var dir = this.getLinkParentAsDirOrThrow(filename, "mkdir");
        var name2 = steps[steps.length - 1];
        if (dir.getChild(name2)) throw createError(EEXIST, "mkdir", filename);
        dir.createChild(name2, this.createNode(true, modeNum));
      };
      Volume2.prototype.mkdirpBase = function(filename, modeNum) {
        var fullPath = resolve3(filename);
        var fullPathSansSlash = fullPath.substring(1);
        var steps = !fullPathSansSlash ? [] : fullPathSansSlash.split(sep2);
        var link3 = this.root;
        var created = false;
        for (var i5 = 0; i5 < steps.length; i5++) {
          var step = steps[i5];
          if (!link3.getNode().isDirectory()) throw createError(ENOTDIR, "mkdir", link3.getPath());
          var child = link3.getChild(step);
          if (child) {
            if (child.getNode().isDirectory()) link3 = child;
            else throw createError(ENOTDIR, "mkdir", child.getPath());
          } else {
            link3 = link3.createChild(step, this.createNode(true, modeNum));
            created = true;
          }
        }
        return created ? fullPath : void 0;
      };
      Volume2.prototype.mkdirSync = function(path2, options) {
        var opts = getMkdirOptions(options);
        var modeNum = modeToNumber(opts.mode, 511);
        var filename = pathToFilename(path2);
        if (opts.recursive) return this.mkdirpBase(filename, modeNum);
        this.mkdirBase(filename, modeNum);
      };
      Volume2.prototype.mkdir = function(path2, a5, b6) {
        var opts = getMkdirOptions(a5);
        var callback = validateCallback(typeof a5 === "function" ? a5 : b6);
        var modeNum = modeToNumber(opts.mode, 511);
        var filename = pathToFilename(path2);
        if (opts.recursive) this.wrapAsync(this.mkdirpBase, [filename, modeNum], callback);
        else this.wrapAsync(this.mkdirBase, [filename, modeNum], callback);
      };
      Volume2.prototype.mkdirpSync = function(path2, mode) {
        return this.mkdirSync(path2, {
          mode,
          recursive: true
        });
      };
      Volume2.prototype.mkdirp = function(path2, a5, b6) {
        var mode = typeof a5 === "function" ? void 0 : a5;
        var callback = validateCallback(typeof a5 === "function" ? a5 : b6);
        this.mkdir(path2, {
          mode,
          recursive: true
        }, callback);
      };
      Volume2.prototype.mkdtempBase = function(prefix, encoding, retry) {
        if (retry === void 0) {
          retry = 5;
        }
        var filename = prefix + this.genRndStr();
        try {
          this.mkdirBase(
            filename,
            511
            /* MODE.DIR */
          );
          return (0, encoding_1.strToEncoding)(filename, encoding);
        } catch (err) {
          if (err.code === EEXIST) {
            if (retry > 1) return this.mkdtempBase(prefix, encoding, retry - 1);
            else throw Error("Could not create temp dir.");
          } else throw err;
        }
      };
      Volume2.prototype.mkdtempSync = function(prefix, options) {
        var encoding = getDefaultOpts(options).encoding;
        if (!prefix || typeof prefix !== "string") throw new TypeError("filename prefix is required");
        nullCheck(prefix);
        return this.mkdtempBase(prefix, encoding);
      };
      Volume2.prototype.mkdtemp = function(prefix, a5, b6) {
        var _a2 = getDefaultOptsAndCb(a5, b6), encoding = _a2[0].encoding, callback = _a2[1];
        if (!prefix || typeof prefix !== "string") throw new TypeError("filename prefix is required");
        if (!nullCheck(prefix)) return;
        this.wrapAsync(this.mkdtempBase, [prefix, encoding], callback);
      };
      Volume2.prototype.rmdirBase = function(filename, options) {
        var opts = getRmdirOptions(options);
        var link3 = this.getLinkAsDirOrThrow(filename, "rmdir");
        if (link3.length && !opts.recursive) throw createError(ENOTEMPTY, "rmdir", filename);
        this.deleteLink(link3);
      };
      Volume2.prototype.rmdirSync = function(path2, options) {
        this.rmdirBase(pathToFilename(path2), options);
      };
      Volume2.prototype.rmdir = function(path2, a5, b6) {
        var opts = getRmdirOptions(a5);
        var callback = validateCallback(typeof a5 === "function" ? a5 : b6);
        this.wrapAsync(this.rmdirBase, [pathToFilename(path2), opts], callback);
      };
      Volume2.prototype.rmBase = function(filename, options) {
        if (options === void 0) {
          options = {};
        }
        var link3 = this.getResolvedLink(filename);
        if (!link3) {
          if (!options.force) throw createError(ENOENT, "stat", filename);
          return;
        }
        if (link3.getNode().isDirectory()) {
          if (!options.recursive) {
            throw createError(ERR_FS_EISDIR, "rm", filename);
          }
        }
        this.deleteLink(link3);
      };
      Volume2.prototype.rmSync = function(path2, options) {
        this.rmBase(pathToFilename(path2), options);
      };
      Volume2.prototype.rm = function(path2, a5, b6) {
        var _a2 = getRmOptsAndCb(a5, b6), opts = _a2[0], callback = _a2[1];
        this.wrapAsync(this.rmBase, [pathToFilename(path2), opts], callback);
      };
      Volume2.prototype.fchmodBase = function(fd, modeNum) {
        var file = this.getFileByFdOrThrow(fd, "fchmod");
        file.chmod(modeNum);
      };
      Volume2.prototype.fchmodSync = function(fd, mode) {
        this.fchmodBase(fd, modeToNumber(mode));
      };
      Volume2.prototype.fchmod = function(fd, mode, callback) {
        this.wrapAsync(this.fchmodBase, [fd, modeToNumber(mode)], callback);
      };
      Volume2.prototype.chmodBase = function(filename, modeNum) {
        var fd = this.openSync(filename, "r");
        try {
          this.fchmodBase(fd, modeNum);
        } finally {
          this.closeSync(fd);
        }
      };
      Volume2.prototype.chmodSync = function(path2, mode) {
        var modeNum = modeToNumber(mode);
        var filename = pathToFilename(path2);
        this.chmodBase(filename, modeNum);
      };
      Volume2.prototype.chmod = function(path2, mode, callback) {
        var modeNum = modeToNumber(mode);
        var filename = pathToFilename(path2);
        this.wrapAsync(this.chmodBase, [filename, modeNum], callback);
      };
      Volume2.prototype.lchmodBase = function(filename, modeNum) {
        var fd = this.openBase(filename, O_RDWR, 0, false);
        try {
          this.fchmodBase(fd, modeNum);
        } finally {
          this.closeSync(fd);
        }
      };
      Volume2.prototype.lchmodSync = function(path2, mode) {
        var modeNum = modeToNumber(mode);
        var filename = pathToFilename(path2);
        this.lchmodBase(filename, modeNum);
      };
      Volume2.prototype.lchmod = function(path2, mode, callback) {
        var modeNum = modeToNumber(mode);
        var filename = pathToFilename(path2);
        this.wrapAsync(this.lchmodBase, [filename, modeNum], callback);
      };
      Volume2.prototype.fchownBase = function(fd, uid, gid) {
        this.getFileByFdOrThrow(fd, "fchown").chown(uid, gid);
      };
      Volume2.prototype.fchownSync = function(fd, uid, gid) {
        validateUid(uid);
        validateGid(gid);
        this.fchownBase(fd, uid, gid);
      };
      Volume2.prototype.fchown = function(fd, uid, gid, callback) {
        validateUid(uid);
        validateGid(gid);
        this.wrapAsync(this.fchownBase, [fd, uid, gid], callback);
      };
      Volume2.prototype.chownBase = function(filename, uid, gid) {
        var link3 = this.getResolvedLinkOrThrow(filename, "chown");
        var node = link3.getNode();
        node.chown(uid, gid);
      };
      Volume2.prototype.chownSync = function(path2, uid, gid) {
        validateUid(uid);
        validateGid(gid);
        this.chownBase(pathToFilename(path2), uid, gid);
      };
      Volume2.prototype.chown = function(path2, uid, gid, callback) {
        validateUid(uid);
        validateGid(gid);
        this.wrapAsync(this.chownBase, [pathToFilename(path2), uid, gid], callback);
      };
      Volume2.prototype.lchownBase = function(filename, uid, gid) {
        this.getLinkOrThrow(filename, "lchown").getNode().chown(uid, gid);
      };
      Volume2.prototype.lchownSync = function(path2, uid, gid) {
        validateUid(uid);
        validateGid(gid);
        this.lchownBase(pathToFilename(path2), uid, gid);
      };
      Volume2.prototype.lchown = function(path2, uid, gid, callback) {
        validateUid(uid);
        validateGid(gid);
        this.wrapAsync(this.lchownBase, [pathToFilename(path2), uid, gid], callback);
      };
      Volume2.prototype.watchFile = function(path2, a5, b6) {
        var filename = pathToFilename(path2);
        var options = a5;
        var listener = b6;
        if (typeof options === "function") {
          listener = a5;
          options = null;
        }
        if (typeof listener !== "function") {
          throw Error('"watchFile()" requires a listener function');
        }
        var interval = 5007;
        var persistent = true;
        if (options && typeof options === "object") {
          if (typeof options.interval === "number") interval = options.interval;
          if (typeof options.persistent === "boolean") persistent = options.persistent;
        }
        var watcher = this.statWatchers[filename];
        if (!watcher) {
          watcher = new this.StatWatcher();
          watcher.start(filename, persistent, interval);
          this.statWatchers[filename] = watcher;
        }
        watcher.addListener("change", listener);
        return watcher;
      };
      Volume2.prototype.unwatchFile = function(path2, listener) {
        var filename = pathToFilename(path2);
        var watcher = this.statWatchers[filename];
        if (!watcher) return;
        if (typeof listener === "function") {
          watcher.removeListener("change", listener);
        } else {
          watcher.removeAllListeners("change");
        }
        if (watcher.listenerCount("change") === 0) {
          watcher.stop();
          delete this.statWatchers[filename];
        }
      };
      Volume2.prototype.createReadStream = function(path2, options) {
        return new this.ReadStream(path2, options);
      };
      Volume2.prototype.createWriteStream = function(path2, options) {
        return new this.WriteStream(path2, options);
      };
      Volume2.prototype.watch = function(path2, options, listener) {
        var filename = pathToFilename(path2);
        var givenOptions = options;
        if (typeof options === "function") {
          listener = options;
          givenOptions = null;
        }
        var _a2 = getDefaultOpts(givenOptions), persistent = _a2.persistent, recursive = _a2.recursive, encoding = _a2.encoding;
        if (persistent === void 0) persistent = true;
        if (recursive === void 0) recursive = false;
        var watcher = new this.FSWatcher();
        watcher.start(filename, persistent, recursive, encoding);
        if (listener) {
          watcher.addListener("change", listener);
        }
        return watcher;
      };
      Volume2.fd = 2147483647;
      return Volume2;
    }()
  );
  exports$44.Volume = Volume;
  function emitStop(self2) {
    self2.emit("stop");
  }
  var StatWatcher = (
    /** @class */
    function(_super) {
      __extends(StatWatcher2, _super);
      function StatWatcher2(vol2) {
        var _this = _super.call(this) || this;
        _this.onInterval = function() {
          try {
            var stats = _this.vol.statSync(_this.filename);
            if (_this.hasChanged(stats)) {
              _this.emit("change", stats, _this.prev);
              _this.prev = stats;
            }
          } finally {
            _this.loop();
          }
        };
        _this.vol = vol2;
        return _this;
      }
      StatWatcher2.prototype.loop = function() {
        this.timeoutRef = this.setTimeout(this.onInterval, this.interval);
      };
      StatWatcher2.prototype.hasChanged = function(stats) {
        if (stats.mtimeMs > this.prev.mtimeMs) return true;
        if (stats.nlink !== this.prev.nlink) return true;
        return false;
      };
      StatWatcher2.prototype.start = function(path2, persistent, interval) {
        if (persistent === void 0) {
          persistent = true;
        }
        if (interval === void 0) {
          interval = 5007;
        }
        this.filename = pathToFilename(path2);
        this.setTimeout = persistent ? setTimeout.bind(typeof globalThis !== "undefined" ? globalThis : _global5) : setTimeoutUnref_1.default;
        this.interval = interval;
        this.prev = this.vol.statSync(this.filename);
        this.loop();
      };
      StatWatcher2.prototype.stop = function() {
        clearTimeout(this.timeoutRef);
        process_1.default.nextTick(emitStop, this);
      };
      return StatWatcher2;
    }(events_1.EventEmitter)
  );
  exports$44.StatWatcher = StatWatcher;
  var pool;
  function allocNewPool(poolSize) {
    pool = (0, buffer_1.bufferAllocUnsafe)(poolSize);
    pool.used = 0;
  }
  util.inherits(FsReadStream, stream_1.Readable);
  exports$44.ReadStream = FsReadStream;
  function FsReadStream(vol2, path2, options) {
    if (!(this instanceof FsReadStream)) return new FsReadStream(vol2, path2, options);
    this._vol = vol2;
    options = Object.assign({}, getOptions(options, {}));
    if (options.highWaterMark === void 0) options.highWaterMark = 64 * 1024;
    stream_1.Readable.call(this, options);
    this.path = pathToFilename(path2);
    this.fd = options.fd === void 0 ? null : options.fd;
    this.flags = options.flags === void 0 ? "r" : options.flags;
    this.mode = options.mode === void 0 ? 438 : options.mode;
    this.start = options.start;
    this.end = options.end;
    this.autoClose = options.autoClose === void 0 ? true : options.autoClose;
    this.pos = void 0;
    this.bytesRead = 0;
    if (this.start !== void 0) {
      if (typeof this.start !== "number") {
        throw new TypeError('"start" option must be a Number');
      }
      if (this.end === void 0) {
        this.end = Infinity;
      } else if (typeof this.end !== "number") {
        throw new TypeError('"end" option must be a Number');
      }
      if (this.start > this.end) {
        throw new Error('"start" option must be <= "end" option');
      }
      this.pos = this.start;
    }
    if (typeof this.fd !== "number") this.open();
    this.on("end", function() {
      if (this.autoClose) {
        if (this.destroy) this.destroy();
      }
    });
  }
  FsReadStream.prototype.open = function() {
    var self2 = this;
    this._vol.open(this.path, this.flags, this.mode, function(er, fd) {
      if (er) {
        if (self2.autoClose) {
          if (self2.destroy) self2.destroy();
        }
        self2.emit("error", er);
        return;
      }
      self2.fd = fd;
      self2.emit("open", fd);
      self2.read();
    });
  };
  FsReadStream.prototype._read = function(n6) {
    if (typeof this.fd !== "number") {
      return this.once("open", function() {
        this._read(n6);
      });
    }
    if (this.destroyed) return;
    if (!pool || pool.length - pool.used < kMinPoolSpace) {
      allocNewPool(this._readableState.highWaterMark);
    }
    var thisPool = pool;
    var toRead = Math.min(pool.length - pool.used, n6);
    var start = pool.used;
    if (this.pos !== void 0) toRead = Math.min(this.end - this.pos + 1, toRead);
    if (toRead <= 0) return this.push(null);
    var self2 = this;
    this._vol.read(this.fd, pool, pool.used, toRead, this.pos, onread);
    if (this.pos !== void 0) this.pos += toRead;
    pool.used += toRead;
    function onread(er, bytesRead) {
      if (er) {
        if (self2.autoClose && self2.destroy) {
          self2.destroy();
        }
        self2.emit("error", er);
      } else {
        var b6 = null;
        if (bytesRead > 0) {
          self2.bytesRead += bytesRead;
          b6 = thisPool.slice(start, start + bytesRead);
        }
        self2.push(b6);
      }
    }
  };
  FsReadStream.prototype._destroy = function(err, cb) {
    this.close(function(err2) {
      cb(err || err2);
    });
  };
  FsReadStream.prototype.close = function(cb) {
    var _this = this;
    var _a2;
    if (cb) this.once("close", cb);
    if (this.closed || typeof this.fd !== "number") {
      if (typeof this.fd !== "number") {
        this.once("open", closeOnOpen);
        return;
      }
      return process_1.default.nextTick(function() {
        return _this.emit("close");
      });
    }
    if (typeof ((_a2 = this._readableState) === null || _a2 === void 0 ? void 0 : _a2.closed) === "boolean") {
      this._readableState.closed = true;
    } else {
      this.closed = true;
    }
    this._vol.close(this.fd, function(er) {
      if (er) _this.emit("error", er);
      else _this.emit("close");
    });
    this.fd = null;
  };
  function closeOnOpen(fd) {
    this.close();
  }
  util.inherits(FsWriteStream, stream_1.Writable);
  exports$44.WriteStream = FsWriteStream;
  function FsWriteStream(vol2, path2, options) {
    if (!(this instanceof FsWriteStream)) return new FsWriteStream(vol2, path2, options);
    this._vol = vol2;
    options = Object.assign({}, getOptions(options, {}));
    stream_1.Writable.call(this, options);
    this.path = pathToFilename(path2);
    this.fd = options.fd === void 0 ? null : options.fd;
    this.flags = options.flags === void 0 ? "w" : options.flags;
    this.mode = options.mode === void 0 ? 438 : options.mode;
    this.start = options.start;
    this.autoClose = options.autoClose === void 0 ? true : !!options.autoClose;
    this.pos = void 0;
    this.bytesWritten = 0;
    if (this.start !== void 0) {
      if (typeof this.start !== "number") {
        throw new TypeError('"start" option must be a Number');
      }
      if (this.start < 0) {
        throw new Error('"start" must be >= zero');
      }
      this.pos = this.start;
    }
    if (options.encoding) this.setDefaultEncoding(options.encoding);
    if (typeof this.fd !== "number") this.open();
    this.once("finish", function() {
      if (this.autoClose) {
        this.close();
      }
    });
  }
  FsWriteStream.prototype.open = function() {
    this._vol.open(this.path, this.flags, this.mode, function(er, fd) {
      if (er) {
        if (this.autoClose && this.destroy) {
          this.destroy();
        }
        this.emit("error", er);
        return;
      }
      this.fd = fd;
      this.emit("open", fd);
    }.bind(this));
  };
  FsWriteStream.prototype._write = function(data, encoding, cb) {
    if (!(data instanceof buffer_1.Buffer || data instanceof Uint8Array)) return this.emit("error", new Error("Invalid data"));
    if (typeof this.fd !== "number") {
      return this.once("open", function() {
        this._write(data, encoding, cb);
      });
    }
    var self2 = this;
    this._vol.write(this.fd, data, 0, data.length, this.pos, function(er, bytes) {
      if (er) {
        if (self2.autoClose && self2.destroy) {
          self2.destroy();
        }
        return cb(er);
      }
      self2.bytesWritten += bytes;
      cb();
    });
    if (this.pos !== void 0) this.pos += data.length;
  };
  FsWriteStream.prototype._writev = function(data, cb) {
    if (typeof this.fd !== "number") {
      return this.once("open", function() {
        this._writev(data, cb);
      });
    }
    var self2 = this;
    var len = data.length;
    var chunks = new Array(len);
    var size = 0;
    for (var i5 = 0; i5 < len; i5++) {
      var chunk = data[i5].chunk;
      chunks[i5] = chunk;
      size += chunk.length;
    }
    var buf = buffer_1.Buffer.concat(chunks);
    this._vol.write(this.fd, buf, 0, buf.length, this.pos, function(er, bytes) {
      if (er) {
        if (self2.destroy) self2.destroy();
        return cb(er);
      }
      self2.bytesWritten += bytes;
      cb();
    });
    if (this.pos !== void 0) this.pos += size;
  };
  FsWriteStream.prototype.close = function(cb) {
    var _this = this;
    var _a2;
    if (cb) this.once("close", cb);
    if (this.closed || typeof this.fd !== "number") {
      if (typeof this.fd !== "number") {
        this.once("open", closeOnOpen);
        return;
      }
      return process_1.default.nextTick(function() {
        return _this.emit("close");
      });
    }
    if (typeof ((_a2 = this._writableState) === null || _a2 === void 0 ? void 0 : _a2.closed) === "boolean") {
      this._writableState.closed = true;
    } else {
      this.closed = true;
    }
    this._vol.close(this.fd, function(er) {
      if (er) _this.emit("error", er);
      else _this.emit("close");
    });
    this.fd = null;
  };
  FsWriteStream.prototype._destroy = FsReadStream.prototype._destroy;
  FsWriteStream.prototype.destroySoon = FsWriteStream.prototype.end;
  var FSWatcher = (
    /** @class */
    function(_super) {
      __extends(FSWatcher2, _super);
      function FSWatcher2(vol2) {
        var _this = _super.call(this) || this;
        _this._filename = "";
        _this._filenameEncoded = "";
        _this._recursive = false;
        _this._encoding = encoding_1.ENCODING_UTF8;
        _this._listenerRemovers = /* @__PURE__ */ new Map();
        _this._onParentChild = function(link3) {
          if (link3.getName() === _this._getName()) {
            _this._emit("rename");
          }
        };
        _this._emit = function(type) {
          _this.emit("change", type, _this._filenameEncoded);
        };
        _this._persist = function() {
          _this._timer = setTimeout(_this._persist, 1e6);
        };
        _this._vol = vol2;
        return _this;
      }
      FSWatcher2.prototype._getName = function() {
        return this._steps[this._steps.length - 1];
      };
      FSWatcher2.prototype.start = function(path2, persistent, recursive, encoding) {
        var _this = this;
        if (persistent === void 0) {
          persistent = true;
        }
        if (recursive === void 0) {
          recursive = false;
        }
        if (encoding === void 0) {
          encoding = encoding_1.ENCODING_UTF8;
        }
        this._filename = pathToFilename(path2);
        this._steps = filenameToSteps(this._filename);
        this._filenameEncoded = (0, encoding_1.strToEncoding)(this._filename);
        this._recursive = recursive;
        this._encoding = encoding;
        try {
          this._link = this._vol.getLinkOrThrow(this._filename, "FSWatcher");
        } catch (err) {
          var error = new Error("watch ".concat(this._filename, " ").concat(err.code));
          error.code = err.code;
          error.errno = err.code;
          throw error;
        }
        var watchLinkNodeChanged = function(link3) {
          var _a2;
          var filepath = link3.getPath();
          var node = link3.getNode();
          var onNodeChange = function() {
            var filename = relative2(_this._filename, filepath);
            if (!filename) {
              filename = _this._getName();
            }
            return _this.emit("change", "change", filename);
          };
          node.on("change", onNodeChange);
          var removers = (_a2 = _this._listenerRemovers.get(node.ino)) !== null && _a2 !== void 0 ? _a2 : [];
          removers.push(function() {
            return node.removeListener("change", onNodeChange);
          });
          _this._listenerRemovers.set(node.ino, removers);
        };
        var watchLinkChildrenChanged = function(link3) {
          var _a2;
          var node = link3.getNode();
          var onLinkChildAdd = function(l5) {
            _this.emit("change", "rename", relative2(_this._filename, l5.getPath()));
            setTimeout(function() {
              watchLinkNodeChanged(l5);
              watchLinkChildrenChanged(l5);
            });
          };
          var onLinkChildDelete = function(l5) {
            var removeLinkNodeListeners = function(curLink) {
              var ino = curLink.getNode().ino;
              var removers2 = _this._listenerRemovers.get(ino);
              if (removers2) {
                removers2.forEach(function(r6) {
                  return r6();
                });
                _this._listenerRemovers.delete(ino);
              }
              Object.values(curLink.children).forEach(function(childLink) {
                if (childLink) {
                  removeLinkNodeListeners(childLink);
                }
              });
            };
            removeLinkNodeListeners(l5);
            _this.emit("change", "rename", relative2(_this._filename, l5.getPath()));
          };
          Object.entries(link3.children).forEach(function(_a3) {
            var name2 = _a3[0], childLink = _a3[1];
            if (childLink && name2 !== "." && name2 !== "..") {
              watchLinkNodeChanged(childLink);
            }
          });
          link3.on("child:add", onLinkChildAdd);
          link3.on("child:delete", onLinkChildDelete);
          var removers = (_a2 = _this._listenerRemovers.get(node.ino)) !== null && _a2 !== void 0 ? _a2 : [];
          removers.push(function() {
            link3.removeListener("child:add", onLinkChildAdd);
            link3.removeListener("child:delete", onLinkChildDelete);
          });
          if (recursive) {
            Object.entries(link3.children).forEach(function(_a3) {
              var name2 = _a3[0], childLink = _a3[1];
              if (childLink && name2 !== "." && name2 !== "..") {
                watchLinkChildrenChanged(childLink);
              }
            });
          }
        };
        watchLinkNodeChanged(this._link);
        watchLinkChildrenChanged(this._link);
        var parent = this._link.parent;
        if (parent) {
          parent.setMaxListeners(parent.getMaxListeners() + 1);
          parent.on("child:delete", this._onParentChild);
        }
        if (persistent) this._persist();
      };
      FSWatcher2.prototype.close = function() {
        clearTimeout(this._timer);
        this._listenerRemovers.forEach(function(removers) {
          removers.forEach(function(r6) {
            return r6();
          });
        });
        this._listenerRemovers.clear();
        var parent = this._link.parent;
        if (parent) {
          parent.removeListener("child:delete", this._onParentChild);
        }
      };
      return FSWatcher2;
    }(events_1.EventEmitter)
  );
  exports$44.FSWatcher = FSWatcher;
  return exports$44;
}
var exports$34 = {};
var _dewExec$16 = false;
function dew$16() {
  if (_dewExec$16) return exports$34;
  _dewExec$16 = true;
  Object.defineProperty(exports$34, "__esModule", {
    value: true
  });
  exports$34.fsSyncMethods = exports$34.fsProps = exports$34.fsAsyncMethods = void 0;
  exports$34.fsProps = ["constants", "F_OK", "R_OK", "W_OK", "X_OK", "Stats"];
  exports$34.fsSyncMethods = ["renameSync", "ftruncateSync", "truncateSync", "chownSync", "fchownSync", "lchownSync", "chmodSync", "fchmodSync", "lchmodSync", "statSync", "lstatSync", "fstatSync", "linkSync", "symlinkSync", "readlinkSync", "realpathSync", "unlinkSync", "rmdirSync", "mkdirSync", "mkdirpSync", "readdirSync", "closeSync", "openSync", "utimesSync", "futimesSync", "fsyncSync", "writeSync", "readSync", "readFileSync", "writeFileSync", "appendFileSync", "existsSync", "accessSync", "fdatasyncSync", "mkdtempSync", "copyFileSync", "rmSync", "createReadStream", "createWriteStream"];
  exports$34.fsAsyncMethods = ["rename", "ftruncate", "truncate", "chown", "fchown", "lchown", "chmod", "fchmod", "lchmod", "stat", "lstat", "fstat", "link", "symlink", "readlink", "realpath", "unlink", "rmdir", "mkdir", "mkdirp", "readdir", "close", "open", "utimes", "futimes", "fsync", "write", "read", "readFile", "writeFile", "appendFile", "exists", "access", "fdatasync", "mkdtemp", "copyFile", "rm", "watchFile", "unwatchFile", "watch"];
  return exports$34;
}
var exports$26 = {};
var _dewExec10 = false;
function dew10() {
  if (_dewExec10) return exports$26;
  _dewExec10 = true;
  var __assign = exports$26 && exports$26.__assign || function() {
    __assign = Object.assign || function(t6) {
      for (var s5, i5 = 1, n6 = arguments.length; i5 < n6; i5++) {
        s5 = arguments[i5];
        for (var p5 in s5) if (Object.prototype.hasOwnProperty.call(s5, p5)) t6[p5] = s5[p5];
      }
      return t6;
    };
    return __assign.apply(this, arguments);
  };
  Object.defineProperty(exports$26, "__esModule", {
    value: true
  });
  exports$26.fs = exports$26.createFsFromVolume = exports$26.vol = exports$26.Volume = void 0;
  var Stats_1 = dew$d3();
  var Dirent_1 = dew$93();
  var volume_1 = dew$25();
  var _a = dew$16(), fsSyncMethods = _a.fsSyncMethods, fsAsyncMethods = _a.fsAsyncMethods;
  var constants_1 = dew$f3();
  var F_OK2 = constants_1.constants.F_OK, R_OK2 = constants_1.constants.R_OK, W_OK2 = constants_1.constants.W_OK, X_OK2 = constants_1.constants.X_OK;
  exports$26.Volume = volume_1.Volume;
  exports$26.vol = new volume_1.Volume();
  function createFsFromVolume2(vol2) {
    var fs2 = {
      F_OK: F_OK2,
      R_OK: R_OK2,
      W_OK: W_OK2,
      X_OK: X_OK2,
      constants: constants_1.constants,
      Stats: Stats_1.default,
      Dirent: Dirent_1.default
    };
    for (var _i = 0, fsSyncMethods_1 = fsSyncMethods; _i < fsSyncMethods_1.length; _i++) {
      var method = fsSyncMethods_1[_i];
      if (typeof vol2[method] === "function") fs2[method] = vol2[method].bind(vol2);
    }
    for (var _a2 = 0, fsAsyncMethods_1 = fsAsyncMethods; _a2 < fsAsyncMethods_1.length; _a2++) {
      var method = fsAsyncMethods_1[_a2];
      if (typeof vol2[method] === "function") fs2[method] = vol2[method].bind(vol2);
    }
    fs2.StatWatcher = vol2.StatWatcher;
    fs2.FSWatcher = vol2.FSWatcher;
    fs2.WriteStream = vol2.WriteStream;
    fs2.ReadStream = vol2.ReadStream;
    fs2.promises = vol2.promises;
    fs2._toUnixTimestamp = volume_1.toUnixTimestamp;
    return fs2;
  }
  exports$26.createFsFromVolume = createFsFromVolume2;
  exports$26.fs = createFsFromVolume2(exports$26.vol);
  exports$26 = __assign(__assign({}, exports$26), exports$26.fs);
  exports$26.semantic = true;
  return exports$26;
}
var exports$19 = dew10();
exports$19["__esModule"];
exports$19["fs"];
exports$19["createFsFromVolume"];
exports$19["vol"];
exports$19["Volume"];
exports$19["semantic"];
var exports11 = dew$25();
exports11["__esModule"];
exports11["FSWatcher"];
exports11["StatWatcher"];
exports11["Volume"];
exports11["toUnixTimestamp"];
exports11["bufferToEncoding"];
exports11["dataToBuffer"];
exports11["dataToStr"];
exports11["pathToSteps"];
exports11["filenameToSteps"];
exports11["pathToFilename"];
exports11["flagsToNumber"];
exports11["FLAGS"];
exports11["ReadStream"];
exports11["WriteStream"];
var { vol, createFsFromVolume } = exports$19;
function unimplemented3(name2) {
  throw new Error(`Node.js fs ${name2} is not supported by JSPM core in the browser`);
}
vol.fromNestedJSON({
  "/dev": { stdin: "", stdout: "", stderr: "" },
  "/usr/bin": {},
  "/home": {},
  "/tmp": {}
});
vol.releasedFds = [2, 1, 0];
vol.openSync("/dev/stdin", "w");
vol.openSync("/dev/stdout", "r");
vol.openSync("/dev/stderr", "r");
watchStdo("/dev/stdout", 1, console.log);
watchStdo("/dev/stderr", 2, console.error);
function watchStdo(path2, fd, listener) {
  let oldSize = 0;
  const decoder = new TextDecoder();
  vol.watch(path2, "utf8", () => {
    const { size } = vol.fstatSync(fd);
    const buf = Buffer2.alloc(size - oldSize);
    vol.readSync(fd, buf, 0, buf.length, oldSize);
    oldSize = size;
    listener(decoder.decode(buf, { stream: true }));
  });
}
var fs = createFsFromVolume(vol);
fs.opendir = () => unimplemented3("opendir");
fs.opendirSync = () => unimplemented3("opendirSync");
fs.promises.opendir = () => unimplemented3("promises.opendir");
fs.cp = () => unimplemented3("cp");
fs.cpSync = () => unimplemented3("cpSync");
fs.promises.cp = () => unimplemented3("promises.cp");
fs.readv = () => unimplemented3("readv");
fs.readvSync = () => unimplemented3("readvSync");
fs.rm = () => unimplemented3("rm");
fs.rmSync = () => unimplemented3("rmSync");
fs.promises.rm = () => unimplemented3("promises.rm");
fs.Dir = () => unimplemented3("Dir");
fs.promises.watch = () => unimplemented3("promises.watch");
fs.FileReadStream = fs.ReadStream;
fs.FileWriteStream = fs.WriteStream;
function handleFsUrl(url, isSync) {
  if (url.protocol === "file:")
    return fileURLToPath2(url);
  if (url.protocol === "https:" || url.protocol === "http:") {
    const path2 = "\\\\url\\" + url.href.replaceAll(/\//g, "\\\\");
    if (existsSync(path2))
      return path2;
    if (isSync)
      throw new Error(`Cannot sync request URL ${url} via FS. JSPM FS support for network URLs requires using async FS methods or priming the MemFS cache first with an async request before a sync request.`);
    return (async () => {
      const res = await fetch(url);
      if (!res.ok)
        throw new Error(`Unable to fetch ${url.href}, ${res.status}`);
      const buf = await res.arrayBuffer();
      writeFileSync(path2, Buffer2.from(buf));
      return path2;
    })();
  }
  throw new Error("URL " + url + " not supported in JSPM FS implementation.");
}
function wrapFsSync(fn) {
  return function(path2, ...args) {
    if (path2 instanceof URL)
      return fn(handleFsUrl(path2, true), ...args);
    return fn(path2, ...args);
  };
}
function wrapFsPromise(fn) {
  return async function(path2, ...args) {
    if (path2 instanceof URL)
      return fn(await handleFsUrl(path2), ...args);
    return fn(path2, ...args);
  };
}
function wrapFsCallback(fn) {
  return function(path2, ...args) {
    const cb = args[args.length - 1];
    if (path2 instanceof URL && typeof cb === "function") {
      handleFsUrl(path2).then((path3) => {
        fn(path3, ...args);
      }, cb);
    } else {
      fn(path2, ...args);
    }
  };
}
fs.promises.readFile = wrapFsPromise(fs.promises.readFile);
fs.readFile = wrapFsCallback(fs.readFile);
fs.readFileSync = wrapFsSync(fs.readFileSync);
var {
  appendFile,
  appendFileSync,
  access,
  accessSync,
  chown,
  chownSync,
  chmod,
  chmodSync,
  close,
  closeSync,
  copyFile,
  copyFileSync,
  cp,
  cpSync,
  createReadStream,
  createWriteStream,
  exists,
  existsSync,
  fchown,
  fchownSync,
  fchmod,
  fchmodSync,
  fdatasync,
  fdatasyncSync,
  fstat,
  fstatSync,
  fsync,
  fsyncSync,
  ftruncate,
  ftruncateSync,
  futimes,
  futimesSync,
  lchown,
  lchownSync,
  lchmod,
  lchmodSync,
  link,
  linkSync,
  lstat,
  lstatSync,
  mkdir,
  mkdirSync,
  mkdtemp,
  mkdtempSync,
  open,
  openSync,
  opendir,
  opendirSync,
  readdir,
  readdirSync,
  read,
  readSync,
  readv,
  readvSync,
  readFile,
  readFileSync,
  readlink,
  readlinkSync,
  realpath,
  realpathSync,
  rename,
  renameSync,
  rm,
  rmSync,
  rmdir,
  rmdirSync,
  stat,
  statSync,
  symlink,
  symlinkSync,
  truncate,
  truncateSync,
  unwatchFile,
  unlink,
  unlinkSync,
  utimes,
  utimesSync,
  watch,
  watchFile,
  writeFile,
  writeFileSync,
  write,
  writeSync,
  writev,
  writevSync,
  Dir,
  Dirent,
  Stats,
  ReadStream,
  WriteStream,
  FileReadStream,
  FileWriteStream,
  _toUnixTimestamp,
  constants: { F_OK, R_OK, W_OK, X_OK },
  constants,
  promises
} = fs;

// node_modules/@jspm/core/nodelibs/browser/fs/promises.js
var {
  access: access2,
  copyFile: copyFile2,
  cp: cp2,
  open: open2,
  opendir: opendir2,
  rename: rename2,
  truncate: truncate2,
  rm: rm2,
  rmdir: rmdir2,
  mkdir: mkdir2,
  readdir: readdir2,
  readlink: readlink2,
  symlink: symlink2,
  lstat: lstat2,
  stat: stat2,
  link: link2,
  unlink: unlink2,
  chmod: chmod2,
  lchmod: lchmod2,
  lchown: lchown2,
  chown: chown2,
  utimes: utimes2,
  realpath: realpath2,
  mkdtemp: mkdtemp2,
  writeFile: writeFile2,
  appendFile: appendFile2,
  readFile: readFile2,
  watch: watch2
} = promises;

// node_modules/@jspm/core/nodelibs/browser/path.js
var _makeLong = exports9._makeLong;
var basename = exports9.basename;
var delimiter = exports9.delimiter;
var dirname = exports9.dirname;
var extname = exports9.extname;
var format2 = exports9.format;
var isAbsolute = exports9.isAbsolute;
var join = exports9.join;
var normalize = exports9.normalize;
var parse2 = exports9.parse;
var posix = exports9.posix;
var relative = exports9.relative;
var resolve2 = exports9.resolve;
var sep = exports9.sep;
var win32 = exports9.win32;

// src/core/storage.js
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
var LocalStorage = class {
  get(key, defaultValue = null) {
    const data = localStorage.getItem(key);
    if (data === void 0) return defaultValue;
    let value;
    try {
      value = JSON.parse(data);
    } catch (err) {
      console.error("error reading storage key:", key);
      value = null;
    }
    if (value === void 0) return defaultValue;
    return value || defaultValue;
  }
  set(key, value) {
    if (value === void 0 || value === null) {
      localStorage.removeItem(key);
    } else {
      const data = JSON.stringify(value);
      localStorage.setItem(key, data);
    }
  }
  remove(key) {
    localStorage.removeItem(key);
  }
};
var NodeStorage = class {
  isNodeStorage = true;
  _cache = null;
  _storageFilePath = null;
  _pendingWritePromise = Promise.resolve();
  constructor() {
    if (isBrowser) {
      throw new Error("NodeStorage cannot be constructed in a browser environment.");
    }
    this._initializePath();
  }
  _initializePath() {
    if (this._storageFilePath) return;
    try {
      const dirname2 = exports9.dirname(fileURLToPath2(import.meta.url));
      const rootDir = exports9.join(dirname2, "../");
      this._storageFilePath = exports9.join(rootDir, "local.json");
    } catch (err) {
      console.error("Failed to calculate NodeStorage path:", err);
      this._storageFilePath = null;
    }
  }
  // Use statically imported fs
  async _readData() {
    this._initializePath();
    if (!this._storageFilePath) return {};
    if (this._cache !== null) return this._cache;
    try {
      const data = await promises.readFile(this._storageFilePath, "utf-8");
      this._cache = JSON.parse(data);
    } catch (error) {
      if (error.code === "ENOENT") {
        this._cache = {};
      } else {
        console.error(
          /*...*/
        );
        this._cache = {};
      }
    }
    return this._cache;
  }
  // Use statically imported fs
  async _writeData(data) {
    this._initializePath();
    if (!this._storageFilePath) {
      return;
    }
    try {
      this._cache = data;
      const jsonData = JSON.stringify(data, null, 2);
      this._pendingWritePromise = this._pendingWritePromise.then(async () => {
        await promises.writeFile(this._storageFilePath, jsonData);
      }).catch((error) => {
      });
    } catch (error) {
    }
  }
  async get(key, defaultValue = null) {
    this._initializePath();
    const data = await this._readData();
    return data.hasOwnProperty(key) ? data[key] : defaultValue;
  }
  async set(key, value) {
    this._initializePath();
    const data = await this._readData();
    let changed = false;
    if (value === void 0 || value === null) {
      if (data.hasOwnProperty(key)) {
        delete data[key];
        changed = true;
      }
    } else {
      if (data[key] !== value) {
        data[key] = value;
        changed = true;
      }
    }
    if (changed) {
      this._writeData(data);
    }
  }
  async remove(key) {
    await this.set(key, null);
  }
  // Method to await the last pending write
  async flushWrites() {
    console.log("[NodeStorage flushWrites] Awaiting pending write operations...");
    await this._pendingWritePromise;
    console.log("[NodeStorage flushWrites] Write operations flushed.");
  }
};
var storageInstance;
if (isBrowser) {
  storageInstance = new LocalStorage();
} else {
  storageInstance = new NodeStorage();
}
var storage = storageInstance;

// src/core/utils-client.js
async function hashFile(file) {
  const buf = await file.arrayBuffer();
  const hashBuf = await crypto.subtle.digest("SHA-256", buf);
  const hash = Array.from(new Uint8Array(hashBuf)).map((b6) => b6.toString(16).padStart(2, "0")).join("");
  return hash;
}

// src/core/systems/ClientNetwork.js
var ClientNetwork = class extends System {
  constructor(world2) {
    super(world2);
    this.ids = -1;
    this.ws = null;
    this.apiUrl = null;
    this.id = null;
    this.isClient = true;
    this.queue = [];
  }
  init({ wsUrl, initialAuthToken }) {
    const authToken = initialAuthToken;
    const connectionUrl = authToken && typeof authToken === "string" ? `${wsUrl}?authToken=${encodeURIComponent(authToken)}` : wsUrl;
    this.ws = new WebSocket(connectionUrl);
    this.ws.binaryType = "arraybuffer";
    this.ws.addEventListener("message", this.onPacket);
    this.ws.addEventListener("close", this.onClose);
  }
  preFixedUpdate() {
    this.flush();
  }
  send(name2, data) {
    const packet = writePacket(name2, data);
    this.ws.send(packet);
  }
  async upload(file) {
    {
      const hash = await hashFile(file);
      const ext = file.name.split(".").pop().toLowerCase();
      const filename = `${hash}.${ext}`;
      const url2 = `${this.apiUrl}/upload-check?filename=${filename}`;
      const resp = await fetch(url2);
      const data = await resp.json();
      if (data.exists) return;
    }
    const form = new FormData();
    form.append("file", file);
    const url = `${this.apiUrl}/upload`;
    await fetch(url, {
      method: "POST",
      body: form
    });
  }
  enqueue(method, data) {
    this.queue.push([method, data]);
  }
  flush() {
    while (this.queue.length) {
      try {
        const [method, data] = this.queue.shift();
        this[method]?.(data);
      } catch (err) {
        console.error(`[ClientNetwork flush] Error executing method: ${err}`);
      }
    }
  }
  getTime() {
    return (performance.now() + this.serverTimeOffset) / 1e3;
  }
  onPacket = (e7) => {
    const [method, data] = readPacket(e7.data);
    this.enqueue(method, data);
  };
  onSnapshot(data) {
    this.id = data.id;
    this.serverTimeOffset = data.serverTime - performance.now();
    this.apiUrl = data.apiUrl;
    this.maxUploadSize = data.maxUploadSize;
    this.world.assetsUrl = data.assetsUrl;
    this.world.settings?.deserialize(data.settings);
    this.world.chat?.deserialize(data.chat);
    this.world.blueprints?.deserialize(data.blueprints);
    this.world.entities?.deserialize(data.entities);
    if (this.world.livekit?.deserialize) {
      this.world.livekit?.deserialize(data.livekit);
    }
    try {
      storage.set("authToken", data.authToken);
    } catch (e7) {
      console.error("[ClientNetwork onSnapshot] Error calling storage.set:", e7);
    }
    if (this.world.loader) {
      if (data.settings.model) {
        this.world.loader.preload("model", data.settings.model.url);
      } else if (this.world.environment?.base?.model) {
        this.world.loader.preload("model", this.world.environment.base.model);
      }
      if (data.settings.avatar) {
        this.world.loader.preload("avatar", data.settings.avatar.url);
      }
      for (const item of data.blueprints) {
        if (item.preload) {
          if (item.model) {
            const type = item.model.endsWith(".vrm") ? "avatar" : "model";
            this.world.loader.preload(type, item.model);
          }
          if (item.script) {
            this.world.loader.preload("script", item.script);
          }
          for (const value of Object.values(item.props || {})) {
            if (value === void 0 || value === null || !value?.url || !value?.type) continue;
            this.world.loader.preload(value.type, value.url);
          }
        }
      }
      for (const url of emoteUrls) {
        this.world.loader.preload("emote", url);
      }
      for (const item of data.entities) {
        if (item.type === "player" && item.owner === this.id) {
          const url = item.sessionAvatar || item.avatar;
          if (url) {
            this.world.loader.preload("avatar", url);
          }
        }
      }
      this.world.loader.execPreload();
    } else {
      this.world.emit("ready", true);
    }
  }
  onSettingsModified = (data) => {
    this.world.settings.set(data.key, data.value);
  };
  onChatAdded = (msg) => {
    this.world.chat.add(msg, false);
  };
  onChatCleared = () => {
    this.world.chat.clear();
  };
  onBlueprintAdded = (blueprint) => {
    this.world.blueprints.add(blueprint);
  };
  onBlueprintModified = (change) => {
    this.world.blueprints.modify(change);
  };
  onEntityAdded = (data) => {
    this.world.entities.add(data);
  };
  onEntityModified = (data) => {
    const entity = this.world.entities.get(data.id);
    if (!entity) return console.error("onEntityModified: no entity found", data);
    entity.modify(data);
  };
  onEntityEvent = (event) => {
    const [id, version4, name2, data] = event;
    const entity = this.world.entities.get(id);
    entity?.onEvent(version4, name2, data);
  };
  onEntityRemoved = (id) => {
    this.world.entities.remove(id);
  };
  onPlayerTeleport = (data) => {
    this.world.entities.player?.teleport(data);
  };
  onPlayerPush = (data) => {
    this.world.entities.player?.push(data.force);
  };
  onPlayerSessionAvatar = (data) => {
    this.world.entities.player?.setSessionAvatar(data.avatar);
  };
  onPong = (time) => {
    this.world.stats?.onPong(time);
  };
  onKick = (code) => {
    this.world.emit("kick", code);
  };
  onClose = (code) => {
    this.world.chat.add({
      id: uuid(),
      from: null,
      fromId: null,
      body: `You have been disconnected.`,
      createdAt: moment3().toISOString()
    });
    this.world.emit("disconnect", code || true);
    console.log("disconnect", code);
  };
};

// src/core/systems/Client.js
var worker;
var Client = class extends System {
  constructor(world2) {
    super(world2);
    window.world = world2;
    window.THREE = three_exports;
  }
  async init({ loadYoga }) {
    await loadYoga;
    initYoga();
  }
  start() {
    this.world.graphics.renderer.setAnimationLoop(this.world.tick);
    document.addEventListener("visibilitychange", this.onVisibilityChange);
    this.world.settings.on("change", this.onSettingsChange);
  }
  onSettingsChange = (changes) => {
    if (changes.title) {
      document.title = changes.title.value || "World";
    }
  };
  onVisibilityChange = () => {
    if (!worker) {
      const script = `
        const rate = 1000 / 5 // 5 FPS
        let intervalId = null;
        self.onmessage = e => {
          if (e.data === 'start' && !intervalId) {
            intervalId = setInterval(() => {
              self.postMessage(1);
            }, rate);
            console.log('[worker] tick started')
          }
          if (e.data === 'stop' && intervalId) {
            clearInterval(intervalId);
            intervalId = null;
            console.log('[worker] tick stopped')
          }
        }
      `;
      const blob = new Blob([script], { type: "application/javascript" });
      worker = new Worker(URL.createObjectURL(blob));
      worker.onmessage = () => {
        const time = performance.now();
        this.world.tick(time);
      };
    }
    if (document.hidden) {
      this.world.graphics.renderer.setAnimationLoop(null);
      worker.postMessage("start");
    } else {
      worker.postMessage("stop");
      this.world.graphics.renderer.setAnimationLoop(this.world.tick);
    }
  };
  destroy() {
    this.world.graphics.renderer.setAnimationLoop(null);
    worker?.postMessage("stop");
  }
};

// src/core/systems/ClientLiveKit.js
import { Participant, ParticipantEvent, Room, RoomEvent, ScreenSharePresets, Track } from "livekit-client";
import { isBoolean as isBoolean16 } from "lodash-es";
import { TrackSource } from "livekit-server-sdk";
var v17 = new Vector3Enhanced();
var v25 = new Vector3Enhanced();
var q15 = new three_exports.Quaternion();
var ClientLiveKit = class extends System {
  constructor(world2) {
    super(world2);
    this.room = null;
    this.status = {
      available: false,
      connected: false,
      mic: false,
      screenshare: null
    };
    this.voices = /* @__PURE__ */ new Map();
    this.screens = [];
    this.screenNodes = /* @__PURE__ */ new Set();
  }
  async deserialize(opts) {
    if (!opts) return;
    this.status.available = true;
    this.room = new Room({
      webAudioMix: {
        audioContext: this.world.audio.ctx
      },
      publishDefaults: {
        screenShareEncoding: ScreenSharePresets.h1080fps30.encoding,
        screenShareSimulcastLayers: [ScreenSharePresets.h1080fps30]
      }
    });
    this.room.on(RoomEvent.TrackMuted, this.onTrackMuted);
    this.room.on(RoomEvent.TrackUnmuted, this.onTrackUnmuted);
    this.room.on(RoomEvent.LocalTrackPublished, this.onLocalTrackPublished);
    this.room.on(RoomEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished);
    this.room.on(RoomEvent.TrackSubscribed, this.onTrackSubscribed);
    this.room.on(RoomEvent.TrackUnsubscribed, this.onTrackUnsubscribed);
    this.room.localParticipant.on(ParticipantEvent.IsSpeakingChanged, (speaking) => {
      this.world.entities.player.setSpeaking(speaking);
    });
    this.world.audio.ready(async () => {
      await this.room.connect(opts.wsUrl, opts.token);
      this.status.connected = true;
      this.emit("status", this.status);
    });
  }
  lateUpdate(delta) {
    this.voices.forEach((voice) => {
      voice.lateUpdate(delta);
    });
  }
  setMicrophoneEnabled(value) {
    if (!this.room) return console.error("[livekit] setMicrophoneEnabled failed (not connected)");
    value = isBoolean16(value) ? value : !this.room.localParticipant.isMicrophoneEnabled;
    if (this.status.mic === value) return;
    this.room.localParticipant.setMicrophoneEnabled(value);
  }
  setScreenShareTarget(targetId = null) {
    if (!this.room) return console.error("[livekit] setScreenShareTarget failed (not connected)");
    if (this.status.screenshare === targetId) return;
    const metadata = JSON.stringify({
      screenTargetId: targetId
    });
    this.room.localParticipant.setMetadata(metadata);
    this.room.localParticipant.setScreenShareEnabled(!!targetId, {
      // audio: true,
      // systemAudio: 'include',
    });
  }
  onTrackMuted = (track) => {
    if (track.isLocal && track.source === "microphone") {
      this.status.mic = false;
      this.emit("status", this.status);
    }
  };
  onTrackUnmuted = (track) => {
    if (track.isLocal && track.source === "microphone") {
      this.status.mic = true;
      this.emit("status", this.status);
    }
  };
  onLocalTrackPublished = (publication) => {
    const world2 = this.world;
    const track = publication.track;
    const playerId = this.world.network.id;
    if (publication.source === "microphone") {
      this.status.mic = true;
      this.emit("status", this.status);
    }
    if (publication.source === "screen_share") {
      const metadata = JSON.parse(this.room.localParticipant.metadata || "{}");
      const targetId = metadata.screenTargetId;
      this.status.screenshare = targetId;
      const screen = createPlayerScreen({ world: world2, playerId, targetId, track, publication });
      this.addScreen(screen);
      this.emit("status", this.status);
    }
  };
  onLocalTrackUnpublished = (publication) => {
    const playerId = this.world.network.id;
    if (publication.source === "microphone") {
      this.status.mic = false;
      this.emit("status", this.status);
    }
    if (publication.source === "screen_share") {
      const screen = this.screens.find((s5) => s5.playerId === playerId);
      this.removeScreen(screen);
      this.status.screenshare = null;
      this.emit("status", this.status);
    }
  };
  onTrackSubscribed = (track, publication, participant) => {
    const playerId = participant.identity;
    const player = this.world.entities.getPlayer(playerId);
    if (!player) return console.error("onTrackSubscribed failed: no player");
    const world2 = this.world;
    if (track.source === "microphone") {
      const voice = new PlayerVoice(world2, player, track, participant);
      this.voices.set(playerId, voice);
    }
    if (track.source === "screen_share") {
      const metadata = JSON.parse(participant.metadata || "{}");
      const targetId = metadata.screenTargetId;
      const screen = createPlayerScreen({ world: world2, playerId, targetId, track, publication });
      this.addScreen(screen);
    }
  };
  onTrackUnsubscribed = (track, publication, participant) => {
    const playerId = participant.identity;
    if (track.source === "microphone") {
      const voice = this.voices.get(playerId);
      voice?.destroy();
      this.voices.delete(playerId);
    }
    if (track.source === "screen_share") {
      const screen = this.screens.find((s5) => s5.playerId === playerId);
      this.removeScreen(screen);
    }
  };
  addScreen(screen) {
    this.screens.push(screen);
    for (const node of this.screenNodes) {
      if (node._screenId === screen.targetId) {
        node.needsRebuild = true;
        node.setDirty();
      }
    }
  }
  removeScreen(screen) {
    screen.destroy();
    this.screens = this.screens.filter((s5) => s5 !== screen);
    for (const node of this.screenNodes) {
      if (node._screenId === screen.targetId) {
        node.needsRebuild = true;
        node.setDirty();
      }
    }
  }
  registerScreenNode(node) {
    this.screenNodes.add(node);
    let match;
    for (const screen of this.screens) {
      if (screen.targetId === node._screenId) {
        match = screen;
      }
    }
    return match;
  }
  unregisterScreenNode(node) {
    this.screenNodes.delete(node);
  }
};
var PlayerVoice = class {
  constructor(world2, player, track, participant) {
    this.world = world2;
    this.player = player;
    this.track = track;
    this.participant = participant;
    this.track.setAudioContext(world2.audio.ctx);
    this.spatial = true;
    this.panner = world2.audio.ctx.createPanner();
    this.panner.panningModel = "HRTF";
    this.panner.panningModel = "HRTF";
    this.panner.distanceModel = "inverse";
    this.panner.refDistance = 1;
    this.panner.maxDistance = 40;
    this.panner.rolloffFactor = 3;
    this.panner.coneInnerAngle = 360;
    this.panner.coneOuterAngle = 360;
    this.panner.coneOuterGain = 0;
    this.gain = world2.audio.groupGains.voice;
    this.panner.connect(this.gain);
    this.track.attach();
    this.track.setWebAudioPlugins([this.spatial ? this.panner : this.gain]);
    this.participant.on(ParticipantEvent.IsSpeakingChanged, (speaking) => {
      this.player.setSpeaking(speaking);
    });
  }
  lateUpdate(delta) {
    const audio = this.world.audio;
    const matrix = this.player.base.matrixWorld;
    const pos = v17.setFromMatrixPosition(matrix);
    const qua = q15.setFromRotationMatrix(matrix);
    const dir = v25.set(0, 0, -1).applyQuaternion(qua);
    if (this.panner.positionX) {
      const endTime = audio.ctx.currentTime + audio.lastDelta;
      this.panner.positionX.linearRampToValueAtTime(pos.x, endTime);
      this.panner.positionY.linearRampToValueAtTime(pos.y, endTime);
      this.panner.positionZ.linearRampToValueAtTime(pos.z, endTime);
      this.panner.orientationX.linearRampToValueAtTime(dir.x, endTime);
      this.panner.orientationY.linearRampToValueAtTime(dir.y, endTime);
      this.panner.orientationZ.linearRampToValueAtTime(dir.z, endTime);
    } else {
      this.panner.setPosition(pos.x, pos.y, pos.z);
      this.panner.setOrientation(dir.x, dir.y, dir.z);
    }
  }
  destroy() {
    this.player.setSpeaking(false);
    this.track.detach();
  }
};
function createPlayerScreen({ world: world2, playerId, targetId, track, participant }) {
  const elem = document.createElement("video");
  elem.playsInline = true;
  elem.muted = true;
  track.attach(elem);
  const texture = new three_exports.VideoTexture(elem);
  texture.colorSpace = three_exports.SRGBColorSpace;
  texture.minFilter = three_exports.LinearFilter;
  texture.magFilter = three_exports.LinearFilter;
  texture.anisotropy = world2.graphics.maxAnisotropy;
  texture.needsUpdate = true;
  let width;
  let height;
  let ready = false;
  const prepare = function() {
    return new Promise(async (resolve3) => {
      let playing = false;
      let data = false;
      elem.addEventListener(
        "loadeddata",
        async () => {
          if (playing) elem.pause();
          data = true;
          width = elem.videoWidth;
          height = elem.videoHeight;
          console.log({ width, height });
          ready = true;
          resolve3();
        },
        { once: true }
      );
      elem.addEventListener(
        "loadedmetadata",
        async () => {
          if (data) return;
        },
        { once: true }
      );
    });
  }();
  function isPlaying() {
    return true;
  }
  function play(restartIfPlaying = false) {
  }
  function pause() {
  }
  function stop() {
  }
  function release3() {
  }
  function destroy() {
    console.log("destory");
    texture.dispose();
  }
  const handle = {
    isScreen: true,
    playerId,
    targetId,
    elem,
    audio: null,
    texture,
    prepare,
    get ready() {
      return ready;
    },
    get width() {
      return width;
    },
    get height() {
      return height;
    },
    get loop() {
      return false;
    },
    set loop(value) {
    },
    get isPlaying() {
      return isPlaying();
    },
    get currentTime() {
      return elem.currentTime;
    },
    set currentTime(value) {
      elem.currentTime = value;
    },
    play,
    pause,
    stop,
    release: release3,
    destroy
  };
  return handle;
}

// src/core/systems/ClientPointer.js
var ClientPointer = class extends System {
  constructor(world2) {
    super(world2);
    this.pointerState = new PointerState();
  }
  init({ ui }) {
    this.ui = ui;
  }
  start() {
    this.control = this.world.controls.bind({
      priority: ControlPriorities.POINTER
    });
  }
  update(delta) {
    const hit = this.control.pointer.locked ? this.world.stage.raycastReticle()[0] : this.screenHit;
    this.pointerState.update(hit, this.control.mouseLeft.pressed, this.control.mouseLeft.released);
  }
  setScreenHit(screenHit) {
    this.screenHit = screenHit;
    this.control.mouseLeft.capture = !!screenHit;
  }
};
var PointerEvents = {
  ENTER: "pointerenter",
  LEAVE: "pointerleave",
  DOWN: "pointerdown",
  UP: "pointerup"
};
var CURSOR_DEFAULT = "default";
var PointerEvent = class {
  constructor() {
    this.type = null;
    this._propagationStopped = false;
  }
  set(type) {
    this.type = type;
    this._propagationStopped = false;
  }
  stopPropagation() {
    this._propagationStopped = true;
  }
};
var PointerState = class {
  constructor() {
    this.activePath = /* @__PURE__ */ new Set();
    this.event = new PointerEvent();
    this.cursor = CURSOR_DEFAULT;
    this.pressedNodes = /* @__PURE__ */ new Set();
  }
  update(hit, pointerPressed, pointerReleased) {
    const newPath = hit ? this.getAncestorPath(hit) : [];
    const oldPath = Array.from(this.activePath);
    let i5 = 0;
    while (i5 < newPath.length && i5 < oldPath.length && newPath[i5] === oldPath[i5]) i5++;
    for (let j4 = oldPath.length - 1; j4 >= i5; j4--) {
      if (oldPath[j4].onPointerLeave) {
        this.event.set(PointerEvents.LEAVE);
        try {
          oldPath[j4].onPointerLeave?.(this.event);
        } catch (err) {
          console.error(err);
        }
      }
      this.activePath.delete(oldPath[j4]);
    }
    for (let j4 = i5; j4 < newPath.length; j4++) {
      if (newPath[j4].onPointerEnter) {
        this.event.set(PointerEvents.ENTER);
        try {
          newPath[j4].onPointerEnter?.(this.event);
        } catch (err) {
          console.error(err);
        }
        if (this.event._propagationStopped) break;
      }
      this.activePath.add(newPath[j4]);
    }
    let cursor = CURSOR_DEFAULT;
    if (newPath.length > 0) {
      for (let i6 = newPath.length - 1; i6 >= 0; i6--) {
        if (newPath[i6].cursor) {
          cursor = newPath[i6].cursor;
          break;
        }
      }
    }
    if (cursor !== this.cursor) {
      document.body.style.cursor = cursor;
      this.cursor = cursor;
    }
    if (pointerPressed) {
      for (let i6 = newPath.length - 1; i6 >= 0; i6--) {
        const node = newPath[i6];
        if (node.onPointerDown) {
          this.event.set(PointerEvents.DOWN);
          try {
            node.onPointerDown(this.event);
          } catch (err) {
            console.error(err);
          }
          this.pressedNodes.add(node);
          if (this.event._propagationStopped) break;
        }
      }
    }
    if (pointerReleased) {
      for (const node of this.pressedNodes) {
        if (node.onPointerUp) {
          this.event.set(PointerEvents.UP);
          try {
            node.onPointerUp(this.event);
          } catch (err) {
            console.error(err);
          }
          if (this.event._propagationStopped) break;
        }
      }
      this.pressedNodes.clear();
    }
  }
  getAncestorPath(hit) {
    const path2 = [];
    let node = hit.node?.resolveHit?.(hit) || hit.node;
    while (node) {
      path2.unshift(node);
      node = node.parent;
    }
    return path2;
  }
};

// src/core/systems/ClientPrefs.js
import { isBoolean as isBoolean17, isNumber as isNumber21 } from "lodash-es";

// src/client/utils.js
var isTouch = !!navigator.userAgent.match(/OculusBrowser|iPhone|iPad|iPod|Android/i);

// src/core/systems/ClientPrefs.js
var ClientPrefs = class extends System {
  constructor(world2) {
    super(world2);
    const isQuest = /OculusBrowser/.test(navigator.userAgent);
    const data = storage.get("prefs", {});
    if (!data.v) {
      data.v = 2;
      data.ui = null;
    }
    if (data.v < 3) {
      data.v = 3;
      data.shadows = null;
    }
    this.ui = isNumber21(data.ui) ? data.ui : isTouch ? 0.9 : 1;
    this.actions = isBoolean17(data.actions) ? data.actions : true;
    this.stats = isBoolean17(data.stats) ? data.stats : false;
    this.dpr = isNumber21(data.dpr) ? data.dpr : 1;
    this.shadows = data.shadows ? data.shadows : isTouch ? "med" : "high";
    this.postprocessing = isBoolean17(data.postprocessing) ? data.postprocessing : true;
    this.bloom = isBoolean17(data.bloom) ? data.bloom : true;
    this.music = isNumber21(data.music) ? data.music : 1;
    this.sfx = isNumber21(data.sfx) ? data.sfx : 1;
    this.voice = isNumber21(data.voice) ? data.voice : 1;
    this.v = data.v;
    this.changes = null;
  }
  preFixedUpdate() {
    if (!this.changes) return;
    this.emit("change", this.changes);
    this.changes = null;
  }
  modify(key, value) {
    if (this[key] === value) return;
    const prev = this[key];
    this[key] = value;
    if (!this.changes) this.changes = {};
    if (!this.changes[key]) this.changes[key] = { prev, value: null };
    this.changes[key].value = value;
    this.persist();
  }
  persist() {
    storage.set("prefs", {
      ui: this.ui,
      actions: this.actions,
      stats: this.stats,
      dpr: this.dpr,
      shadows: this.shadows,
      postprocessing: this.postprocessing,
      bloom: this.bloom,
      music: this.music,
      sfx: this.sfx,
      voice: this.voice,
      v: this.v
    });
  }
  setUI(value) {
    this.modify("ui", value);
  }
  setActions(value) {
    this.modify("actions", value);
  }
  setStats(value) {
    this.modify("stats", value);
  }
  setDPR(value) {
    this.modify("dpr", value);
  }
  setShadows(value) {
    this.modify("shadows", value);
  }
  setPostprocessing(value) {
    this.modify("postprocessing", value);
  }
  setBloom(value) {
    this.modify("bloom", value);
  }
  setMusic(value) {
    this.modify("music", value);
  }
  setSFX(value) {
    this.modify("sfx", value);
  }
  setVoice(value) {
    this.modify("voice", value);
  }
};

// src/core/extras/buttons.js
var buttons = /* @__PURE__ */ new Set([
  "keyA",
  "keyB",
  "keyC",
  "keyD",
  "keyE",
  "keyF",
  "keyG",
  "keyH",
  "keyI",
  "keyJ",
  "keyK",
  "keyL",
  "keyM",
  "keyN",
  "keyO",
  "keyP",
  "keyQ",
  "keyR",
  "keyS",
  "keyT",
  "keyU",
  "keyV",
  "keyW",
  "keyX",
  "keyY",
  "keyZ",
  "digit0",
  "digit1",
  "digit2",
  "digit3",
  "digit4",
  "digit5",
  "digit6",
  "digit7",
  "digit8",
  "digit9",
  "minus",
  "equal",
  "bracketLeft",
  "bracketRight",
  "backslash",
  "semicolon",
  "quote",
  "backquote",
  "comma",
  "period",
  "slash",
  "arrowUp",
  "arrowDown",
  "arrowLeft",
  "arrowRight",
  "home",
  "end",
  "pageUp",
  "pageDown",
  "tab",
  "capsLock",
  "shiftLeft",
  "shiftRight",
  "controlLeft",
  "controlRight",
  "altLeft",
  "altRight",
  "enter",
  "space",
  "backspace",
  "delete",
  "escape",
  "mouseLeft",
  "mouseRight",
  "metaLeft"
]);
var codeToProp = {
  KeyA: "keyA",
  KeyB: "keyB",
  KeyC: "keyC",
  KeyD: "keyD",
  KeyE: "keyE",
  KeyF: "keyF",
  KeyG: "keyG",
  KeyH: "keyH",
  KeyI: "keyI",
  KeyJ: "keyJ",
  KeyK: "keyK",
  KeyL: "keyL",
  KeyM: "keyM",
  KeyN: "keyN",
  KeyO: "keyO",
  KeyP: "keyP",
  KeyQ: "keyQ",
  KeyR: "keyR",
  KeyS: "keyS",
  KeyT: "keyT",
  KeyU: "keyU",
  KeyV: "keyV",
  KeyW: "keyW",
  KeyX: "keyX",
  KeyY: "keyY",
  KeyZ: "keyZ",
  Digit0: "digit0",
  Digit1: "digit1",
  Digit2: "digit2",
  Digit3: "digit3",
  Digit4: "digit4",
  Digit5: "digit5",
  Digit6: "digit6",
  Digit7: "digit7",
  Digit8: "digit8",
  Digit9: "digit9",
  Minus: "minus",
  Equal: "equal",
  BracketLeft: "bracketLeft",
  BracketRight: "bracketRight",
  Backslash: "backslash",
  Semicolon: "semicolon",
  Quote: "quote",
  Backquote: "backquote",
  Comma: "comma",
  Period: "period",
  Slash: "slash",
  ArrowUp: "arrowUp",
  ArrowDown: "arrowDown",
  ArrowLeft: "arrowLeft",
  ArrowRight: "arrowRight",
  Home: "home",
  End: "end",
  PageUp: "pageUp",
  PageDown: "pageDown",
  Tab: "tab",
  CapsLock: "capsLock",
  ShiftLeft: "shiftLeft",
  ShiftRight: "shiftRight",
  ControlLeft: "controlLeft",
  ControlRight: "controlRight",
  AltLeft: "altLeft",
  AltRight: "altRight",
  Enter: "enter",
  Space: "space",
  Backspace: "backspace",
  Delete: "delete",
  Escape: "escape",
  MouseLeft: "mouseLeft",
  MouseRight: "mouseRight",
  MetaLeft: "metaLeft"
};

// src/core/systems/ClientControls.js
var LMB = 1;
var RMB = 2;
var MouseLeft = "mouseLeft";
var MouseRight = "mouseRight";
var HandednessLeft = "left";
var HandednessRight = "right";
var actionIds = 0;
var controlTypes = {
  // key: createButton,
  mouseLeft: createButton,
  mouseRight: createButton,
  touchStick: createVector,
  scrollDelta: createValue,
  pointer: createPointer,
  screen: createScreen,
  camera: createCamera,
  xrLeftStick: createVector,
  xrLeftBtn1: createButton,
  xrLeftBtn2: createButton,
  xrRightStick: createVector,
  xrRightBtn1: createButton,
  xrRightBtn2: createButton,
  touchA: createButton,
  touchB: createButton
};
var ClientControls = class extends System {
  constructor(world2) {
    super(world2);
    this.controls = [];
    this.actions = [];
    this.buttonsDown = /* @__PURE__ */ new Set();
    this.isUserGesture = false;
    this.isMac = /Mac/.test(navigator.platform);
    this.pointer = {
      locked: false,
      shouldLock: false,
      coords: new Vector3Enhanced(),
      // [0,0] to [1,1]
      position: new Vector3Enhanced(),
      // [0,0] to [viewportWidth,viewportHeight]
      delta: new Vector3Enhanced()
      // position delta (pixels)
    };
    this.touches = /* @__PURE__ */ new Map();
    this.screen = {
      width: 0,
      height: 0
    };
    this.scroll = {
      delta: 0
    };
    this.xrSession = null;
  }
  start() {
    this.world.on("xrSession", this.onXRSession);
  }
  preFixedUpdate() {
    for (const control of this.controls) {
      if (control.entries.scrollDelta) {
        control.entries.scrollDelta.value = this.scroll.delta;
        if (control.entries.scrollDelta.capture) break;
      }
    }
    if (this.xrSession) {
      this.xrSession.inputSources?.forEach((src) => {
        if (src.gamepad && src.handedness === HandednessLeft) {
          for (const control of this.controls) {
            if (control.entries.xrLeftStick) {
              control.entries.xrLeftStick.value.x = src.gamepad.axes[2];
              control.entries.xrLeftStick.value.z = src.gamepad.axes[3];
              if (control.entries.xrLeftStick.capture) break;
            }
            if (control.entries.xrLeftBtn1) {
              const button = control.entries.xrLeftBtn1;
              const down = src.gamepad.buttons[4].pressed;
              if (down && !button.down) {
                button.pressed = true;
                button.onPress?.();
              }
              if (!down && button.down) {
                button.released = true;
                button.onRelease?.();
              }
              button.down = down;
            }
            if (control.entries.xrLeftBtn2) {
              const button = control.entries.xrLeftBtn2;
              const down = src.gamepad.buttons[5].pressed;
              if (down && !button.down) {
                button.pressed = true;
                button.onPress?.();
              }
              if (!down && button.down) {
                button.released = true;
                button.onRelease?.();
              }
              button.down = down;
            }
          }
        }
        if (src.gamepad && src.handedness === HandednessRight) {
          for (const control of this.controls) {
            if (control.entries.xrRightStick) {
              control.entries.xrRightStick.value.x = src.gamepad.axes[2];
              control.entries.xrRightStick.value.z = src.gamepad.axes[3];
              if (control.entries.xrRightStick.capture) break;
            }
            if (control.entries.xrRightBtn1) {
              const button = control.entries.xrRightBtn1;
              const down = src.gamepad.buttons[4].pressed;
              if (down && !button.down) {
                button.pressed = true;
                button.onPress?.();
              }
              if (!down && button.down) {
                button.released = true;
                button.onRelease?.();
              }
              button.down = down;
            }
            if (control.entries.xrRightBtn2) {
              const button = control.entries.xrRightBtn2;
              const down = src.gamepad.buttons[5].pressed;
              if (down && !button.down) {
                button.pressed = true;
                button.onPress?.();
              }
              if (!down && button.down) {
                button.released = true;
                button.onRelease?.();
              }
              button.down = down;
            }
          }
        }
      });
    }
  }
  postLateUpdate() {
    this.pointer.delta.set(0, 0, 0);
    this.scroll.delta = 0;
    for (const control of this.controls) {
      for (const key in control.entries) {
        const value = control.entries[key];
        if (value.$button) {
          value.pressed = false;
          value.released = false;
        }
      }
    }
    let written;
    for (const control of this.controls) {
      const camera = control.entries.camera;
      if (camera?.write && !written) {
        this.world.rig.position.copy(camera.position);
        this.world.rig.quaternion.copy(camera.quaternion);
        this.world.camera.position.z = camera.zoom;
        written = true;
      } else if (camera) {
        camera.position.copy(this.world.rig.position);
        camera.quaternion.copy(this.world.rig.quaternion);
        camera.zoom = this.world.camera.position.z;
      }
    }
    for (const [id, info] of this.touches) {
      info.delta.set(0, 0, 0);
    }
  }
  async init({ viewport }) {
    this.viewport = viewport;
    this.screen.width = this.viewport.offsetWidth;
    this.screen.height = this.viewport.offsetHeight;
    if (typeof window !== "undefined") {
      window.addEventListener("keydown", this.onKeyDown);
      window.addEventListener("keyup", this.onKeyUp);
      document.addEventListener("pointerlockchange", this.onPointerLockChange);
      this.viewport.addEventListener("pointerdown", this.onPointerDown);
      window.addEventListener("pointermove", this.onPointerMove);
      this.viewport.addEventListener("touchstart", this.onTouchStart);
      this.viewport.addEventListener("touchmove", this.onTouchMove);
      this.viewport.addEventListener("touchend", this.onTouchEnd);
      this.viewport.addEventListener("touchcancel", this.onTouchEnd);
      this.viewport.addEventListener("pointerup", this.onPointerUp);
      this.viewport.addEventListener("wheel", this.onScroll, { passive: false });
      document.body.addEventListener("contextmenu", this.onContextMenu);
      window.addEventListener("resize", this.onResize);
      window.addEventListener("blur", this.onBlur);
    }
  }
  bind(options = {}) {
    const self2 = this;
    const entries = {};
    const control = {
      options,
      entries,
      actions: null,
      api: {
        setActions(value) {
          if (value !== null && !Array.isArray(value)) {
            throw new Error("[control] actions must be null or array");
          }
          control.actions = value;
          if (value) {
            for (const action of value) {
              action.id = ++actionIds;
            }
          }
          self2.buildActions();
        },
        release: () => {
          const idx2 = this.controls.indexOf(control);
          if (idx2 === -1) return;
          this.controls.splice(idx2, 1);
          options.onRelease?.();
        }
      }
    };
    const idx = this.controls.findIndex((c5) => c5.options.priority <= options.priority);
    if (idx === -1) {
      this.controls.push(control);
    } else {
      this.controls.splice(idx, 0, control);
    }
    return new Proxy(control, {
      get(target, prop) {
        if (prop in target.api) {
          return target.api[prop];
        }
        if (prop in entries) {
          return entries[prop];
        }
        if (buttons.has(prop)) {
          entries[prop] = createButton(self2, control, prop);
          return entries[prop];
        }
        const createType = controlTypes[prop];
        if (createType) {
          entries[prop] = createType(self2, control, prop);
          return entries[prop];
        }
        return void 0;
      }
    });
  }
  releaseAllButtons() {
    for (const control of this.controls) {
      for (const key in control.entries) {
        const value = control.entries[key];
        if (value.$button && value.down) {
          value.released = true;
          value.down = false;
          value.onRelease?.();
        }
      }
    }
  }
  buildActions() {
    this.actions = [];
    for (const control of this.controls) {
      const actions = control.actions;
      if (actions) {
        for (const action of actions) {
          if (!action.type === "custom") {
            const idx = this.actions.findIndex((a5) => a5.type === action.type);
            if (idx !== -1) continue;
          }
          this.actions.push(action);
        }
      }
    }
    this.world.emit("actions", this.actions);
  }
  setTouchBtn(prop, down) {
    if (down) {
      this.buttonsDown.add(prop);
      for (const control of this.controls) {
        const button = control.entries[prop];
        if (button?.$button) {
          button.pressed = true;
          button.down = true;
          const capture = button.onPress?.();
          if (capture || button.capture) break;
        }
      }
    } else {
      this.buttonsDown.delete(prop);
      for (const control of this.controls) {
        const button = control.entries[prop];
        if (button?.$button && button.down) {
          button.down = false;
          button.released = true;
          button.onRelease?.();
        }
      }
    }
  }
  onKeyDown = (e7) => {
    if (e7.defaultPrevented) return;
    if (e7.repeat) return;
    if (this.isInputFocused()) return;
    const code = e7.code;
    if (code === "Tab") {
      e7.preventDefault();
    }
    const prop = codeToProp[code];
    const text = e7.key;
    this.buttonsDown.add(prop);
    for (const control of this.controls) {
      const button = control.entries[prop];
      if (button?.$button) {
        button.pressed = true;
        button.down = true;
        const capture2 = button.onPress?.();
        if (capture2 || button.capture) break;
      }
      const capture = control.onButtonPress?.(prop, text);
      if (capture) break;
    }
  };
  onKeyUp = (e7) => {
    if (e7.repeat) return;
    if (this.isInputFocused()) return;
    const code = e7.code;
    if (code === "MetaLeft" || code === "MetaRight") {
      return this.releaseAllButtons();
    }
    const prop = codeToProp[code];
    this.buttonsDown.delete(prop);
    for (const control of this.controls) {
      const button = control.entries[prop];
      if (button?.$button && button.down) {
        button.down = false;
        button.released = true;
        button.onRelease?.();
      }
    }
  };
  onPointerDown = (e7) => {
    if (e7.isCoreUI) return;
    this.checkPointerChanges(e7);
  };
  onPointerMove = (e7) => {
    if (e7.isCoreUI) return;
    const rect = this.viewport.getBoundingClientRect();
    const offsetX = e7.pageX - rect.left;
    const offsetY = e7.pageY - rect.top;
    this.pointer.coords.x = Math.max(0, Math.min(1, offsetX / rect.width));
    this.pointer.coords.y = Math.max(0, Math.min(1, offsetY / rect.height));
    this.pointer.position.x = offsetX;
    this.pointer.position.y = offsetY;
    this.pointer.delta.x += e7.movementX;
    this.pointer.delta.y += e7.movementY;
  };
  onPointerUp = (e7) => {
    if (e7.isCoreUI) return;
    this.checkPointerChanges(e7);
  };
  checkPointerChanges(e7) {
    const lmb = !!(e7.buttons & LMB);
    if (!this.lmbDown && lmb) {
      this.lmbDown = true;
      this.buttonsDown.add(MouseLeft);
      for (const control of this.controls) {
        const button = control.entries.mouseLeft;
        if (button) {
          button.down = true;
          button.pressed = true;
          const capture = button.onPress?.();
          if (capture || button.capture) break;
        }
      }
    }
    if (this.lmbDown && !lmb) {
      this.lmbDown = false;
      this.buttonsDown.delete(MouseLeft);
      for (const control of this.controls) {
        const button = control.entries.mouseLeft;
        if (button) {
          button.down = false;
          button.released = true;
          button.onRelease?.();
        }
      }
    }
    const rmb = !!(e7.buttons & RMB);
    if (!this.rmbDown && rmb) {
      this.rmbDown = true;
      this.buttonsDown.add(MouseRight);
      for (const control of this.controls) {
        const button = control.entries.mouseRight;
        if (button) {
          button.down = true;
          button.pressed = true;
          const capture = button.onPress?.();
          if (capture || button.capture) break;
        }
      }
    }
    if (this.rmbDown && !rmb) {
      this.rmbDown = false;
      this.buttonsDown.delete(MouseRight);
      for (const control of this.controls) {
        const button = control.entries.mouseRight;
        if (button) {
          button.down = false;
          button.released = true;
          button.onRelease?.();
        }
      }
    }
  }
  async lockPointer() {
    this.pointer.shouldLock = true;
    try {
      await this.viewport.requestPointerLock();
      return true;
    } catch (err) {
      console.log("pointerlock denied, too quick?");
      return false;
    }
  }
  unlockPointer() {
    this.pointer.shouldLock = false;
    if (!this.pointer.locked) return;
    document.exitPointerLock();
    this.onPointerLockEnd();
  }
  onPointerLockChange = (e7) => {
    const didPointerLock = !!document.pointerLockElement;
    if (didPointerLock) {
      this.onPointerLockStart();
    } else {
      this.onPointerLockEnd();
    }
  };
  onPointerLockStart() {
    if (this.pointer.locked) return;
    this.pointer.locked = true;
    this.world.emit("pointer-lock", true);
    if (!this.pointer.shouldLock) this.unlockPointer();
  }
  onPointerLockEnd() {
    if (!this.pointer.locked) return;
    this.pointer.locked = false;
    this.world.emit("pointer-lock", false);
  }
  onScroll = (e7) => {
    if (e7.isCoreUI) return;
    e7.preventDefault();
    let delta = e7.shiftKey ? e7.deltaX : e7.deltaY;
    if (!this.isMac) delta = -delta;
    this.scroll.delta += delta;
  };
  onContextMenu = (e7) => {
    e7.preventDefault();
  };
  onTouchStart = (e7) => {
    if (e7.isCoreUI) return;
    e7.preventDefault();
    for (let i5 = 0; i5 < e7.changedTouches.length; i5++) {
      const touch = e7.changedTouches[i5];
      const info = {
        id: touch.identifier,
        position: new Vector3Enhanced(touch.clientX, touch.clientY, 0),
        prevPosition: new Vector3Enhanced(touch.clientX, touch.clientY, 0),
        delta: new Vector3Enhanced()
      };
      this.touches.set(info.id, info);
      for (const control of this.controls) {
        const consume = control.options.onTouch?.(info);
        if (consume) break;
      }
    }
  };
  onTouchMove = (e7) => {
    if (e7.isCoreUI) return;
    for (let i5 = 0; i5 < e7.changedTouches.length; i5++) {
      const touch = e7.changedTouches[i5];
      const info = this.touches.get(touch.identifier);
      if (!info) continue;
      const currentX = touch.clientX;
      const currentY = touch.clientY;
      info.delta.x += currentX - info.prevPosition.x;
      info.delta.y += currentY - info.prevPosition.y;
      info.position.x = currentX;
      info.position.y = currentY;
      info.prevPosition.x = currentX;
      info.prevPosition.y = currentY;
    }
  };
  onTouchEnd = (e7) => {
    if (e7.isCoreUI) return;
    for (let i5 = 0; i5 < e7.changedTouches.length; i5++) {
      const touch = e7.changedTouches[i5];
      const info = this.touches.get(touch.identifier);
      for (const control of this.controls) {
        const consume = control.options.onTouchEnd?.(info);
        if (consume) break;
      }
      this.touches.delete(touch.identifier);
    }
  };
  onResize = () => {
    this.screen.width = this.viewport.offsetWidth;
    this.screen.height = this.viewport.offsetHeight;
  };
  onBlur = () => {
    this.releaseAllButtons();
  };
  onXRSession = (session) => {
    this.xrSession = session;
  };
  isInputFocused() {
    return document.activeElement?.tagName === "INPUT" || document.activeElement?.tagName === "TEXTAREA";
  }
};
function createButton(controls, control, prop) {
  const down = controls.buttonsDown.has(prop);
  const pressed = down;
  const released = false;
  return {
    $button: true,
    down,
    pressed,
    released,
    capture: false,
    onPress: null,
    onRelease: null
  };
}
function createVector(controls, control, prop) {
  return {
    $vector: true,
    value: new Vector3Enhanced(),
    capture: false
  };
}
function createValue(controls, control, prop) {
  return {
    $value: true,
    value: null,
    capture: false
  };
}
function createPointer(controls, control, prop) {
  const coords = new Vector3Enhanced();
  const position = new Vector3Enhanced();
  const delta = new Vector3Enhanced();
  return {
    get coords() {
      return coords.copy(controls.pointer.coords);
    },
    get position() {
      return position.copy(controls.pointer.position);
    },
    get delta() {
      return delta.copy(controls.pointer.delta);
    },
    get locked() {
      return controls.pointer.locked;
    },
    lock() {
      controls.lockPointer();
    },
    unlock() {
      controls.unlockPointer();
    }
  };
}
function createScreen(controls, control) {
  return {
    $screen: true,
    get width() {
      return controls.screen.width;
    },
    get height() {
      return controls.screen.height;
    }
  };
}
function createCamera(controls, control) {
  const world2 = controls.world;
  const position = new Vector3Enhanced().copy(world2.rig.position);
  const quaternion = new three_exports.Quaternion().copy(world2.rig.quaternion);
  const rotation = new three_exports.Euler(0, 0, 0, "YXZ").copy(world2.rig.rotation);
  bindRotations(quaternion, rotation);
  const zoom = world2.camera.position.z;
  return {
    $camera: true,
    position,
    quaternion,
    rotation,
    zoom,
    write: false
  };
}

// src/core/systems/ClientLoader.js
import { RGBELoader } from "three/examples/jsm/loaders/RGBELoader.js";
import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";
import { VRMLoaderPlugin } from "@pixiv/three-vrm";

// src/core/extras/createVRMFactory.js
import * as SkeletonUtils2 from "three/examples/jsm/utils/SkeletonUtils.js";
var v18 = new Vector3Enhanced();
var v26 = new Vector3Enhanced();
var DIST_CHECK_RATE = 1;
var DIST_MIN_RATE = 1 / 5;
var DIST_MAX_RATE = 1 / 25;
var DIST_MIN = 30;
var DIST_MAX = 60;
var material = new three_exports.MeshBasicMaterial();
function createVRMFactory(glb, setupMaterial) {
  glb.scene.matrixAutoUpdate = false;
  glb.scene.matrixWorldAutoUpdate = false;
  const expressions = glb.scene.children.filter((n6) => n6.type === "VRMExpression");
  for (const node of expressions) node.removeFromParent();
  const vrmHumanoidRigs = glb.scene.children.filter((n6) => n6.name === "VRMHumanoidRig");
  for (const node of vrmHumanoidRigs) node.removeFromParent();
  const secondaries = glb.scene.children.filter((n6) => n6.name === "secondary");
  for (const node of secondaries) node.removeFromParent();
  glb.scene.traverse((obj) => {
    if (obj.isMesh) {
      obj.castShadow = true;
      obj.receiveShadow = true;
    }
  });
  const bones = glb.userData.vrm.humanoid._rawHumanBones.humanBones;
  const hipsPosition = v18.setFromMatrixPosition(bones.hips.node.matrixWorld);
  const rootPosition = v26.set(0, 0, 0);
  const rootToHips = hipsPosition.y - rootPosition.y;
  const version4 = glb.userData.vrm.meta?.metaVersion;
  const skinnedMeshes = [];
  glb.scene.traverse((node) => {
    if (node.isSkinnedMesh) {
      node.bindMode = three_exports.DetachedBindMode;
      node.bindMatrix.copy(node.matrixWorld);
      node.bindMatrixInverse.copy(node.bindMatrix).invert();
      skinnedMeshes.push(node);
    }
    if (node.isMesh) {
      node.geometry.computeBoundsTree();
      node.material.shadowSide = three_exports.BackSide;
      setupMaterial(node.material);
    }
  });
  const skeleton = skinnedMeshes[0].skeleton;
  const normBones = glb.userData.vrm.humanoid._normalizedHumanBones.humanBones;
  const leftArm = normBones.leftUpperArm.node;
  leftArm.rotation.z = 75 * DEG2RAD;
  const rightArm = normBones.rightUpperArm.node;
  rightArm.rotation.z = -75 * DEG2RAD;
  glb.userData.vrm.humanoid.update(0);
  skeleton.update();
  let height = 1;
  for (const mesh of skinnedMeshes) {
    if (!mesh.boundingBox) mesh.computeBoundingBox();
    if (height < mesh.boundingBox.max.y) {
      height = mesh.boundingBox.max.y;
    }
  }
  const headPos = normBones.head.node.getWorldPosition(new Vector3Enhanced());
  const headToHeight = height - headPos.y;
  const getBoneName = (vrmBoneName) => {
    return glb.userData.vrm.humanoid.getRawBoneNode(vrmBoneName)?.name;
  };
  const noop3 = () => {
  };
  return {
    create,
    applyStats(stats) {
      glb.scene.traverse((obj) => {
        if (obj.geometry && !stats.geometries.has(obj.geometry.uuid)) {
          stats.geometries.add(obj.geometry.uuid);
          stats.triangles += getTrianglesFromGeometry(obj.geometry);
        }
        if (obj.material && !stats.materials.has(obj.material.uuid)) {
          stats.materials.add(obj.material.uuid);
          stats.textureBytes += getTextureBytesFromMaterial(obj.material);
        }
      });
    }
  };
  function create(matrix, hooks, node) {
    const vrm = cloneGLB(glb);
    const tvrm = vrm.userData.vrm;
    const skinnedMeshes2 = getSkinnedMeshes(vrm.scene);
    const skeleton2 = skinnedMeshes2[0].skeleton;
    const rootBone = skeleton2.bones[0];
    rootBone.parent.remove(rootBone);
    rootBone.updateMatrixWorld(true);
    vrm.scene.matrix = matrix;
    vrm.scene.matrixWorld = matrix;
    hooks.scene.add(vrm.scene);
    const getEntity = () => node?.ctx.entity;
    const cRadius = 0.3;
    const sItem = {
      matrix,
      geometry: createCapsule(cRadius, height - cRadius * 2),
      material,
      getEntity
    };
    hooks.octree?.insert(sItem);
    vrm.scene.traverse((o5) => {
      o5.getEntity = getEntity;
    });
    const mixer = new three_exports.AnimationMixer(skinnedMeshes2[0]);
    let elapsed = 0;
    let rate = 0;
    let rateCheckedAt = 999;
    const update = (delta) => {
      rateCheckedAt += delta;
      if (rateCheckedAt >= DIST_CHECK_RATE) {
        const vrmPos = v18.setFromMatrixPosition(vrm.scene.matrix);
        const camPos = v26.setFromMatrixPosition(hooks.camera.matrixWorld);
        const distance = vrmPos.distanceTo(camPos);
        const clampedDistance = Math.max(distance - DIST_MIN, 0);
        const normalizedDistance = Math.min(clampedDistance / (DIST_MAX - DIST_MIN), 1);
        rate = DIST_MAX_RATE + normalizedDistance * (DIST_MIN_RATE - DIST_MAX_RATE);
        rateCheckedAt = 0;
      }
      elapsed += delta;
      const should = elapsed >= rate;
      if (should) {
        mixer.update(elapsed);
        skeleton2.bones.forEach((bone) => bone.updateMatrixWorld());
        skeleton2.update = three_exports.Skeleton.prototype.update;
        elapsed = 0;
      } else {
        skeleton2.update = noop3;
        elapsed += delta;
      }
    };
    const emotes = {
      // [url]: {
      //   url: String
      //   loading: Boolean
      //   action: AnimationAction
      // }
    };
    let currentEmote;
    const setEmote = (url) => {
      if (currentEmote?.url === url) return;
      if (currentEmote) {
        currentEmote.action?.fadeOut(0.15);
        currentEmote = null;
      }
      if (!url) return;
      const opts = getQueryParams(url);
      const loop = opts.l !== "0";
      const speed = parseFloat(opts.s || 1);
      if (emotes[url]) {
        currentEmote = emotes[url];
        if (currentEmote.action) {
          currentEmote.action.clampWhenFinished = !loop;
          currentEmote.action.setLoop(loop ? three_exports.LoopRepeat : three_exports.LoopOnce);
          currentEmote.action.reset().fadeIn(0.15).play();
        }
      } else {
        const emote = {
          url,
          loading: true,
          action: null
        };
        emotes[url] = emote;
        currentEmote = emote;
        hooks.loader.load("emote", url).then((emo) => {
          const clip = emo.toClip({
            rootToHips,
            version: version4,
            getBoneName
          });
          const action = mixer.clipAction(clip);
          action.timeScale = speed;
          emote.action = action;
          if (currentEmote === emote) {
            action.clampWhenFinished = !loop;
            action.setLoop(loop ? three_exports.LoopRepeat : three_exports.LoopOnce);
            action.play();
          }
        });
      }
    };
    const bonesByName = {};
    const findBone = (name2) => {
      if (!bonesByName[name2]) {
        const actualName = glb.userData.vrm.humanoid.getRawBoneNode(name2)?.name;
        bonesByName[name2] = skeleton2.getBoneByName(actualName);
      }
      return bonesByName[name2];
    };
    let firstPersonActive = false;
    const setFirstPerson = (active) => {
      if (firstPersonActive === active) return;
      const head = findBone("neck");
      head.scale.setScalar(active ? 0 : 1);
      firstPersonActive = active;
    };
    const m14 = new three_exports.Matrix4();
    const getBoneTransform = (boneName) => {
      const bone = findBone(boneName);
      if (!bone) return null;
      return m14.multiplyMatrices(vrm.scene.matrixWorld, bone.matrixWorld);
    };
    return {
      raw: vrm,
      height,
      headToHeight,
      setEmote,
      setFirstPerson,
      update,
      getBoneTransform,
      move(_matrix) {
        matrix.copy(_matrix);
        hooks.octree?.move(sItem);
      },
      destroy() {
        hooks.scene.remove(vrm.scene);
        hooks.octree?.remove(sItem);
      }
    };
  }
}
function cloneGLB(glb) {
  return { ...glb, scene: SkeletonUtils2.clone(glb.scene) };
}
function getSkinnedMeshes(scene) {
  let meshes = [];
  scene.traverse((o5) => {
    if (o5.isSkinnedMesh) {
      meshes.push(o5);
    }
  });
  return meshes;
}
function createCapsule(radius, height) {
  const fullHeight = radius + height + radius;
  const geometry = new three_exports.CapsuleGeometry(radius, height);
  geometry.translate(0, fullHeight / 2, 0);
  return geometry;
}
var queryParams = {};
function getQueryParams(url) {
  if (!queryParams[url]) {
    url = new URL(url);
    const params = {};
    for (const [key, value] of url.searchParams.entries()) {
      params[key] = value;
    }
    queryParams[url] = params;
  }
  return queryParams[url];
}

// src/core/extras/glbToNodes.js
var groupTypes = ["Scene", "Group", "Object3D"];
function glbToNodes(glb, world2) {
  function registerNode(name2, data) {
    const node = createNode(name2, data);
    return node;
  }
  function parse3(object3ds, parentNode) {
    for (const object3d of object3ds) {
      const props = object3d.userData || {};
      const isSkinnedMeshRoot = !!object3d.children.find((c5) => c5.isSkinnedMesh);
      if (isSkinnedMeshRoot) {
        const node = registerNode("skinnedmesh", {
          id: object3d.name,
          object3d,
          animations: glb.animations,
          castShadow: props.castShadow,
          receiveShadow: props.receiveShadow,
          active: props.active,
          position: object3d.position.toArray(),
          quaternion: object3d.quaternion.toArray(),
          scale: object3d.scale.toArray()
        });
        if (parentNode.name === "lod" && props.maxDistance) {
          parentNode.insert(node, props.maxDistance);
        } else {
          parentNode.add(node);
        }
      } else if (props.node === "snap") {
        const node = registerNode("snap", {
          id: object3d.name,
          position: object3d.position.toArray(),
          quaternion: object3d.quaternion.toArray(),
          scale: object3d.scale.toArray()
        });
        parentNode.add(node);
        parse3(object3d.children, node);
      } else if (props.node === "lod") {
        const node = registerNode("lod", {
          id: object3d.name,
          position: object3d.position.toArray(),
          quaternion: object3d.quaternion.toArray(),
          scale: object3d.scale.toArray()
        });
        parentNode.add(node);
        parse3(object3d.children, node);
      } else if (props.node === "rigidbody") {
        const node = registerNode("rigidbody", {
          id: object3d.name,
          type: props.type,
          mass: props.mass,
          position: object3d.position.toArray(),
          quaternion: object3d.quaternion.toArray(),
          scale: object3d.scale.toArray()
        });
        parentNode.add(node);
        parse3(object3d.children, node);
      } else if (props.node === "collider" && object3d.isMesh) {
        const node = registerNode("collider", {
          id: object3d.name,
          type: "geometry",
          geometry: object3d.geometry,
          convex: props.convex,
          trigger: props.trigger,
          position: object3d.position.toArray(),
          quaternion: object3d.quaternion.toArray(),
          scale: object3d.scale.toArray()
        });
        parentNode.add(node);
        parse3(object3d.children, node);
      } else if (object3d.type === "Mesh") {
        if (object3d.material.userData.wind) {
          addWind(object3d, world2);
        }
        const hasMorphTargets = object3d.morphTargetDictionary || object3d.morphTargetInfluences?.length > 0;
        const node = registerNode("mesh", {
          id: object3d.name,
          type: "geometry",
          geometry: object3d.geometry,
          material: object3d.material,
          linked: !hasMorphTargets,
          castShadow: props.castShadow,
          receiveShadow: props.receiveShadow,
          visible: props.visible,
          // DEPRECATED: use Node.active
          active: props.active,
          position: object3d.position.toArray(),
          quaternion: object3d.quaternion.toArray(),
          scale: object3d.scale.toArray()
        });
        if (parentNode.name === "lod" && props.maxDistance) {
          parentNode.insert(node, props.maxDistance);
        } else {
          parentNode.add(node);
        }
        parse3(object3d.children, node);
      } else if (object3d.type === "SkinnedMesh") {
      } else if (groupTypes.includes(object3d.type)) {
        const node = registerNode("group", {
          id: object3d.name,
          position: object3d.position.toArray(),
          quaternion: object3d.quaternion.toArray(),
          scale: object3d.scale.toArray()
        });
        parentNode.add(node);
        parse3(object3d.children, node);
      }
    }
  }
  const root = registerNode("group", {
    id: "$root"
  });
  parse3(glb.scene.children, root);
  return root;
}
function addWind(mesh, world2) {
  if (!world2.wind) return;
  const uniforms = world2.wind.uniforms;
  if (mesh.material.hasWind) return;
  mesh.material.hasWind = true;
  mesh.material.onBeforeCompile = (shader) => {
    if (!shader.defines) shader.defines = {};
    shader.defines.USE_WIND = 1;
    shader.uniforms.time = uniforms.time;
    shader.uniforms.strength = uniforms.strength;
    shader.uniforms.direction = uniforms.direction;
    shader.uniforms.speed = uniforms.speed;
    shader.uniforms.noiseScale = uniforms.noiseScale;
    shader.uniforms.ampScale = uniforms.ampScale;
    shader.uniforms.freqMultiplier = uniforms.freqMultiplier;
    const height = mesh.geometry.boundingBox.max.y * mesh.scale.y;
    shader.uniforms.height = { value: height };
    shader.uniforms.stiffness = { value: 0 };
    shader.vertexShader = shader.vertexShader.replace(
      "#include <common>",
      `
      uniform float time;
      uniform float strength;
      uniform vec3 direction;
      uniform float speed;
      uniform float noiseScale;
      uniform float ampScale;
      uniform float freqMultiplier;

      uniform float height;
      uniform float stiffness;

      ${snoise}

      #include <common>
      `
    );
    shader.vertexShader = shader.vertexShader.replace(
      "#include <begin_vertex>",
      `
      #include <begin_vertex>

      #ifdef USE_WIND
        vec4 worldPos = vec4(position, 1.0);
        #ifdef USE_INSTANCING
          worldPos = instanceMatrix * worldPos;
        #endif
        worldPos = modelMatrix * worldPos;

        float heightFactor = position.y / height;
        float noiseFactor = snoise(worldPos.xyz * noiseScale + time * speed);
        vec3 displacement = sin(time * freqMultiplier + worldPos.xyz) * noiseFactor * ampScale * heightFactor * (1.0 - stiffness);
        transformed += strength * displacement * direction;
      #endif
      `
    );
  };
}
var snoise = `
  //	Simplex 3D Noise 
  //	by Ian McEwan, Stefan Gustavson (https://github.com/stegu/webgl-noise)
  //
  vec4 permute(vec4 x){
    return mod(((x*34.0)+1.0)*x, 289.0);
  }
  vec4 taylorInvSqrt(vec4 r){ 
    return 1.79284291400159 - 0.85373472095314 * r; 
  }

  float snoise(vec3 v){ 
  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

  // First corner
  vec3 i  = floor(v + dot(v, C.yyy) );
  vec3 x0 =   v - i + dot(i, C.xxx) ;

  // Other corners
  vec3 g = step(x0.yzx, x0.xyz);
  vec3 l = 1.0 - g;
  vec3 i1 = min( g.xyz, l.zxy );
  vec3 i2 = max( g.xyz, l.zxy );

  //  x0 = x0 - 0. + 0.0 * C 
  vec3 x1 = x0 - i1 + 1.0 * C.xxx;
  vec3 x2 = x0 - i2 + 2.0 * C.xxx;
  vec3 x3 = x0 - 1. + 3.0 * C.xxx;

  // Permutations
  i = mod(i, 289.0 ); 
  vec4 p = permute( permute( permute( 
      i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
    + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
    + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

  // Gradients
  // ( N*N points uniformly over a square, mapped onto an octahedron.)
  float n_ = 1.0/7.0; // N=7
  vec3  ns = n_ * D.wyz - D.xzx;

  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)

  vec4 x_ = floor(j * ns.z);
  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

  vec4 x = x_ *ns.x + ns.yyyy;
  vec4 y = y_ *ns.x + ns.yyyy;
  vec4 h = 1.0 - abs(x) - abs(y);

  vec4 b0 = vec4( x.xy, y.xy );
  vec4 b1 = vec4( x.zw, y.zw );

  vec4 s0 = floor(b0)*2.0 + 1.0;
  vec4 s1 = floor(b1)*2.0 + 1.0;
  vec4 sh = -step(h, vec4(0.0));

  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

  vec3 p0 = vec3(a0.xy,h.x);
  vec3 p1 = vec3(a0.zw,h.y);
  vec3 p2 = vec3(a1.xy,h.z);
  vec3 p3 = vec3(a1.zw,h.w);

  //Normalise gradients
  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
  p0 *= norm.x;
  p1 *= norm.y;
  p2 *= norm.z;
  p3 *= norm.w;

  // Mix final noise value
  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
  m = m * m;
  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
                                dot(p2,x2), dot(p3,x3) ) );
  }
`;

// src/core/extras/createEmoteFactory.js
import * as THREE6 from "three";
var q16 = new THREE6.Quaternion();
var restRotationInverse = new THREE6.Quaternion();
var parentRestWorldRotation = new THREE6.Quaternion();
function createEmoteFactory(glb, url) {
  const clip = glb.animations[0];
  const scale = glb.scene.children[0].scale.x;
  const yOffset = -0.05 / scale;
  let haveRoot;
  clip.tracks = clip.tracks.filter((track) => {
    if (track instanceof THREE6.VectorKeyframeTrack) {
      const [name2, type] = track.name.split(".");
      if (type !== "position") return;
      if (name2 === "Root") {
        haveRoot = true;
        return true;
      }
      if (name2 === "mixamorigHips") {
        return true;
      }
      return false;
    }
    return true;
  });
  clip.tracks.forEach((track) => {
    const trackSplitted = track.name.split(".");
    const mixamoRigName = trackSplitted[0];
    const mixamoRigNode = glb.scene.getObjectByName(mixamoRigName);
    mixamoRigNode.getWorldQuaternion(restRotationInverse).invert();
    mixamoRigNode.parent.getWorldQuaternion(parentRestWorldRotation);
    if (track instanceof THREE6.QuaternionKeyframeTrack) {
      for (let i5 = 0; i5 < track.values.length; i5 += 4) {
        const flatQuaternion = track.values.slice(i5, i5 + 4);
        q16.fromArray(flatQuaternion);
        q16.premultiply(parentRestWorldRotation).multiply(restRotationInverse);
        q16.toArray(flatQuaternion);
        flatQuaternion.forEach((v11, index) => {
          track.values[index + i5] = v11;
        });
      }
    } else if (track instanceof THREE6.VectorKeyframeTrack) {
      if (yOffset) {
        track.values = track.values.map((v11, i5) => {
          if (i5 % 3 === 1) {
            return v11 + yOffset;
          }
          return v11;
        });
      }
    }
  });
  clip.optimize();
  return {
    toClip({ rootToHips, version: version4, getBoneName }) {
      const height = rootToHips;
      const tracks = [];
      clip.tracks.forEach((track) => {
        const trackSplitted = track.name.split(".");
        const ogBoneName = trackSplitted[0];
        const vrmBoneName = normalizedBoneNames[ogBoneName];
        const vrmNodeName = getBoneName(vrmBoneName);
        const scaler = height * scale;
        if (vrmNodeName !== void 0) {
          const propertyName = trackSplitted[1];
          if (track instanceof THREE6.QuaternionKeyframeTrack) {
            tracks.push(
              new THREE6.QuaternionKeyframeTrack(
                `${vrmNodeName}.${propertyName}`,
                track.times,
                track.values.map((v11, i5) => version4 === "0" && i5 % 2 === 0 ? -v11 : v11)
              )
            );
          } else if (track instanceof THREE6.VectorKeyframeTrack) {
            tracks.push(
              new THREE6.VectorKeyframeTrack(
                `${vrmNodeName}.${propertyName}`,
                track.times,
                track.values.map((v11, i5) => {
                  return (version4 === "0" && i5 % 3 !== 1 ? -v11 : v11) * scaler;
                })
              )
            );
          }
        }
      });
      return new THREE6.AnimationClip(
        clip.name,
        // todo: name variable?
        clip.duration,
        tracks
      );
    }
  };
}
var normalizedBoneNames = {
  // vrm standard
  hips: "hips",
  spine: "spine",
  chest: "chest",
  upperChest: "upperChest",
  neck: "neck",
  head: "head",
  leftShoulder: "leftShoulder",
  leftUpperArm: "leftUpperArm",
  leftLowerArm: "leftLowerArm",
  leftHand: "leftHand",
  leftThumbProximal: "leftThumbProximal",
  leftThumbIntermediate: "leftThumbIntermediate",
  leftThumbDistal: "leftThumbDistal",
  leftIndexProximal: "leftIndexProximal",
  leftIndexIntermediate: "leftIndexIntermediate",
  leftIndexDistal: "leftIndexDistal",
  leftMiddleProximal: "leftMiddleProximal",
  leftMiddleIntermediate: "leftMiddleIntermediate",
  leftMiddleDistal: "leftMiddleDistal",
  leftRingProximal: "leftRingProximal",
  leftRingIntermediate: "leftRingIntermediate",
  leftRingDistal: "leftRingDistal",
  leftLittleProximal: "leftLittleProximal",
  leftLittleIntermediate: "leftLittleIntermediate",
  leftLittleDistal: "leftLittleDistal",
  rightShoulder: "rightShoulder",
  rightUpperArm: "rightUpperArm",
  rightLowerArm: "rightLowerArm",
  rightHand: "rightHand",
  rightLittleProximal: "rightLittleProximal",
  rightLittleIntermediate: "rightLittleIntermediate",
  rightLittleDistal: "rightLittleDistal",
  rightRingProximal: "rightRingProximal",
  rightRingIntermediate: "rightRingIntermediate",
  rightRingDistal: "rightRingDistal",
  rightMiddleProximal: "rightMiddleProximal",
  rightMiddleIntermediate: "rightMiddleIntermediate",
  rightMiddleDistal: "rightMiddleDistal",
  rightIndexProximal: "rightIndexProximal",
  rightIndexIntermediate: "rightIndexIntermediate",
  rightIndexDistal: "rightIndexDistal",
  rightThumbProximal: "rightThumbProximal",
  rightThumbIntermediate: "rightThumbIntermediate",
  rightThumbDistal: "rightThumbDistal",
  leftUpperLeg: "leftUpperLeg",
  leftLowerLeg: "leftLowerLeg",
  leftFoot: "leftFoot",
  leftToes: "leftToes",
  rightUpperLeg: "rightUpperLeg",
  rightLowerLeg: "rightLowerLeg",
  rightFoot: "rightFoot",
  rightToes: "rightToes",
  // vrm uploaded to mixamo
  // these are latest mixamo bone names
  Hips: "hips",
  Spine: "spine",
  Spine1: "chest",
  Spine2: "upperChest",
  Neck: "neck",
  Head: "head",
  LeftShoulder: "leftShoulder",
  LeftArm: "leftUpperArm",
  LeftForeArm: "leftLowerArm",
  LeftHand: "leftHand",
  LeftHandThumb1: "leftThumbProximal",
  LeftHandThumb2: "leftThumbIntermediate",
  LeftHandThumb3: "leftThumbDistal",
  LeftHandIndex1: "leftIndexProximal",
  LeftHandIndex2: "leftIndexIntermediate",
  LeftHandIndex3: "leftIndexDistal",
  LeftHandMiddle1: "leftMiddleProximal",
  LeftHandMiddle2: "leftMiddleIntermediate",
  LeftHandMiddle3: "leftMiddleDistal",
  LeftHandRing1: "leftRingProximal",
  LeftHandRing2: "leftRingIntermediate",
  LeftHandRing3: "leftRingDistal",
  LeftHandPinky1: "leftLittleProximal",
  LeftHandPinky2: "leftLittleIntermediate",
  LeftHandPinky3: "leftLittleDistal",
  RightShoulder: "rightShoulder",
  RightArm: "rightUpperArm",
  RightForeArm: "rightLowerArm",
  RightHand: "rightHand",
  RightHandPinky1: "rightLittleProximal",
  RightHandPinky2: "rightLittleIntermediate",
  RightHandPinky3: "rightLittleDistal",
  RightHandRing1: "rightRingProximal",
  RightHandRing2: "rightRingIntermediate",
  RightHandRing3: "rightRingDistal",
  RightHandMiddle1: "rightMiddleProximal",
  RightHandMiddle2: "rightMiddleIntermediate",
  RightHandMiddle3: "rightMiddleDistal",
  RightHandIndex1: "rightIndexProximal",
  RightHandIndex2: "rightIndexIntermediate",
  RightHandIndex3: "rightIndexDistal",
  RightHandThumb1: "rightThumbProximal",
  RightHandThumb2: "rightThumbIntermediate",
  RightHandThumb3: "rightThumbDistal",
  LeftUpLeg: "leftUpperLeg",
  LeftLeg: "leftLowerLeg",
  LeftFoot: "leftFoot",
  LeftToeBase: "leftToes",
  RightUpLeg: "rightUpperLeg",
  RightLeg: "rightLowerLeg",
  RightFoot: "rightFoot",
  RightToeBase: "rightToes",
  // these must be old mixamo names, prefixed with "mixamo"
  mixamorigHips: "hips",
  mixamorigSpine: "spine",
  mixamorigSpine1: "chest",
  mixamorigSpine2: "upperChest",
  mixamorigNeck: "neck",
  mixamorigHead: "head",
  mixamorigLeftShoulder: "leftShoulder",
  mixamorigLeftArm: "leftUpperArm",
  mixamorigLeftForeArm: "leftLowerArm",
  mixamorigLeftHand: "leftHand",
  mixamorigLeftHandThumb1: "leftThumbProximal",
  mixamorigLeftHandThumb2: "leftThumbIntermediate",
  mixamorigLeftHandThumb3: "leftThumbDistal",
  mixamorigLeftHandIndex1: "leftIndexProximal",
  mixamorigLeftHandIndex2: "leftIndexIntermediate",
  mixamorigLeftHandIndex3: "leftIndexDistal",
  mixamorigLeftHandMiddle1: "leftMiddleProximal",
  mixamorigLeftHandMiddle2: "leftMiddleIntermediate",
  mixamorigLeftHandMiddle3: "leftMiddleDistal",
  mixamorigLeftHandRing1: "leftRingProximal",
  mixamorigLeftHandRing2: "leftRingIntermediate",
  mixamorigLeftHandRing3: "leftRingDistal",
  mixamorigLeftHandPinky1: "leftLittleProximal",
  mixamorigLeftHandPinky2: "leftLittleIntermediate",
  mixamorigLeftHandPinky3: "leftLittleDistal",
  mixamorigRightShoulder: "rightShoulder",
  mixamorigRightArm: "rightUpperArm",
  mixamorigRightForeArm: "rightLowerArm",
  mixamorigRightHand: "rightHand",
  mixamorigRightHandPinky1: "rightLittleProximal",
  mixamorigRightHandPinky2: "rightLittleIntermediate",
  mixamorigRightHandPinky3: "rightLittleDistal",
  mixamorigRightHandRing1: "rightRingProximal",
  mixamorigRightHandRing2: "rightRingIntermediate",
  mixamorigRightHandRing3: "rightRingDistal",
  mixamorigRightHandMiddle1: "rightMiddleProximal",
  mixamorigRightHandMiddle2: "rightMiddleIntermediate",
  mixamorigRightHandMiddle3: "rightMiddleDistal",
  mixamorigRightHandIndex1: "rightIndexProximal",
  mixamorigRightHandIndex2: "rightIndexIntermediate",
  mixamorigRightHandIndex3: "rightIndexDistal",
  mixamorigRightHandThumb1: "rightThumbProximal",
  mixamorigRightHandThumb2: "rightThumbIntermediate",
  mixamorigRightHandThumb3: "rightThumbDistal",
  mixamorigLeftUpLeg: "leftUpperLeg",
  mixamorigLeftLeg: "leftLowerLeg",
  mixamorigLeftFoot: "leftFoot",
  mixamorigLeftToeBase: "leftToes",
  mixamorigRightUpLeg: "rightUpperLeg",
  mixamorigRightLeg: "rightLowerLeg",
  mixamorigRightFoot: "rightFoot",
  mixamorigRightToeBase: "rightToes"
};

// src/core/systems/ClientLoader.js
import { TextureLoader } from "three";
import Hls from "hls.js/dist/hls.js";
var ClientLoader = class extends System {
  constructor(world2) {
    super(world2);
    this.files = /* @__PURE__ */ new Map();
    this.promises = /* @__PURE__ */ new Map();
    this.results = /* @__PURE__ */ new Map();
    this.rgbeLoader = new RGBELoader();
    this.texLoader = new TextureLoader();
    this.gltfLoader = new GLTFLoader();
    this.gltfLoader.register((parser) => new VRMLoaderPlugin(parser));
    this.preloadItems = [];
  }
  start() {
    this.vrmHooks = {
      camera: this.world.camera,
      scene: this.world.stage.scene,
      octree: this.world.stage.octree,
      setupMaterial: this.world.setupMaterial,
      loader: this.world.loader
    };
  }
  has(type, url) {
    const key = `${type}/${url}`;
    return this.promises.has(key);
  }
  get(type, url) {
    const key = `${type}/${url}`;
    return this.results.get(key);
  }
  preload(type, url) {
    this.preloadItems.push({ type, url });
  }
  execPreload() {
    const promises2 = this.preloadItems.map((item) => this.load(item.type, item.url));
    this.preloader = Promise.allSettled(promises2).then(() => {
      this.preloader = null;
      this.world.emit("ready", true);
    });
  }
  setFile(url, file) {
    this.files.set(url, file);
  }
  getFile(url, name2) {
    url = this.world.resolveURL(url);
    if (name2) {
      const file = this.files.get(url);
      return new File([file], name2, {
        type: file.type,
        // Preserve the MIME type
        lastModified: file.lastModified
        // Preserve the last modified timestamp
      });
    }
    return this.files.get(url);
  }
  loadFile = async (url) => {
    url = this.world.resolveURL(url);
    if (this.files.has(url)) {
      return this.files.get(url);
    }
    const resp = await fetch(url);
    const blob = await resp.blob();
    const file = new File([blob], url.split("/").pop(), { type: blob.type });
    this.files.set(url, file);
    return file;
  };
  async load(type, url) {
    if (this.preloader) {
      await this.preloader;
    }
    const key = `${type}/${url}`;
    if (this.promises.has(key)) {
      return this.promises.get(key);
    }
    if (type === "video") {
      const promise4 = new Promise((resolve3) => {
        url = this.world.resolveURL(url);
        const factory = createVideoFactory(this.world, url);
        resolve3(factory);
      });
      this.promises.set(key, promise4);
      return promise4;
    }
    const promise3 = this.loadFile(url).then(async (file) => {
      if (type === "hdr") {
        const buffer2 = await file.arrayBuffer();
        const result = this.rgbeLoader.parse(buffer2);
        const texture = new three_exports.DataTexture(result.data, result.width, result.height);
        texture.colorSpace = three_exports.LinearSRGBColorSpace;
        texture.minFilter = three_exports.LinearFilter;
        texture.magFilter = three_exports.LinearFilter;
        texture.generateMipmaps = false;
        texture.flipY = true;
        texture.type = result.type;
        texture.needsUpdate = true;
        this.results.set(key, texture);
        return texture;
      }
      if (type === "image") {
        return new Promise((resolve3) => {
          const img = new Image();
          img.onload = () => {
            this.results.set(key, img);
            resolve3(img);
          };
          img.src = URL.createObjectURL(file);
        });
      }
      if (type === "texture") {
        return new Promise((resolve3) => {
          const img = new Image();
          img.onload = () => {
            const texture = this.texLoader.load(img.src);
            this.results.set(key, texture);
            resolve3(texture);
            URL.revokeObjectURL(img.src);
          };
          img.src = URL.createObjectURL(file);
        });
      }
      if (type === "model") {
        const buffer2 = await file.arrayBuffer();
        const glb = await this.gltfLoader.parseAsync(buffer2);
        const node = glbToNodes(glb, this.world);
        const model = {
          toNodes() {
            return node.clone(true);
          },
          getStats() {
            const stats = node.getStats(true);
            stats.fileBytes = file.size;
            return stats;
          }
        };
        this.results.set(key, model);
        return model;
      }
      if (type === "emote") {
        const buffer2 = await file.arrayBuffer();
        const glb = await this.gltfLoader.parseAsync(buffer2);
        const factory = createEmoteFactory(glb, url);
        const emote = {
          toClip(options) {
            return factory.toClip(options);
          }
        };
        this.results.set(key, emote);
        return emote;
      }
      if (type === "avatar") {
        const buffer2 = await file.arrayBuffer();
        const glb = await this.gltfLoader.parseAsync(buffer2);
        const factory = createVRMFactory(glb, this.world.setupMaterial);
        const hooks = this.vrmHooks;
        const node = createNode("group", { id: "$root" });
        const node2 = createNode("avatar", { id: "avatar", factory, hooks });
        node.add(node2);
        const avatar = {
          factory,
          hooks,
          toNodes(customHooks) {
            const clone3 = node.clone(true);
            if (customHooks) {
              clone3.get("avatar").hooks = customHooks;
            }
            return clone3;
          },
          getStats() {
            const stats = node.getStats(true);
            stats.fileBytes = file.size;
            return stats;
          }
        };
        this.results.set(key, avatar);
        return avatar;
      }
      if (type === "script") {
        const code = await file.text();
        const script = this.world.scripts.evaluate(code);
        this.results.set(key, script);
        return script;
      }
      if (type === "audio") {
        const buffer2 = await file.arrayBuffer();
        const audioBuffer = await this.world.audio.ctx.decodeAudioData(buffer2);
        this.results.set(key, audioBuffer);
        return audioBuffer;
      }
    });
    this.promises.set(key, promise3);
    return promise3;
  }
  insert(type, url, file) {
    const key = `${type}/${url}`;
    const localUrl = URL.createObjectURL(file);
    let promise3;
    if (type === "hdr") {
      promise3 = this.rgbeLoader.loadAsync(localUrl).then((texture) => {
        this.results.set(key, texture);
        return texture;
      });
    }
    if (type === "image") {
      promise3 = new Promise((resolve3) => {
        const img = new Image();
        img.onload = () => {
          this.results.set(key, img);
          resolve3(img);
        };
        img.src = localUrl;
      });
    }
    if (type === "video") {
      promise3 = new Promise((resolve3) => {
        const factory = createVideoFactory(this.world, localUrl);
        resolve3(factory);
      });
    }
    if (type === "texture") {
      promise3 = this.texLoader.loadAsync(localUrl).then((texture) => {
        this.results.set(key, texture);
        return texture;
      });
    }
    if (type === "model") {
      promise3 = this.gltfLoader.loadAsync(localUrl).then((glb) => {
        const node = glbToNodes(glb, this.world);
        const model = {
          toNodes() {
            return node.clone(true);
          },
          getStats() {
            const stats = node.getStats(true);
            stats.fileBytes = file.size;
            return stats;
          }
        };
        this.results.set(key, model);
        return model;
      });
    }
    if (type === "emote") {
      promise3 = this.gltfLoader.loadAsync(localUrl).then((glb) => {
        const factory = createEmoteFactory(glb, url);
        const emote = {
          toClip(options) {
            return factory.toClip(options);
          }
        };
        this.results.set(key, emote);
        return emote;
      });
    }
    if (type === "avatar") {
      promise3 = this.gltfLoader.loadAsync(localUrl).then((glb) => {
        const factory = createVRMFactory(glb, this.world.setupMaterial);
        const hooks = this.vrmHooks;
        const node = createNode("group", { id: "$root" });
        const node2 = createNode("avatar", { id: "avatar", factory, hooks });
        node.add(node2);
        const avatar = {
          factory,
          hooks,
          toNodes(customHooks) {
            const clone3 = node.clone(true);
            if (customHooks) {
              clone3.get("avatar").hooks = customHooks;
            }
            return clone3;
          },
          getStats() {
            const stats = node.getStats(true);
            stats.fileBytes = file.size;
            return stats;
          }
        };
        this.results.set(key, avatar);
        return avatar;
      });
    }
    if (type === "script") {
      promise3 = new Promise(async (resolve3, reject) => {
        try {
          const code = await file.text();
          const script = this.world.scripts.evaluate(code);
          this.results.set(key, script);
          resolve3(script);
        } catch (err) {
          reject(err);
        }
      });
    }
    if (type === "audio") {
      promise3 = new Promise(async (resolve3, reject) => {
        try {
          const arrayBuffer = await file.arrayBuffer();
          const audioBuffer = await this.world.audio.ctx.decodeAudioData(arrayBuffer);
          this.results.set(key, audioBuffer);
          resolve3(audioBuffer);
        } catch (err) {
          reject(err);
        }
      });
    }
    this.promises.set(key, promise3);
  }
};
function createVideoFactory(world2, url) {
  const isHLS = url?.endsWith(".m3u8");
  const sources = {};
  let width;
  let height;
  let duration;
  let ready = false;
  let prepare;
  function createSource(key) {
    const elem = document.createElement("video");
    elem.crossOrigin = "anonymous";
    elem.playsInline = true;
    elem.loop = false;
    elem.muted = true;
    elem.style.width = "1px";
    elem.style.height = "1px";
    elem.style.position = "absolute";
    elem.style.opacity = "0";
    elem.style.zIndex = "-1000";
    elem.style.pointerEvents = "none";
    elem.style.overflow = "hidden";
    const needsPolyfill = isHLS && !elem.canPlayType("application/vnd.apple.mpegurl") && Hls.isSupported();
    if (needsPolyfill) {
      const hls = new Hls();
      hls.loadSource(url);
      hls.attachMedia(elem);
    } else {
      elem.src = url;
    }
    const audio = world2.audio.ctx.createMediaElementSource(elem);
    let n6 = 0;
    let dead;
    world2.audio.ready(() => {
      if (dead) return;
      elem.muted = false;
    });
    const texture = new three_exports.VideoTexture(elem);
    texture.colorSpace = three_exports.SRGBColorSpace;
    texture.minFilter = three_exports.LinearFilter;
    texture.magFilter = three_exports.LinearFilter;
    texture.anisotropy = world2.graphics.maxAnisotropy;
    if (!prepare) {
      prepare = function() {
        return new Promise(async (resolve3) => {
          let playing = false;
          let data = false;
          elem.addEventListener(
            "loadeddata",
            async () => {
              if (playing) elem.pause();
              data = true;
              width = elem.videoWidth;
              height = elem.videoHeight;
              duration = elem.duration;
              ready = true;
              resolve3();
            },
            { once: true }
          );
          elem.addEventListener(
            "loadedmetadata",
            async () => {
              if (data) return;
              elem.play();
              playing = true;
            },
            { once: true }
          );
        });
      }();
    }
    function isPlaying() {
      return elem.currentTime > 0 && !elem.paused && !elem.ended && elem.readyState > 2;
    }
    function play(restartIfPlaying = false) {
      if (restartIfPlaying) elem.currentTime = 0;
      elem.play();
    }
    function pause() {
      elem.pause();
    }
    function stop() {
      elem.currentTime = 0;
      elem.pause();
    }
    function release3() {
      n6--;
      if (n6 === 0) {
        stop();
        audio.disconnect();
        texture.dispose();
        document.body.removeChild(elem);
        delete sources[key];
        elem.src = "";
        elem.load();
      }
    }
    const handle = {
      elem,
      audio,
      texture,
      prepare,
      get ready() {
        return ready;
      },
      get width() {
        return width;
      },
      get height() {
        return height;
      },
      get duration() {
        return duration;
      },
      get loop() {
        return elem.loop;
      },
      set loop(value) {
        elem.loop = value;
      },
      get isPlaying() {
        return isPlaying();
      },
      get currentTime() {
        return elem.currentTime;
      },
      set currentTime(value) {
        elem.currentTime = value;
      },
      play,
      pause,
      stop,
      release: release3
    };
    return {
      createHandle() {
        n6++;
        if (n6 === 1) {
          document.body.appendChild(elem);
        }
        return handle;
      }
    };
  }
  return {
    get(key) {
      let source = sources[key];
      if (!source) {
        source = createSource(key);
        sources[key] = source;
      }
      return source.createHandle();
    }
  };
}

// src/core/systems/ClientGraphics.js
import {
  EffectComposer,
  EffectPass,
  RenderPass,
  SMAAPreset,
  SMAAEffect,
  ToneMappingEffect,
  ToneMappingMode,
  SelectiveBloomEffect,
  BlendFunction,
  Selection
} from "postprocessing";
var v19 = new Vector3Enhanced();
var renderer;
function getRenderer() {
  if (!renderer) {
    renderer = new three_exports.WebGLRenderer({
      powerPreference: "high-performance",
      antialias: true
      // logarithmicDepthBuffer: true,
      // reverseDepthBuffer: true,
    });
  }
  return renderer;
}
var ClientGraphics = class extends System {
  constructor(world2) {
    super(world2);
  }
  async init({ viewport }) {
    this.viewport = viewport;
    this.width = this.viewport.offsetWidth;
    this.height = this.viewport.offsetHeight;
    this.aspect = this.width / this.height;
    this.renderer = getRenderer();
    this.renderer.setSize(this.width, this.height);
    this.renderer.setClearColor(16777215, 0);
    this.renderer.setPixelRatio(this.world.prefs.dpr);
    this.renderer.shadowMap.enabled = true;
    this.renderer.shadowMap.type = three_exports.PCFSoftShadowMap;
    this.renderer.toneMapping = three_exports.NoToneMapping;
    this.renderer.toneMappingExposure = 1;
    this.renderer.outputColorSpace = three_exports.SRGBColorSpace;
    this.renderer.xr.enabled = true;
    this.renderer.xr.setReferenceSpaceType("local-floor");
    this.renderer.xr.setFoveation(1);
    this.maxAnisotropy = this.renderer.capabilities.getMaxAnisotropy();
    three_exports.Texture.DEFAULT_ANISOTROPY = this.maxAnisotropy;
    this.usePostprocessing = this.world.prefs.postprocessing;
    const context = this.renderer.getContext();
    const maxMultisampling = context.getParameter(context.MAX_SAMPLES);
    this.composer = new EffectComposer(this.renderer, {
      frameBufferType: three_exports.HalfFloatType,
      multisampling: Math.min(8, maxMultisampling)
    });
    this.renderPass = new RenderPass(this.world.stage.scene, this.world.camera);
    this.composer.addPass(this.renderPass);
    this.bloom = new SelectiveBloomEffect(this.world.stage.scene, this.world.camera, {
      blendFunction: BlendFunction.ADD,
      mipmapBlur: true,
      luminanceThreshold: 1,
      luminanceSmoothing: 0.3,
      intensity: 0.5,
      radius: 0.8
    });
    this.bloom.inverted = true;
    this.bloom.selection.layer = 14;
    this.bloomPass = new EffectPass(this.world.camera, this.bloom);
    this.bloomPass.enabled = this.world.prefs.bloom;
    this.composer.addPass(this.bloomPass);
    this.effectPass = new EffectPass(
      this.world.camera,
      new SMAAEffect({
        preset: SMAAPreset.ULTRA
      }),
      new ToneMappingEffect({
        mode: ToneMappingMode.ACES_FILMIC
      })
    );
    this.composer.addPass(this.effectPass);
    this.world.prefs.on("change", this.onPrefsChange);
    this.resizer = new ResizeObserver(() => {
      this.resize(this.viewport.offsetWidth, this.viewport.offsetHeight);
    });
    this.viewport.appendChild(this.renderer.domElement);
    this.resizer.observe(this.viewport);
    this.xrWidth = null;
    this.xrHeight = null;
    this.xrDimensionsNeeded = false;
  }
  start() {
    this.world.on("xrSession", this.onXRSession);
  }
  resize(width, height) {
    this.width = width;
    this.height = height;
    this.aspect = this.width / this.height;
    this.world.camera.aspect = this.aspect;
    this.world.camera.updateProjectionMatrix();
    this.renderer.setSize(this.width, this.height);
    this.composer.setSize(this.width, this.height);
    this.emit("resize");
    this.render();
  }
  render() {
    if (this.renderer.xr.isPresenting || !this.usePostprocessing) {
      this.renderer.render(this.world.stage.scene, this.world.camera);
    } else {
      this.composer.render();
    }
    if (this.xrDimensionsNeeded) {
      this.checkXRDimensions();
    }
  }
  commit() {
    this.render();
  }
  preTick() {
    const camera = this.world.camera;
    const fovRadians = camera.fov * (Math.PI / 180);
    const rendererHeight = this.xrHeight || this.height;
    this.worldToScreenFactor = Math.tan(fovRadians / 2) * 2 / rendererHeight;
  }
  scaleUI(object3d, heightPx, pxToMeters) {
    const camera = this.world.camera;
    const vFov = camera.fov * Math.PI / 180;
    const screenHeight = this.height;
    const distance = object3d.position.distanceTo(v19.setFromMatrixPosition(camera.matrixWorld));
    const heightAtDistance = 2 * Math.tan(vFov / 2) * distance;
    const worldUnitsPerPixel = heightAtDistance / screenHeight;
    const desiredWorldHeight = heightPx * worldUnitsPerPixel;
    const scale = desiredWorldHeight / (heightPx * pxToMeters);
    object3d.scale.setScalar(scale);
  }
  onPrefsChange = (changes) => {
    if (changes.dpr) {
      this.renderer.setPixelRatio(changes.dpr.value);
      this.resize(this.width, this.height);
    }
    if (changes.postprocessing) {
      this.usePostprocessing = changes.postprocessing.value;
    }
    if (changes.bloom) {
      this.bloomPass.enabled = changes.bloom.value;
    }
  };
  onXRSession = (session) => {
    if (session) {
      this.xrSession = session;
      this.xrWidth = null;
      this.xrHeight = null;
      this.xrDimensionsNeeded = true;
    } else {
      this.xrSession = null;
      this.xrWidth = null;
      this.xrHeight = null;
      this.xrDimensionsNeeded = false;
    }
  };
  checkXRDimensions = () => {
    const referenceSpace = this.renderer.xr.getReferenceSpace();
    const frame = this.renderer.xr.getFrame();
    if (frame && referenceSpace) {
      const views = frame.getViewerPose(referenceSpace)?.views;
      if (views && views.length > 0) {
        const projectionMatrix = views[0].projectionMatrix;
        const fovFactor = projectionMatrix[5];
        const renderState = this.xrSession.renderState;
        const baseLayer = renderState.baseLayer;
        if (baseLayer) {
          this.xrWidth = baseLayer.framebufferWidth;
          this.xrHeight = baseLayer.framebufferHeight;
          this.xrDimensionsNeeded = false;
          console.log({ xrWidth: this.xrWidth, xrHeight: this.xrHeight });
        }
      }
    }
  };
  destroy() {
    this.resizer.disconnect();
  }
};

// src/core/libs/csm/CSM.js
import * as three from "three";
var lightParsBeginInitial = three.ShaderChunk.lights_pars_begin;
var CSMShader = {
  lights_fragment_begin: (cascades) => (
    /* glsl */
    `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );

vec3 geometryClearcoatNormal;

#ifdef CLEARCOAT

geometryClearcoatNormal = clearcoatNormal;

#endif

IncidentLight directLight;

#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )

	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {

		pointLight = pointLights[ i ];

		getPointLightInfo( pointLight, geometryPosition, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )

	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {

		spotLight = spotLights[ i ];

		getSpotLightInfo( spotLight, geometryPosition, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_DIR_LIGHTS > 0) && defined( RE_Direct ) && defined( USE_CSM ) && defined( CSM_CASCADES )

	DirectionalLight directionalLight;
	float linearDepth = (vViewPosition.z) / (shadowFar - cameraNear);
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#if defined( USE_SHADOWMAP ) && defined( CSM_FADE )
	vec2 cascade;
	float cascadeCenter;
	float closestEdge;
	float margin;
	float csmx;
	float csmy;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );

	  	#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
			// NOTE: Depth gets larger away from the camera.
			// cascade.x is closer, cascade.y is further

				#if ( UNROLLED_LOOP_INDEX < ${cascades} )

					// NOTE: Apply CSM shadows

					cascade = CSM_cascades[ i ];
					cascadeCenter = ( cascade.x + cascade.y ) / 2.0;
					closestEdge = linearDepth < cascadeCenter ? cascade.x : cascade.y;
					margin = 0.25 * pow( closestEdge, 2.0 );
					csmx = cascade.x - margin / 2.0;
					csmy = cascade.y + margin / 2.0;
					if( linearDepth >= csmx && ( linearDepth < csmy || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 ) ) {

						float dist = min( linearDepth - csmx, csmy - linearDepth );
						float ratio = clamp( dist / margin, 0.0, 1.0 );

						vec3 prevColor = directLight.color;
						directionalLightShadow = directionalLightShadows[ i ];
						directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

						bool shouldFadeLastCascade = UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth > cascadeCenter;
						directLight.color = mix( prevColor, directLight.color, shouldFadeLastCascade ? ratio : 1.0 );

						ReflectedLight prevLight = reflectedLight;
						RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

						bool shouldBlend = UNROLLED_LOOP_INDEX != CSM_CASCADES - 1 || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth < cascadeCenter;
						float blendRatio = shouldBlend ? ratio : 1.0;

						reflectedLight.directDiffuse = mix( prevLight.directDiffuse, reflectedLight.directDiffuse, blendRatio );
						reflectedLight.directSpecular = mix( prevLight.directSpecular, reflectedLight.directSpecular, blendRatio );
						reflectedLight.indirectDiffuse = mix( prevLight.indirectDiffuse, reflectedLight.indirectDiffuse, blendRatio );
						reflectedLight.indirectSpecular = mix( prevLight.indirectSpecular, reflectedLight.indirectSpecular, blendRatio );

					}

				#else

					// NOTE: Apply the reminder of directional lights

					directionalLightShadow = directionalLightShadows[ i ];
					directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

					RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal,, material, reflectedLight );

				#endif

	  	#endif

	}
	#pragma unroll_loop_end
	#else

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

			directionalLight = directionalLights[ i ];
			getDirectionalLightInfo( directionalLight, directLight );

			#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )

				#if ( UNROLLED_LOOP_INDEX < ${cascades} )

					// NOTE: Apply CSM shadows

					directionalLightShadow = directionalLightShadows[ i ];
					if(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y) directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

					if(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && (linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1)) RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

				#else

					// NOTE: Apply the reminder of directional lights

					directionalLightShadow = directionalLightShadows[ i ];
					directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;

					RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

				#endif

			#endif

		}
		#pragma unroll_loop_end

	#endif

	#if ( NUM_DIR_LIGHTS > NUM_DIR_LIGHT_SHADOWS)
		// compute the lights not casting shadows (if any)

		#pragma unroll_loop_start
		for ( int i = NUM_DIR_LIGHT_SHADOWS; i < NUM_DIR_LIGHTS; i ++ ) {

			directionalLight = directionalLights[ i ];

			getDirectionalLightInfo( directionalLight, directLight );

			RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

		}
		#pragma unroll_loop_end

	#endif

#endif


#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && !defined( USE_CSM ) && !defined( CSM_CASCADES )

	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {

		directionalLight = directionalLights[ i ];

		getDirectionalLightInfo( directionalLight, directLight );

		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif

		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )

	RectAreaLight rectAreaLight;

	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {

		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );

	}
	#pragma unroll_loop_end

#endif

#if defined( RE_IndirectDiffuse )

	vec3 iblIrradiance = vec3( 0.0 );

	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );

	#if defined( USE_LIGHT_PROBES )

		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );

	#endif

	#if ( NUM_HEMI_LIGHTS > 0 )

		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {

				irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );

		}
		#pragma unroll_loop_end

	#endif

#endif

#if defined( RE_IndirectSpecular )

	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );

#endif
`
  ),
  lights_pars_begin: (maxCascades) => (
    /* glsl */
    `
#if defined( USE_CSM ) && defined( CSM_CASCADES )
uniform vec2 CSM_cascades[${maxCascades}]; // This value is the max. number supported of cascades
uniform float cameraNear;
uniform float shadowFar;
#endif
	` + lightParsBeginInitial
  )
};
var CSMHelper = class extends three.Group {
  constructor(csm) {
    super();
    this.displayFrustum = true;
    this.displayPlanes = true;
    this.displayShadowBounds = true;
    this.cascadeLines = [];
    this.cascadePlanes = [];
    this.shadowLines = [];
    this.csm = csm;
    const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
    const positions = new Float32Array(24);
    const frustumGeometry = new three.BufferGeometry();
    frustumGeometry.setIndex(new three.BufferAttribute(indices, 1));
    frustumGeometry.setAttribute("position", new three.BufferAttribute(positions, 3, false));
    const frustumLines = new three.LineSegments(frustumGeometry, new three.LineBasicMaterial());
    this.add(frustumLines);
    this.frustumLines = frustumLines;
  }
  updateVisibility() {
    const displayFrustum = this.displayFrustum;
    const displayPlanes = this.displayPlanes;
    const displayShadowBounds = this.displayShadowBounds;
    const frustumLines = this.frustumLines;
    const cascadeLines = this.cascadeLines;
    const cascadePlanes = this.cascadePlanes;
    const shadowLines = this.shadowLines;
    for (let i5 = 0, l5 = cascadeLines.length; i5 < l5; i5++) {
      const cascadeLine = cascadeLines[i5];
      const cascadePlane = cascadePlanes[i5];
      const shadowLineGroup = shadowLines[i5];
      cascadeLine.visible = displayFrustum;
      cascadePlane.visible = displayFrustum && displayPlanes;
      shadowLineGroup.visible = displayShadowBounds;
    }
    frustumLines.visible = displayFrustum;
  }
  update() {
    const csm = this.csm;
    const camera = csm.camera;
    const cascades = csm.cascades;
    const mainFrustum = csm.mainFrustum;
    const frustums = csm.frustums;
    const lights = csm.lights;
    const frustumLines = this.frustumLines;
    const frustumLinePositions = frustumLines.geometry.getAttribute("position");
    const cascadeLines = this.cascadeLines;
    const cascadePlanes = this.cascadePlanes;
    const shadowLines = this.shadowLines;
    this.position.copy(camera.position);
    this.quaternion.copy(camera.quaternion);
    this.scale.copy(camera.scale);
    this.updateMatrixWorld(true);
    while (cascadeLines.length > cascades) {
      this.remove(cascadeLines.pop());
      this.remove(cascadePlanes.pop());
      this.remove(shadowLines.pop());
    }
    while (cascadeLines.length < cascades) {
      const cascadeLine = new three.Box3Helper(new three.Box3(), new three.Color(16777215));
      const planeMat = new three.MeshBasicMaterial({
        transparent: true,
        opacity: 0.1,
        depthWrite: false,
        side: three.DoubleSide
      });
      const cascadePlane = new three.Mesh(new three.PlaneGeometry(), planeMat);
      const shadowLineGroup = new three.Group();
      const shadowLine = new three.Box3Helper(new three.Box3(), new three.Color(16776960));
      shadowLineGroup.add(shadowLine);
      this.add(cascadeLine);
      this.add(cascadePlane);
      this.add(shadowLineGroup);
      cascadeLines.push(cascadeLine);
      cascadePlanes.push(cascadePlane);
      shadowLines.push(shadowLineGroup);
    }
    for (let i5 = 0; i5 < cascades; i5++) {
      const frustum = frustums[i5];
      const light = lights[i5];
      const shadowCam = light.shadow.camera;
      const farVerts2 = frustum.vertices.far;
      const cascadeLine = cascadeLines[i5];
      const cascadePlane = cascadePlanes[i5];
      const shadowLineGroup = shadowLines[i5];
      const shadowLine = shadowLineGroup.children[0];
      cascadeLine.box.min.copy(farVerts2[2]);
      cascadeLine.box.max.copy(farVerts2[0]);
      cascadeLine.box.max.z += 1e-4;
      cascadePlane.position.addVectors(farVerts2[0], farVerts2[2]);
      cascadePlane.position.multiplyScalar(0.5);
      cascadePlane.scale.subVectors(farVerts2[0], farVerts2[2]);
      cascadePlane.scale.z = 1e-4;
      this.remove(shadowLineGroup);
      shadowLineGroup.position.copy(shadowCam.position);
      shadowLineGroup.quaternion.copy(shadowCam.quaternion);
      shadowLineGroup.scale.copy(shadowCam.scale);
      shadowLineGroup.updateMatrixWorld(true);
      this.attach(shadowLineGroup);
      shadowLine.box.min.set(shadowCam.bottom, shadowCam.left, -shadowCam.far);
      shadowLine.box.max.set(shadowCam.top, shadowCam.right, -shadowCam.near);
    }
    const nearVerts = mainFrustum.vertices.near;
    const farVerts = mainFrustum.vertices.far;
    frustumLinePositions.setXYZ(0, farVerts[0].x, farVerts[0].y, farVerts[0].z);
    frustumLinePositions.setXYZ(1, farVerts[3].x, farVerts[3].y, farVerts[3].z);
    frustumLinePositions.setXYZ(2, farVerts[2].x, farVerts[2].y, farVerts[2].z);
    frustumLinePositions.setXYZ(3, farVerts[1].x, farVerts[1].y, farVerts[1].z);
    frustumLinePositions.setXYZ(4, nearVerts[0].x, nearVerts[0].y, nearVerts[0].z);
    frustumLinePositions.setXYZ(5, nearVerts[3].x, nearVerts[3].y, nearVerts[3].z);
    frustumLinePositions.setXYZ(6, nearVerts[2].x, nearVerts[2].y, nearVerts[2].z);
    frustumLinePositions.setXYZ(7, nearVerts[1].x, nearVerts[1].y, nearVerts[1].z);
    frustumLinePositions.needsUpdate = true;
  }
};
var inverseProjectionMatrix = new three.Matrix4();
var CSMFrustum = class _CSMFrustum {
  constructor(data = {}) {
    this.vertices = {
      near: [new three.Vector3(), new three.Vector3(), new three.Vector3(), new three.Vector3()],
      far: [new three.Vector3(), new three.Vector3(), new three.Vector3(), new three.Vector3()]
    };
    if (data.projectionMatrix !== void 0) {
      this.setFromProjectionMatrix(data.projectionMatrix, data.maxFar || 1e4);
    }
  }
  setFromProjectionMatrix(projectionMatrix, maxFar) {
    const isOrthographic = projectionMatrix.elements[2 * 4 + 3] === 0;
    inverseProjectionMatrix.copy(projectionMatrix).invert();
    this.vertices.near[0].set(1, 1, -1);
    this.vertices.near[1].set(1, -1, -1);
    this.vertices.near[2].set(-1, -1, -1);
    this.vertices.near[3].set(-1, 1, -1);
    this.vertices.near.forEach(function(v11) {
      v11.applyMatrix4(inverseProjectionMatrix);
    });
    this.vertices.far[0].set(1, 1, 1);
    this.vertices.far[1].set(1, -1, 1);
    this.vertices.far[2].set(-1, -1, 1);
    this.vertices.far[3].set(-1, 1, 1);
    this.vertices.far.forEach(function(v11) {
      v11.applyMatrix4(inverseProjectionMatrix);
      const absZ = Math.abs(v11.z);
      if (isOrthographic) {
        v11.z *= Math.min(maxFar / absZ, 1);
      } else {
        v11.multiplyScalar(Math.min(maxFar / absZ, 1));
      }
    });
    return this.vertices;
  }
  split(breaks, target) {
    while (breaks.length > target.length) {
      target.push(new _CSMFrustum());
    }
    target.length = breaks.length;
    for (let i5 = 0; i5 < breaks.length; i5++) {
      const cascade = target[i5];
      if (i5 === 0) {
        for (let j4 = 0; j4 < 4; j4++) {
          cascade.vertices.near[j4].copy(this.vertices.near[j4]);
        }
      } else {
        for (let j4 = 0; j4 < 4; j4++) {
          cascade.vertices.near[j4].lerpVectors(this.vertices.near[j4], this.vertices.far[j4], breaks[i5 - 1]);
        }
      }
      if (i5 === breaks.length - 1) {
        for (let j4 = 0; j4 < 4; j4++) {
          cascade.vertices.far[j4].copy(this.vertices.far[j4]);
        }
      } else {
        for (let j4 = 0; j4 < 4; j4++) {
          cascade.vertices.far[j4].lerpVectors(this.vertices.near[j4], this.vertices.far[j4], breaks[i5]);
        }
      }
    }
  }
  toSpace(cameraMatrix, target) {
    for (let i5 = 0; i5 < 4; i5++) {
      target.vertices.near[i5].copy(this.vertices.near[i5]).applyMatrix4(cameraMatrix);
      target.vertices.far[i5].copy(this.vertices.far[i5]).applyMatrix4(cameraMatrix);
    }
  }
};
function uniformSplit(amount, near, far, target) {
  for (let i5 = 1; i5 < amount; i5++) {
    target.push((near + (far - near) * i5 / amount) / far);
  }
  target.push(1);
}
function logarithmicSplit(amount, near, far, target) {
  for (let i5 = 1; i5 < amount; i5++) {
    target.push(near * Math.pow(far / near, i5 / amount) / far);
  }
  target.push(1);
}
function practicalSplit(amount, near, far, lambda, target) {
  _uniformArray.length = 0;
  _logArray.length = 0;
  logarithmicSplit(amount, near, far, _logArray);
  uniformSplit(amount, near, far, _uniformArray);
  for (let i5 = 1; i5 < amount; i5++) {
    target.push(three.MathUtils.lerp(_uniformArray[i5 - 1], _logArray[i5 - 1], lambda));
  }
  target.push(1);
}
var _origin = new three.Vector3(0, 0, 0);
var _lightOrientationMatrix = new three.Matrix4();
var _lightOrientationMatrixInverse = new three.Matrix4();
var _cameraToLightParentMatrix = new three.Matrix4();
var _cameraToLightMatrix = new three.Matrix4();
var _lightSpaceFrustum = new CSMFrustum();
var _center = new three.Vector3();
var _bbox = new three.Box3();
var _uniformArray = [];
var _logArray = [];
var CSM = class {
  constructor(data) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
    this.mainFrustum = new CSMFrustum();
    this.frustums = [];
    this.breaks = [];
    this.lights = [];
    this.shaders = /* @__PURE__ */ new Map();
    this.camera = data.camera;
    this.parent = data.parent;
    this.cascades = (_a = data.cascades) !== null && _a !== void 0 ? _a : 3;
    this.maxCascades = (_b = data.maxCascades) !== null && _b !== void 0 ? _b : data.cascades;
    this.maxFar = (_c = data.maxFar) !== null && _c !== void 0 ? _c : 1e5;
    this.mode = (_d = data.mode) !== null && _d !== void 0 ? _d : "practical";
    this.practicalModeLambda = (_e = data.practicalModeLambda) !== null && _e !== void 0 ? _e : 0.5;
    this.shadowMapSize = (_f = data.shadowMapSize) !== null && _f !== void 0 ? _f : 2048;
    this.shadowBias = (_g = data.shadowBias) !== null && _g !== void 0 ? _g : 0;
    this.shadowNormalBias = (_h = data.shadowNormalBias) !== null && _h !== void 0 ? _h : 0;
    this.lightDirection = (_j = data.lightDirection) !== null && _j !== void 0 ? _j : new three.Vector3(1, -1, 1).normalize();
    this.lightDirectionUp = (_k = data.lightDirectionUp) !== null && _k !== void 0 ? _k : three.Object3D.DEFAULT_UP;
    this.lightIntensity = (_l = data.lightIntensity) !== null && _l !== void 0 ? _l : 1;
    this.lightColor = (_m = data.lightColor) !== null && _m !== void 0 ? _m : new three.Color(16777215);
    this.lightMargin = (_o = data.lightMargin) !== null && _o !== void 0 ? _o : 200;
    this.fade = (_p = data.fade) !== null && _p !== void 0 ? _p : false;
    this.noLastCascadeCutOff = (_q = data.noLastCascadeCutOff) !== null && _q !== void 0 ? _q : false;
    this.customSplitsCallback = data.customSplitsCallback;
    this.createLights();
    this.updateFrustums();
    this.injectInclude();
  }
  createLights() {
    for (let i5 = 0; i5 < this.cascades; i5++) {
      const light = new three.DirectionalLight(this.lightColor, this.lightIntensity);
      light.castShadow = true;
      light.shadow.mapSize.width = this.shadowMapSize;
      light.shadow.mapSize.height = this.shadowMapSize;
      light.shadow.camera.near = 0;
      light.shadow.camera.far = 1;
      this.parent.add(light.target);
      this.lights.push(light);
    }
    for (let i5 = this.lights.length - 1; i5 >= 0; i5--) {
      const light = this.lights[i5];
      light.parent = this.parent;
      this.parent.children.unshift(light);
    }
  }
  initCascades() {
    this.mainFrustum.setFromProjectionMatrix(this.camera.projectionMatrix, this.maxFar);
    this.mainFrustum.split(this.breaks, this.frustums);
  }
  updateShadowBounds() {
    const frustums = this.frustums;
    for (let i5 = 0; i5 < frustums.length; i5++) {
      const light = this.lights[i5];
      const shadowCam = light.shadow.camera;
      const frustum = this.frustums[i5];
      const nearVerts = frustum.vertices.near;
      const farVerts = frustum.vertices.far;
      const point1 = farVerts[0];
      let point2;
      if (point1.distanceTo(farVerts[2]) > point1.distanceTo(nearVerts[2])) {
        point2 = farVerts[2];
      } else {
        point2 = nearVerts[2];
      }
      let squaredBBWidth = point1.distanceTo(point2);
      if (this.fade) {
        const camera = this.camera;
        const far = Math.max(camera.far, this.maxFar);
        const linearDepth = frustum.vertices.far[0].z / (far - camera.near);
        const margin = 0.25 * Math.pow(linearDepth, 2) * (far - camera.near);
        squaredBBWidth += margin;
      }
      shadowCam.left = -squaredBBWidth / 2;
      shadowCam.right = squaredBBWidth / 2;
      shadowCam.top = squaredBBWidth / 2;
      shadowCam.bottom = -squaredBBWidth / 2;
      shadowCam.near = 0;
      shadowCam.far = squaredBBWidth + this.lightMargin;
      shadowCam.updateProjectionMatrix();
      light.shadow.bias = this.shadowBias * squaredBBWidth;
      light.shadow.normalBias = this.shadowNormalBias * squaredBBWidth;
    }
  }
  updateBreaks() {
    const camera = this.camera;
    const far = Math.min(camera.far, this.maxFar);
    this.breaks.length = 0;
    switch (this.mode) {
      case "uniform":
        uniformSplit(this.cascades, camera.near, far, this.breaks);
        break;
      case "logarithmic":
        logarithmicSplit(this.cascades, camera.near, far, this.breaks);
        break;
      case "practical":
        practicalSplit(this.cascades, camera.near, far, this.practicalModeLambda, this.breaks);
        break;
      case "custom":
        if (this.customSplitsCallback === void 0) {
          throw new Error("CSM: Custom split scheme callback not defined.");
        }
        this.breaks.push(...this.customSplitsCallback(this.cascades, camera.near, far));
        break;
    }
  }
  update() {
    for (let i5 = 0; i5 < this.frustums.length; i5++) {
      const light = this.lights[i5];
      const shadowCam = light.shadow.camera;
      const texelWidth = (shadowCam.right - shadowCam.left) / this.shadowMapSize;
      const texelHeight = (shadowCam.top - shadowCam.bottom) / this.shadowMapSize;
      _lightOrientationMatrix.lookAt(_origin, this.lightDirection, this.lightDirectionUp);
      _lightOrientationMatrixInverse.copy(_lightOrientationMatrix).invert();
      _cameraToLightParentMatrix.copy(this.parent.matrixWorld).invert().multiply(this.camera.matrixWorld);
      _cameraToLightMatrix.multiplyMatrices(_lightOrientationMatrixInverse, _cameraToLightParentMatrix);
      this.frustums[i5].toSpace(_cameraToLightMatrix, _lightSpaceFrustum);
      const nearVerts = _lightSpaceFrustum.vertices.near;
      const farVerts = _lightSpaceFrustum.vertices.far;
      _bbox.makeEmpty();
      for (let j4 = 0; j4 < 4; j4++) {
        _bbox.expandByPoint(nearVerts[j4]);
        _bbox.expandByPoint(farVerts[j4]);
      }
      _bbox.getCenter(_center);
      _center.z = _bbox.max.z + this.lightMargin;
      _center.x = Math.floor(_center.x / texelWidth) * texelWidth;
      _center.y = Math.floor(_center.y / texelHeight) * texelHeight;
      _center.applyMatrix4(_lightOrientationMatrix);
      light.position.copy(_center);
      light.target.position.copy(_center);
      light.target.position.x += this.lightDirection.x;
      light.target.position.y += this.lightDirection.y;
      light.target.position.z += this.lightDirection.z;
    }
  }
  injectInclude() {
    three.ShaderChunk.lights_fragment_begin = CSMShader.lights_fragment_begin(this.cascades);
    three.ShaderChunk.lights_pars_begin = CSMShader.lights_pars_begin(this.maxCascades);
  }
  setupMaterial(material2) {
    const fn = (shader) => {
      const breaksVec2 = this.getExtendedBreaks();
      const far = Math.min(this.camera.far, this.maxFar);
      shader.uniforms.CSM_cascades = { value: breaksVec2 };
      shader.uniforms.cameraNear = { value: Math.min(this.maxFar, this.camera.near) };
      shader.uniforms.shadowFar = { value: far };
      material2.defines = material2.defines || {};
      material2.defines.USE_CSM = 1;
      material2.defines.CSM_CASCADES = this.cascades;
      material2.defines.CSM_FADE = this.fade ? "1" : "0";
      material2.needsUpdate = true;
      this.shaders.set(material2, shader);
      material2.addEventListener("dispose", () => {
        this.shaders.delete(material2);
      });
    };
    if (!material2.onBeforeCompile) {
      material2.onBeforeCompile = fn;
    } else {
      const previousFn = material2.onBeforeCompile;
      material2.onBeforeCompile = (...args) => {
        previousFn(...args);
        fn(args[0]);
      };
    }
  }
  updateUniforms() {
    const far = Math.min(this.camera.far, this.maxFar);
    const breaks = this.getExtendedBreaks();
    this.shaders.forEach((shader, material2) => {
      if (shader !== null) {
        const uniforms = shader.uniforms;
        uniforms.CSM_cascades.value = breaks;
        uniforms.cameraNear.value = Math.min(this.maxFar, this.camera.near);
        uniforms.shadowFar.value = far;
      }
      let definesChanged = false;
      const fadeValue = this.fade ? "1" : "0";
      if (material2.defines.CSM_FADE !== fadeValue) {
        material2.defines.CSM_FADE = fadeValue;
        definesChanged = true;
      }
      if (material2.defines.CSM_CASCADES !== this.cascades) {
        material2.defines.CSM_CASCADES = this.cascades;
        definesChanged = true;
      }
      if (definesChanged) {
        material2.needsUpdate = true;
      }
    });
  }
  getExtendedBreaks() {
    const target = [];
    for (let i5 = 0; i5 < this.maxCascades; i5++) {
      const amount = this.breaks[i5] || 0;
      const prev = this.breaks[i5 - 1] || 0;
      target.push(new three.Vector2(prev, amount));
    }
    if (this.noLastCascadeCutOff) {
      target[this.breaks.length - 1].y = Infinity;
    }
    return target;
  }
  updateFrustums() {
    this.updateBreaks();
    this.initCascades();
    this.updateShadowBounds();
    this.updateUniforms();
  }
  updateCascades(cascades) {
    this.cascades = cascades;
    for (const light of this.lights) {
      this.parent.remove(light);
      light.dispose();
    }
    this.lights.length = 0;
    this.createLights();
    this.injectInclude();
    this.updateFrustums();
  }
  updateShadowMapSize(size) {
    this.shadowMapSize = size;
    for (let i5 = 0; i5 < this.lights.length; i5++) {
      const light = this.lights[i5];
      light.shadow.mapSize.width = size;
      light.shadow.mapSize.height = size;
      if (light.shadow.map) {
        light.shadow.map.dispose();
        light.shadow.map = null;
      }
    }
  }
  dispose() {
    this.shaders.forEach(function(shader, material2) {
      delete material2.onBeforeCompile;
      delete material2.defines.USE_CSM;
      delete material2.defines.CSM_CASCADES;
      delete material2.defines.CSM_FADE;
      if (shader !== null) {
        delete shader.uniforms.CSM_cascades;
        delete shader.uniforms.cameraNear;
        delete shader.uniforms.shadowFar;
      }
      material2.needsUpdate = true;
    });
    this.shaders.clear();
    for (let i5 = 0; i5 < this.lights.length; i5++) {
      const light = this.lights[i5];
      this.parent.remove(light);
      light.dispose();
    }
  }
};
CSM.Helper = CSMHelper;

// src/core/systems/ClientEnvironment.js
import { isNumber as isNumber22, isString as isString16 } from "lodash-es";
var csmLevels = {
  none: {
    cascades: 1,
    shadowMapSize: 1024,
    castShadow: false,
    lightIntensity: 3
    // shadowBias: 0.000002,
    // shadowNormalBias: 0.001,
  },
  low: {
    cascades: 1,
    shadowMapSize: 2048,
    castShadow: true,
    lightIntensity: 3,
    shadowBias: 9e-7,
    shadowNormalBias: 1e-3
  },
  med: {
    cascades: 3,
    shadowMapSize: 1024,
    castShadow: true,
    lightIntensity: 1,
    shadowBias: 2e-6,
    shadowNormalBias: 2e-3
  },
  high: {
    cascades: 3,
    shadowMapSize: 2048,
    castShadow: true,
    lightIntensity: 1,
    shadowBias: 3e-6,
    shadowNormalBias: 2e-3
  }
};
var ClientEnvironment = class extends System {
  constructor(world2) {
    super(world2);
    this.model = null;
    this.skys = [];
    this.sky = null;
    this.skyN = 0;
    this.bgUrl = null;
    this.hdrUrl = null;
  }
  init({ baseEnvironment }) {
    this.base = baseEnvironment;
  }
  async start() {
    this.buildCSM();
    this.updateSky();
    this.world.settings.on("change", this.onSettingsChange);
    this.world.prefs.on("change", this.onPrefsChange);
    this.world.graphics.on("resize", this.onViewportResize);
  }
  async updateModel() {
    const url = this.world.settings.model?.url || this.base.model;
    let glb = this.world.loader.get("model", url);
    if (!glb) glb = await this.world.loader.load("model", url);
    if (this.model) this.model.deactivate();
    this.model = glb.toNodes();
    this.model.activate({ world: this.world, label: "base" });
  }
  addSky(node) {
    const handle = {
      node,
      destroy: () => {
        const idx = this.skys.indexOf(handle);
        if (idx === -1) return;
        this.skys.splice(idx, 1);
        this.updateSky();
      }
    };
    this.skys.push(handle);
    this.updateSky();
    return handle;
  }
  getSky() {
  }
  async updateSky() {
    if (!this.sky) {
      const geometry = new three_exports.SphereGeometry(1e3, 60, 40);
      const material2 = new three_exports.MeshBasicMaterial({ side: three_exports.BackSide });
      this.sky = new three_exports.Mesh(geometry, material2);
      this.sky.geometry.computeBoundsTree();
      this.sky.material.fog = false;
      this.sky.material.toneMapped = false;
      this.sky.material.needsUpdate = true;
      this.sky.matrixAutoUpdate = false;
      this.sky.matrixWorldAutoUpdate = false;
      this.sky.visible = false;
      this.world.stage.scene.add(this.sky);
    }
    const base = this.base;
    const node = this.skys[this.skys.length - 1]?.node;
    const bgUrl = node?._bg || base.bg;
    const hdrUrl = node?._hdr || base.hdr;
    const sunDirection = node?._sunDirection || base.sunDirection;
    const sunIntensity = isNumber22(node?._sunIntensity) ? node._sunIntensity : base.sunIntensity;
    const sunColor = isString16(node?._sunColor) ? node._sunColor : base.sunColor;
    const fogNear = isNumber22(node?._fogNear) ? node._fogNear : base.fogNear;
    const fogFar = isNumber22(node?._fogFar) ? node._fogFar : base.fogFar;
    const fogColor = isString16(node?._fogColor) ? node._fogColor : base.fogColor;
    const n6 = ++this.skyN;
    let bgTexture;
    if (bgUrl) bgTexture = await this.world.loader.load("texture", bgUrl);
    let hdrTexture;
    if (hdrUrl) hdrTexture = await this.world.loader.load("hdr", hdrUrl);
    if (n6 !== this.skyN) return;
    if (bgTexture) {
      bgTexture.minFilter = bgTexture.magFilter = three_exports.LinearFilter;
      bgTexture.mapping = three_exports.EquirectangularReflectionMapping;
      bgTexture.colorSpace = three_exports.SRGBColorSpace;
      this.sky.material.map = bgTexture;
      this.sky.visible = true;
    } else {
      this.sky.visible = false;
    }
    if (hdrTexture) {
      hdrTexture.mapping = three_exports.EquirectangularReflectionMapping;
      this.world.stage.scene.environment = hdrTexture;
    }
    this.csm.lightDirection = sunDirection;
    for (const light of this.csm.lights) {
      light.intensity = sunIntensity;
      light.color.set(sunColor);
    }
    if (isNumber22(fogNear) && isNumber22(fogFar) && fogColor) {
      const color = new three_exports.Color(fogColor);
      this.world.stage.scene.fog = new three_exports.Fog(color, fogNear, fogFar);
    } else {
      this.world.stage.scene.fog = null;
    }
    this.skyInfo = {
      bgUrl,
      hdrUrl,
      sunDirection,
      sunIntensity,
      sunColor,
      fogNear,
      fogFar,
      fogColor
    };
  }
  update(delta) {
    this.csm.update();
  }
  lateUpdate(delta) {
    this.sky.matrixWorld.copyPosition(this.world.rig.matrixWorld);
  }
  buildCSM() {
    const options = csmLevels[this.world.prefs.shadows];
    if (this.csm) {
      this.csm.updateCascades(options.cascades);
      this.csm.updateShadowMapSize(options.shadowMapSize);
      this.csm.lightDirection = this.skyInfo.sunDirection;
      for (const light of this.csm.lights) {
        light.intensity = this.skyInfo.sunIntensity;
        light.color.set(this.skyInfo.sunColor);
        light.castShadow = options.castShadow;
      }
    } else {
      const scene = this.world.stage.scene;
      const camera = this.world.camera;
      this.csm = new CSM({
        mode: "practical",
        // uniform, logarithmic, practical, custom
        // mode: 'custom',
        // customSplitsCallback: function (cascadeCount, nearDistance, farDistance) {
        //   return [0.05, 0.2, 0.5]
        // },
        cascades: 3,
        maxCascades: 3,
        shadowMapSize: 2048,
        maxFar: 100,
        lightIntensity: 1,
        lightDirection: new Vector3Enhanced(0, -1, 0).normalize(),
        fade: true,
        parent: scene,
        camera,
        // note: you can play with bias in console like this:
        // var csm = world.graphics.csm
        // csm.shadowBias = 0.00001
        // csm.shadowNormalBias = 0.002
        // csm.updateFrustums()
        // shadowBias: 0.00001,
        // shadowNormalBias: 0.002,
        // lightNear: 0.0000001,
        // lightFar: 5000,
        // lightMargin: 200,
        // noLastCascadeCutOff: true,
        ...options
        // note: you can test changes in console and then call csm.updateFrustrums() to debug
      });
      if (!options.castShadow) {
        for (const light of this.csm.lights) {
          light.castShadow = false;
        }
      }
    }
  }
  onSettingsChange = (changes) => {
    if (changes.model) {
      this.updateModel();
    }
  };
  onPrefsChange = (changes) => {
    if (changes.shadows) {
      this.buildCSM();
      this.updateSky();
    }
  };
  onViewportResize = () => {
    this.csm.updateFrustums();
  };
};

// src/core/systems/ClientAudio.js
var up = new Vector3Enhanced(0, 1, 0);
var v110 = new Vector3Enhanced();
var ClientAudio = class extends System {
  constructor(world2) {
    super(world2);
    this.handles = /* @__PURE__ */ new Set();
    this.ctx = new AudioContext();
    this.masterGain = this.ctx.createGain();
    this.masterGain.connect(this.ctx.destination);
    this.groupGains = {
      music: this.ctx.createGain(),
      sfx: this.ctx.createGain(),
      voice: this.ctx.createGain()
    };
    this.groupGains.music.gain.value = world2.prefs.music;
    this.groupGains.sfx.gain.value = world2.prefs.sfx;
    this.groupGains.voice.gain.value = world2.prefs.voice;
    this.groupGains.music.connect(this.masterGain);
    this.groupGains.sfx.connect(this.masterGain);
    this.groupGains.voice.connect(this.masterGain);
    this.listener = this.ctx.listener;
    this.listener.positionX.value = 0;
    this.listener.positionY.value = 0;
    this.listener.positionZ.value = 0;
    this.listener.forwardX.value = 0;
    this.listener.forwardY.value = 0;
    this.listener.forwardZ.value = -1;
    this.listener.upX.value = 0;
    this.listener.upY.value = 1;
    this.listener.upZ.value = 0;
    this.lastDelta = 0;
    this.queue = [];
    this.unlocked = this.ctx.state !== "suspended";
    if (!this.unlocked) {
      this.setupUnlockListener();
    }
  }
  ready(fn) {
    if (this.unlocked) return fn();
    this.queue.push(fn);
  }
  setupUnlockListener() {
    const complete = () => {
      this.unlocked = true;
      document.removeEventListener("click", unlock);
      document.removeEventListener("touchstart", unlock);
      document.removeEventListener("keydown", unlock);
      while (this.queue.length) {
        this.queue.pop()();
      }
      console.log("[audio] unlocked");
    };
    const unlock = async () => {
      try {
        await this.ctx.resume();
        if (this.ctx.state !== "running") throw new Error("Audio still suspended");
        const video = document.createElement("video");
        video.playsInline = true;
        video.muted = true;
        video.src = "/tiny.mp4";
        video.play().then(() => {
          video.pause();
          video.remove();
          console.log("[audio] video played");
        }).catch((err) => {
          console.log("[audio] video failed");
        });
      } catch (err) {
        console.error(err);
      } finally {
        complete();
      }
    };
    document.addEventListener("click", unlock);
    document.addEventListener("touchstart", unlock);
    document.addEventListener("keydown", unlock);
    console.log("[audio] suspended, waiting for interact...");
  }
  async init() {
    this.world.prefs.on("change", this.onPrefsChange);
  }
  start() {
  }
  lateUpdate(delta) {
    const target = this.world.rig;
    const dir = v110.set(0, 0, -1).applyQuaternion(target.quaternion);
    if (this.listener.positionX) {
      const endTime = this.ctx.currentTime + delta * 2;
      this.listener.positionX.linearRampToValueAtTime(target.position.x, endTime);
      this.listener.positionY.linearRampToValueAtTime(target.position.y, endTime);
      this.listener.positionZ.linearRampToValueAtTime(target.position.z, endTime);
      this.listener.forwardX.linearRampToValueAtTime(dir.x, endTime);
      this.listener.forwardY.linearRampToValueAtTime(dir.y, endTime);
      this.listener.forwardZ.linearRampToValueAtTime(dir.z, endTime);
      this.listener.upX.linearRampToValueAtTime(up.x, endTime);
      this.listener.upY.linearRampToValueAtTime(up.y, endTime);
      this.listener.upZ.linearRampToValueAtTime(up.z, endTime);
    } else {
      this.listener.setPosition(target.position.x, target.position.y, target.position.z);
      this.listener.setOrientation(dir.x, dir.y, dir.z, up.x, up.y, up.z);
    }
    this.lastDelta = delta * 2;
  }
  onPrefsChange = (changes) => {
    if (changes.music) {
      this.groupGains.music.gain.value = changes.music.value;
    }
    if (changes.sfx) {
      this.groupGains.sfx.gain.value = changes.sfx.value;
    }
    if (changes.voice) {
      this.groupGains.voice.gain.value = changes.voice.value;
    }
  };
};

// src/core/libs/stats-gl/panel.js
var Panel = class {
  canvas;
  context;
  name;
  fg;
  bg;
  PR;
  WIDTH;
  HEIGHT;
  TEXT_X;
  TEXT_Y;
  GRAPH_X;
  GRAPH_Y;
  GRAPH_WIDTH;
  GRAPH_HEIGHT;
  constructor(name2, fg, bg) {
    this.name = name2;
    this.fg = fg;
    this.bg = bg;
    this.PR = Math.round(window.devicePixelRatio || 1);
    this.WIDTH = 90 * this.PR;
    this.HEIGHT = 48 * this.PR;
    this.TEXT_X = 3 * this.PR;
    this.TEXT_Y = 2 * this.PR;
    this.GRAPH_X = 3 * this.PR;
    this.GRAPH_Y = 15 * this.PR;
    this.GRAPH_WIDTH = 84 * this.PR;
    this.GRAPH_HEIGHT = 30 * this.PR;
    this.canvas = document.createElement("canvas");
    this.canvas.width = 90 * this.PR;
    this.canvas.height = 48 * this.PR;
    this.canvas.style.width = "90px";
    this.canvas.style.position = "absolute";
    this.canvas.style.height = "48px";
    this.canvas.style.cssText = "width:90px;height:48px";
    this.context = this.canvas.getContext("2d");
    if (this.context) {
      this.context.font = "bold " + 9 * this.PR + "px Helvetica,Arial,sans-serif";
      this.context.textBaseline = "top";
      this.context.fillStyle = this.bg;
      this.context.fillRect(0, 0, this.WIDTH, this.HEIGHT);
      this.context.fillStyle = this.fg;
      this.context.fillText(this.name, this.TEXT_X, this.TEXT_Y);
      this.context.fillRect(
        this.GRAPH_X,
        this.GRAPH_Y,
        this.GRAPH_WIDTH,
        this.GRAPH_HEIGHT
      );
      this.context.fillStyle = this.bg;
      this.context.globalAlpha = 0.9;
      this.context.fillRect(
        this.GRAPH_X,
        this.GRAPH_Y,
        this.GRAPH_WIDTH,
        this.GRAPH_HEIGHT
      );
    }
  }
  update(value, valueGraph, maxValue, maxGraph, decimals = 0) {
    let min = Infinity, max = 0;
    if (!this.context) return;
    min = Math.min(min, value);
    max = Math.max(maxValue, value);
    maxGraph = Math.max(maxGraph, valueGraph);
    this.context.fillStyle = this.bg;
    this.context.globalAlpha = 1;
    this.context.fillRect(0, 0, this.WIDTH, this.GRAPH_Y);
    this.context.fillStyle = this.fg;
    this.context.fillText(
      value.toFixed(decimals) + " " + this.name + " (" + min.toFixed(decimals) + "-" + parseFloat(max.toFixed(decimals)) + ")",
      this.TEXT_X,
      this.TEXT_Y
    );
    this.context.drawImage(
      this.canvas,
      this.GRAPH_X + this.PR,
      this.GRAPH_Y,
      this.GRAPH_WIDTH - this.PR,
      this.GRAPH_HEIGHT,
      this.GRAPH_X,
      this.GRAPH_Y,
      this.GRAPH_WIDTH - this.PR,
      this.GRAPH_HEIGHT
    );
    this.context.fillRect(
      this.GRAPH_X + this.GRAPH_WIDTH - this.PR,
      this.GRAPH_Y,
      this.PR,
      this.GRAPH_HEIGHT
    );
    this.context.fillStyle = this.bg;
    this.context.globalAlpha = 0.9;
    this.context.fillRect(
      this.GRAPH_X + this.GRAPH_WIDTH - this.PR,
      this.GRAPH_Y,
      this.PR,
      (1 - valueGraph / maxGraph) * this.GRAPH_HEIGHT
    );
  }
};
var panel_default = Panel;

// src/core/libs/stats-gl/index.js
var Stats2 = class {
  totalCpuDuration = 0;
  totalGpuDuration = 0;
  totalGpuDurationCompute = 0;
  totalFps = 0;
  mode;
  info;
  dom;
  minimal;
  horizontal;
  beginTime;
  prevTime;
  prevCpuTime;
  frames;
  averageCpu;
  averageGpu;
  averageGpuCompute;
  queryCreated;
  isRunningCPUProfiling;
  fpsPanel;
  // static Panel
  msPanel;
  gpuPanel;
  gpuPanelCompute;
  samplesLog;
  samplesGraph;
  logsPerSecond;
  activeQuery = null;
  precision;
  gl;
  ext;
  query;
  disjoint;
  ns;
  threeRendererPatched;
  gpuQueries = [];
  renderCount = 0;
  constructor({
    logsPerSecond = 20,
    samplesLog = 100,
    samplesGraph = 10,
    precision = 2,
    minimal = false,
    horizontal = true,
    mode = 0
  } = {}) {
    this.mode = mode;
    this.horizontal = horizontal;
    this.dom = document.createElement("div");
    this.dom.style.cssText = "position:absolute;top:0;right:0;opacity:0.9;z-index:10000;display:flex;align-items:center;";
    if (minimal) {
      this.dom.style.cssText += "cursor:pointer";
    }
    this.gl = null;
    this.query = null;
    this.isRunningCPUProfiling = false;
    this.minimal = minimal;
    this.beginTime = (performance || Date).now();
    this.prevTime = this.beginTime;
    this.prevCpuTime = this.beginTime;
    this.frames = 0;
    this.renderCount = 0;
    this.threeRendererPatched = false;
    this.averageCpu = {
      logs: [],
      graph: []
    };
    this.averageGpu = {
      logs: [],
      graph: []
    };
    this.averageGpuCompute = {
      logs: [],
      graph: []
    };
    this.queryCreated = false;
    this.fpsPanel = this.addPanel(new panel_default("FPS", "#0ff", "#002"), 0);
    this.msPanel = this.addPanel(new panel_default("CPU", "#0f0", "#020"), 1);
    this.gpuPanel = null;
    this.gpuPanelCompute = null;
    this.samplesLog = samplesLog;
    this.samplesGraph = samplesGraph;
    this.precision = precision;
    this.logsPerSecond = logsPerSecond;
    if (this.minimal) {
      this.dom.addEventListener(
        "click",
        (event) => {
          event.preventDefault();
          this.showPanel(++this.mode % this.dom.children.length);
        },
        false
      );
      this.mode = mode;
      this.showPanel(this.mode);
    } else {
      window.addEventListener("resize", () => {
        this.resizePanel(this.fpsPanel, 0);
        this.resizePanel(this.msPanel, 1);
        if (this.gpuPanel) {
          this.resizePanel(this.gpuPanel, 2);
        }
        if (this.gpuPanelCompute) {
          this.resizePanel(this.gpuPanelCompute, 3);
        }
      });
    }
  }
  patchThreeRenderer(renderer2) {
    const originalRenderMethod = renderer2.render;
    const statsInstance = this;
    renderer2.render = function(scene, camera) {
      statsInstance.begin();
      originalRenderMethod.call(this, scene, camera);
      statsInstance.end();
    };
    this.threeRendererPatched = true;
  }
  resizePanel(panel, offset) {
    if (this.minimal) {
      panel.canvas.style.display = "none";
    } else {
      panel.canvas.style.display = "block";
      if (this.horizontal) {
        panel.canvas.style.top = "0px";
        panel.canvas.style.left = offset * panel.WIDTH / panel.PR + "px";
      } else {
        panel.canvas.style.left = "0px";
        panel.canvas.style.top = offset * panel.HEIGHT / panel.PR + "px";
      }
    }
  }
  addPanel(panel, offset) {
    if (panel.canvas) {
      this.dom.appendChild(panel.canvas);
      this.resizePanel(panel, offset);
    }
    return panel;
  }
  showPanel(id) {
    for (let i5 = 0; i5 < this.dom.children.length; i5++) {
      const child = this.dom.children[i5];
      child.style.display = i5 === id ? "block" : "none";
    }
    this.mode = id;
  }
  async init(canvasOrGL, patch = true) {
    if (!canvasOrGL) {
      console.error('Stats: The "canvas" parameter is undefined.');
      return;
    }
    if (canvasOrGL.isWebGLRenderer && !this.threeRendererPatched) {
      const canvas = canvasOrGL;
      if (patch) {
        this.patchThreeRenderer(canvas);
      }
      this.gl = canvas.getContext();
    } else if (!this.gl && canvasOrGL instanceof WebGL2RenderingContext) {
      this.gl = canvasOrGL;
    }
    if (canvasOrGL.isWebGPURenderer) {
      canvasOrGL.backend.trackTimestamp = true;
      if (await canvasOrGL.hasFeatureAsync("timestamp-query")) {
        this.gpuPanel = this.addPanel(new panel_default("GPU", "#ff0", "#220"), 2);
        this.gpuPanelCompute = this.addPanel(new panel_default("CPT", "#e1e1e1", "#212121"), 3);
        this.info = canvasOrGL.info;
      }
      return;
    } else if (!this.gl && canvasOrGL instanceof HTMLCanvasElement || canvasOrGL instanceof OffscreenCanvas) {
      this.gl = canvasOrGL.getContext("webgl2");
      if (!this.gl) {
        console.error("Stats: Unable to obtain WebGL2 context.");
        return;
      }
    } else if (!this.gl) {
      console.error(
        "Stats: Invalid input type. Expected WebGL2RenderingContext, HTMLCanvasElement, or OffscreenCanvas."
      );
      return;
    }
    this.ext = this.gl.getExtension("EXT_disjoint_timer_query_webgl2");
    if (this.ext) {
      this.gpuPanel = this.addPanel(new panel_default("GPU", "#ff0", "#220"), 2);
    }
  }
  begin() {
    if (!this.isRunningCPUProfiling) {
      this.beginProfiling("cpu-started");
    }
    if (!this.gl || !this.ext) return;
    if (this.gl && this.ext) {
      if (this.activeQuery) {
        this.gl.endQuery(this.ext.TIME_ELAPSED_EXT);
      }
      this.activeQuery = this.gl.createQuery();
      if (this.activeQuery !== null) {
        this.gl.beginQuery(this.ext.TIME_ELAPSED_EXT, this.activeQuery);
      }
    }
  }
  end() {
    this.renderCount++;
    if (this.gl && this.ext && this.activeQuery) {
      this.gl.endQuery(this.ext.TIME_ELAPSED_EXT);
      this.gpuQueries.push({ query: this.activeQuery });
      this.activeQuery = null;
    }
  }
  processGpuQueries() {
    if (!this.gl || !this.ext) return;
    this.totalGpuDuration = 0;
    this.gpuQueries.forEach((queryInfo, index) => {
      if (this.gl) {
        const available = this.gl.getQueryParameter(queryInfo.query, this.gl.QUERY_RESULT_AVAILABLE);
        const disjoint = this.gl.getParameter(this.ext.GPU_DISJOINT_EXT);
        if (available && !disjoint) {
          const elapsed = this.gl.getQueryParameter(queryInfo.query, this.gl.QUERY_RESULT);
          const duration = elapsed * 1e-6;
          this.totalGpuDuration += duration;
          this.gl.deleteQuery(queryInfo.query);
          this.gpuQueries.splice(index, 1);
        }
      }
    });
  }
  update() {
    if (this.info === void 0) {
      this.processGpuQueries();
    } else {
      this.totalGpuDuration = this.info.render.timestamp;
      this.totalGpuDurationCompute = this.info.compute.timestamp;
      this.addToAverage(this.totalGpuDurationCompute, this.averageGpuCompute);
    }
    this.endProfiling("cpu-started", "cpu-finished", "cpu-duration");
    this.addToAverage(this.totalCpuDuration, this.averageCpu);
    this.addToAverage(this.totalGpuDuration, this.averageGpu);
    this.renderCount = 0;
    if (this.totalCpuDuration === 0) {
      this.beginProfiling("cpu-started");
    }
    this.totalCpuDuration = 0;
    this.totalFps = 0;
    this.beginTime = this.endInternal();
  }
  endInternal() {
    this.frames++;
    const time = (performance || Date).now();
    if (time >= this.prevCpuTime + 1e3 / this.logsPerSecond) {
      this.updatePanel(this.msPanel, this.averageCpu);
      this.updatePanel(this.gpuPanel, this.averageGpu);
      if (this.gpuPanelCompute) {
        this.updatePanel(this.gpuPanelCompute, this.averageGpuCompute);
      }
      this.prevCpuTime = time;
    }
    if (time >= this.prevTime + 1e3) {
      const fps = this.frames * 1e3 / (time - this.prevTime);
      this.fpsPanel.update(fps, fps, 100, 100, 0);
      this.prevTime = time;
      this.frames = 0;
    }
    return time;
  }
  addToAverage(value, averageArray) {
    averageArray.logs.push(value);
    if (averageArray.logs.length > this.samplesLog) {
      averageArray.logs.shift();
    }
    averageArray.graph.push(value);
    if (averageArray.graph.length > this.samplesGraph) {
      averageArray.graph.shift();
    }
  }
  beginProfiling(marker) {
    if (window.performance) {
      window.performance.mark(marker);
      this.isRunningCPUProfiling = true;
    }
  }
  endProfiling(startMarker, endMarker, measureName) {
    if (window.performance && endMarker && this.isRunningCPUProfiling) {
      window.performance.mark(endMarker);
      const cpuMeasure = performance.measure(measureName, startMarker, endMarker);
      this.totalCpuDuration += cpuMeasure.duration;
      this.isRunningCPUProfiling = false;
    }
  }
  updatePanel(panel, averageArray) {
    if (averageArray.logs.length > 0) {
      let sumLog = 0;
      let max = 0.01;
      for (let i5 = 0; i5 < averageArray.logs.length; i5++) {
        sumLog += averageArray.logs[i5];
        if (averageArray.logs[i5] > max) {
          max = averageArray.logs[i5];
        }
      }
      let sumGraph = 0;
      let maxGraph = 0.01;
      for (let i5 = 0; i5 < averageArray.graph.length; i5++) {
        sumGraph += averageArray.graph[i5];
        if (averageArray.graph[i5] > maxGraph) {
          maxGraph = averageArray.graph[i5];
        }
      }
      if (panel) {
        panel.update(
          sumLog / Math.min(averageArray.logs.length, this.samplesLog),
          sumGraph / Math.min(averageArray.graph.length, this.samplesGraph),
          max,
          maxGraph,
          this.precision
        );
      }
    }
  }
  get domElement() {
    return this.dom;
  }
  get container() {
    console.warn("Stats: Deprecated! this.container as been replaced to this.dom ");
    return this.dom;
  }
};
var stats_gl_default = Stats2;

// src/core/systems/ClientStats.js
import { isBoolean as isBoolean18 } from "lodash-es";
var PING_RATE = 1 / 2;
var ClientStats = class extends System {
  constructor(world2) {
    super(world2);
    this.stats = null;
    this.ui = null;
    this.active = false;
    this.lastPingAt = 0;
    this.pingHistory = [];
    this.pingHistorySize = 30;
    this.maxPing = 0.01;
  }
  init({ ui }) {
    this.ui = ui;
  }
  start() {
    this.world.prefs.on("change", this.onPrefsChange);
    this.world.on("ready", this.onReady);
  }
  onReady = () => {
    if (this.world.prefs.stats) {
      this.toggle(true);
    }
  };
  toggle(value) {
    value = isBoolean18(value) ? value : !this.active;
    if (this.active === value) return;
    this.active = value;
    if (this.active) {
      if (!this.stats) {
        this.stats = new stats_gl_default({
          logsPerSecond: 20,
          samplesLog: 100,
          samplesGraph: 10,
          precision: 2,
          horizontal: true,
          minimal: false,
          mode: 0
        });
        this.stats.init(this.world.graphics.renderer, false);
        this.ping = new panel_default("PING", "#f00", "#200");
        this.stats.addPanel(this.ping, 3);
      }
      this.ui.appendChild(this.stats.dom);
    } else {
      this.ui.removeChild(this.stats.dom);
    }
  }
  preTick() {
    if (this.active) {
      this.stats.begin();
    }
  }
  update(delta) {
    if (!this.active) return;
    this.lastPingAt += delta;
    if (this.lastPingAt > PING_RATE) {
      const time = performance.now();
      this.world.network.send("ping", time);
      this.lastPingAt = 0;
    }
  }
  postTick() {
    if (this.active) {
      this.stats.end();
      this.stats.update();
    }
  }
  onPong(time) {
    const rttMs = performance.now() - time;
    if (this.active && this.ping) {
      this.pingHistory.push(rttMs);
      if (this.pingHistory.length > this.pingHistorySize) {
        this.pingHistory.shift();
      }
      let sum = 0;
      let min = Infinity;
      let max = 0;
      for (let i5 = 0; i5 < this.pingHistory.length; i5++) {
        const value = this.pingHistory[i5];
        sum += value;
        if (value < min) min = value;
        if (value > max) max = value;
      }
      const avg = sum / this.pingHistory.length;
      if (max > this.maxPing) {
        this.maxPing = max;
      }
      this.ping.update(
        avg,
        // current value (average)
        rttMs,
        // graph value (latest ping)
        max,
        // max value for text display
        this.maxPing,
        // max value for graph scaling
        0
        // number of decimal places (0 for ping)
      );
    }
  }
  onPrefsChange = (changes) => {
    if (changes.stats) {
      this.toggle(changes.stats.value);
    }
  };
};

// src/core/systems/ClientBuilder.js
import moment4 from "moment";
import { cloneDeep as cloneDeep2, isBoolean as isBoolean19 } from "lodash-es";
import { TransformControls } from "three/examples/jsm/controls/TransformControls.js";

// src/core/extras/appTools.js
import { cloneDeep } from "lodash-es";
async function importApp(file) {
  const buffer2 = await file.arrayBuffer();
  const view = new DataView(buffer2);
  const headerSize = view.getUint32(0, true);
  const bytes = new Uint8Array(buffer2.slice(4, 4 + headerSize));
  const header = JSON.parse(new TextDecoder().decode(bytes));
  let position = 4 + headerSize;
  const assets = [];
  for (const assetInfo of header.assets) {
    const data = buffer2.slice(position, position + assetInfo.size);
    const file2 = new File([data], assetInfo.url.split("/").pop(), {
      type: assetInfo.mime
    });
    assets.push({
      type: assetInfo.type,
      url: assetInfo.url,
      file: file2
    });
    position += assetInfo.size;
  }
  return {
    blueprint: header.blueprint,
    assets
  };
}

// src/core/systems/ClientBuilder.js
var FORWARD3 = new Vector3Enhanced(0, 0, -1);
var SNAP_DISTANCE = 1;
var SNAP_DEGREES = 5;
var PROJECT_SPEED = 10;
var PROJECT_MIN = 3;
var PROJECT_MAX = 50;
var v111 = new Vector3Enhanced();
var q17 = new three_exports.Quaternion();
var e13 = new three_exports.Euler();
var modeLabels = {
  grab: "Grab",
  translate: "Translate",
  rotate: "Rotate",
  scale: "Scale"
};
var ClientBuilder = class extends System {
  constructor(world2) {
    super(world2);
    this.enabled = false;
    this.selected = null;
    this.mode = "grab";
    this.localSpace = false;
    this.target = new three_exports.Object3D();
    this.target.rotation.reorder("YXZ");
    this.lastMoveSendTime = 0;
    this.undos = [];
    this.dropTarget = null;
    this.file = null;
  }
  async init({ viewport }) {
    this.viewport = viewport;
    this.viewport.addEventListener("dragover", this.onDragOver);
    this.viewport.addEventListener("dragenter", this.onDragEnter);
    this.viewport.addEventListener("dragleave", this.onDragLeave);
    this.viewport.addEventListener("drop", this.onDrop);
    this.world.on("player", this.onLocalPlayer);
  }
  start() {
    this.control = this.world.controls.bind({ priority: ControlPriorities.BUILDER });
    this.control.mouseLeft.onPress = () => {
      if (!this.control.pointer.locked) {
        this.control.pointer.lock();
        this.justPointerLocked = true;
        return true;
      }
    };
    this.updateActions();
  }
  onLocalPlayer = () => {
    this.updateActions();
  };
  canBuild() {
    return this.world.settings.public || hasRole(this.world.entities.player?.data.roles, "admin");
  }
  updateActions() {
    const actions = [];
    if (!this.enabled) {
      if (this.canBuild()) {
      }
    }
    if (this.enabled && !this.selected) {
      actions.push({ type: "mouseLeft", label: modeLabels[this.mode] });
      actions.push({ type: "mouseRight", label: "Inspect" });
      actions.push({ type: "custom", btn: "1234", label: "Grab / Translate / Rotate / Scale" });
      actions.push({ type: "keyR", label: "Duplicate" });
      actions.push({ type: "keyP", label: "Pin" });
      actions.push({ type: "keyX", label: "Destroy" });
      actions.push({ type: "space", label: "Jump / Fly (Double-Tap)" });
    }
    if (this.enabled && this.selected && this.mode === "grab") {
      actions.push({ type: "mouseLeft", label: "Place" });
      actions.push({ type: "mouseWheel", label: "Rotate" });
      actions.push({ type: "mouseRight", label: "Inspect" });
      actions.push({ type: "custom", btn: "1234", label: "Grab / Translate / Rotate / Scale" });
      actions.push({ type: "keyF", label: "Push" });
      actions.push({ type: "keyC", label: "Pull" });
      actions.push({ type: "keyX", label: "Destroy" });
      actions.push({ type: "controlLeft", label: "No Snap (Hold)" });
      actions.push({ type: "space", label: "Jump / Fly (Double-Tap)" });
    }
    if (this.enabled && this.selected && (this.mode === "translate" || this.mode === "rotate" || this.mode === "scale")) {
      actions.push({ type: "mouseLeft", label: "Select / Transform" });
      actions.push({ type: "mouseRight", label: "Inspect" });
      actions.push({ type: "custom", btn: "1234", label: "Grab / Translate / Rotate / Scale" });
      actions.push({ type: "keyT", label: this.localSpace ? "World Space" : "Local Space" });
      actions.push({ type: "keyX", label: "Destroy" });
      actions.push({ type: "controlLeft", label: "No Snap (Hold)" });
      actions.push({ type: "space", label: "Jump / Fly (Double-Tap)" });
    }
    this.control.setActions(actions);
  }
  update(delta) {
    if (this.control.tab.pressed) {
      this.toggle();
    }
    if (this.selected?.destroyed) {
      this.select(null);
    }
    if (this.selected && this.selected?.data.mover !== this.world.network.id) {
      this.select(null);
    }
    if (!this.enabled) {
      return;
    }
    if (this.control.mouseRight.pressed && this.control.pointer.locked) {
      const entity = this.getEntityAtReticle();
      if (entity?.isApp) {
        this.select(null);
        this.control.pointer.unlock();
        this.world.ui.setApp(entity);
      }
    } else if (!this.selected && !this.control.pointer.locked && this.control.mouseRight.pressed) {
      const entity = this.getEntityAtPointer();
      if (entity?.isApp) {
        this.select(null);
        this.control.pointer.unlock();
        this.world.ui.setApp(entity);
      }
    }
    if (this.control.keyU.pressed && this.control.pointer.locked) {
      const entity = this.selected || this.getEntityAtReticle();
      if (entity?.isApp) {
        this.select(null);
        const blueprint = {
          id: uuid(),
          version: 0,
          name: entity.blueprint.name,
          image: entity.blueprint.image,
          author: entity.blueprint.author,
          url: entity.blueprint.url,
          desc: entity.blueprint.desc,
          model: entity.blueprint.model,
          script: entity.blueprint.script,
          props: cloneDeep2(entity.blueprint.props),
          preload: entity.blueprint.preload,
          public: entity.blueprint.public,
          locked: entity.blueprint.locked,
          frozen: entity.blueprint.frozen,
          unique: entity.blueprint.unique,
          disabled: entity.blueprint.disabled
        };
        this.world.blueprints.add(blueprint, true);
        entity.modify({ blueprint: blueprint.id });
        this.world.network.send("entityModified", { id: entity.data.id, blueprint: blueprint.id });
        this.world.emit("toast", "Unlinked");
      }
    }
    if (this.control.keyP.pressed && this.control.pointer.locked) {
      const entity = this.selected || this.getEntityAtReticle();
      if (entity?.isApp) {
        entity.data.pinned = !entity.data.pinned;
        this.world.network.send("entityModified", {
          id: entity.data.id,
          pinned: entity.data.pinned
        });
        this.world.emit("toast", entity.data.pinned ? "Pinned" : "Un-pinned");
        this.select(null);
      }
    }
    if (this.control.keyT.pressed & (this.mode === "translate" || this.mode === "rotate" || this.mode === "scale")) {
      this.localSpace = !this.localSpace;
      this.gizmo.space = this.localSpace ? "local" : "world";
      this.updateActions();
    }
    if (this.control.digit1.pressed) {
      this.setMode("grab");
    }
    if (this.control.digit2.pressed) {
      this.setMode("translate");
    }
    if (this.control.digit3.pressed) {
      this.setMode("rotate");
    }
    if (this.control.digit4.pressed) {
      this.setMode("scale");
    }
    if (!this.justPointerLocked && this.control.pointer.locked && this.control.mouseLeft.pressed) {
      if (!this.selected) {
        const entity = this.getEntityAtReticle();
        if (entity?.isApp && !entity.data.pinned) this.select(entity);
      } else if (this.selected && this.mode === "grab") {
        this.select(null);
      } else if (this.selected && (this.mode === "translate" || this.mode === "rotate" || this.mode === "scale") && !this.gizmoActive) {
        const entity = this.getEntityAtReticle();
        if (entity?.isApp) this.select(entity);
        else this.select(null);
      }
    }
    if (this.selected && !this.control.pointer.locked) {
      this.select(null);
    }
    if (!this.justPointerLocked && this.control.pointer.locked && this.control.keyR.pressed) {
      const entity = this.selected || this.getEntityAtReticle();
      if (entity?.isApp) {
        let blueprintId = entity.data.blueprint;
        if (entity.blueprint.unique) {
          const blueprint = {
            id: uuid(),
            version: 0,
            name: entity.blueprint.name,
            image: entity.blueprint.image,
            author: entity.blueprint.author,
            url: entity.blueprint.url,
            desc: entity.blueprint.desc,
            model: entity.blueprint.model,
            script: entity.blueprint.script,
            props: cloneDeep2(entity.blueprint.props),
            preload: entity.blueprint.preload,
            public: entity.blueprint.public,
            locked: entity.blueprint.locked,
            frozen: entity.blueprint.frozen,
            unique: entity.blueprint.unique,
            disabled: entity.blueprint.disabled
          };
          this.world.blueprints.add(blueprint, true);
          blueprintId = blueprint.id;
        }
        const data = {
          id: uuid(),
          type: "app",
          blueprint: blueprintId,
          position: entity.root.position.toArray(),
          quaternion: entity.root.quaternion.toArray(),
          scale: entity.root.scale.toArray(),
          mover: this.world.network.id,
          uploader: null,
          pinned: false,
          state: {}
        };
        const dup = this.world.entities.add(data, true);
        this.select(dup);
        this.addUndo({
          name: "remove-entity",
          entityId: data.id
        });
      }
    }
    if (this.control.keyX.pressed) {
      const entity = this.selected || this.getEntityAtReticle();
      if (entity?.isApp && !entity.data.pinned) {
        this.select(null);
        this.addUndo({
          name: "add-entity",
          data: cloneDeep2(entity.data)
        });
        entity?.destroy(true);
      }
    }
    if (this.control.keyZ.pressed && !this.control.shiftLeft.down && (this.control.metaLeft.down || this.control.controlLeft.down)) {
      console.log("undo", {
        shiftLeft: this.control.shiftLeft.down,
        metaLeft: this.control.metaLeft.down,
        controlLeft: this.control.controlLeft.down
      });
      this.undo();
    }
    if (this.selected && this.mode === "translate" && this.gizmoActive) {
      const app = this.selected;
      app.root.position.copy(this.gizmoTarget.position);
      app.root.quaternion.copy(this.gizmoTarget.quaternion);
      app.root.scale.copy(this.gizmoTarget.scale);
    }
    if (this.selected && this.mode === "rotate" && this.control.controlLeft.pressed) {
      this.gizmo.rotationSnap = null;
    }
    if (this.selected && this.mode === "rotate" && this.control.controlLeft.released) {
      this.gizmo.rotationSnap = SNAP_DEGREES * DEG2RAD;
    }
    if (this.selected && this.mode === "rotate" && this.gizmoActive) {
      const app = this.selected;
      app.root.position.copy(this.gizmoTarget.position);
      app.root.quaternion.copy(this.gizmoTarget.quaternion);
      app.root.scale.copy(this.gizmoTarget.scale);
    }
    if (this.selected && this.mode === "scale" && this.gizmoActive) {
      const app = this.selected;
      app.root.scale.copy(this.gizmoTarget.scale);
    }
    if (this.selected && this.mode === "grab") {
      const app = this.selected;
      const hit = this.getHitAtReticle(app, true);
      const camPos = this.world.rig.position;
      const camDir = v111.copy(FORWARD3).applyQuaternion(this.world.rig.quaternion);
      const hitDistance = hit ? hit.point.distanceTo(camPos) : 0;
      if (hit && hitDistance < this.target.limit) {
        this.target.position.copy(hit.point);
      } else {
        this.target.position.copy(camPos).add(camDir.multiplyScalar(this.target.limit));
      }
      let project = this.control.keyF.down ? 1 : this.control.keyC.down ? -1 : null;
      if (project) {
        const multiplier = this.control.shiftLeft.down ? 4 : 1;
        this.target.limit += project * PROJECT_SPEED * delta * multiplier;
        if (this.target.limit < PROJECT_MIN) this.target.limit = PROJECT_MIN;
        if (hitDistance && this.target.limit > hitDistance) this.target.limit = hitDistance;
      }
      if (this.control.shiftLeft.down) {
        const scaleFactor = 1 + this.control.scrollDelta.value * 0.1 * delta;
        this.target.scale.multiplyScalar(scaleFactor);
      } else {
        this.target.rotation.y += this.control.scrollDelta.value * 0.1 * delta;
      }
      app.root.position.copy(this.target.position);
      app.root.quaternion.copy(this.target.quaternion);
      app.root.scale.copy(this.target.scale);
      if (!this.control.controlLeft.down) {
        const newY = this.target.rotation.y;
        const degrees = newY / DEG2RAD;
        const snappedDegrees = Math.round(degrees / SNAP_DEGREES) * SNAP_DEGREES;
        app.root.rotation.y = snappedDegrees * DEG2RAD;
      }
      app.root.clean();
      if (!this.control.controlLeft.down) {
        for (const pos of app.snaps) {
          const result = this.world.snaps.octree.query(pos, SNAP_DISTANCE)[0];
          if (result) {
            const offset = v111.copy(result.position).sub(pos);
            app.root.position.add(offset);
            break;
          }
        }
      }
    }
    if (this.selected) {
      this.lastMoveSendTime += delta;
      if (this.lastMoveSendTime > this.world.networkRate) {
        const app = this.selected;
        this.world.network.send("entityModified", {
          id: app.data.id,
          position: app.root.position.toArray(),
          quaternion: app.root.quaternion.toArray(),
          scale: app.root.scale.toArray()
        });
        this.lastMoveSendTime = 0;
      }
    }
    if (this.justPointerLocked) {
      this.justPointerLocked = false;
    }
  }
  addUndo(action) {
    this.undos.push(action);
    if (this.undos.length > 50) {
      this.undos.shift();
    }
  }
  undo() {
    const undo = this.undos.pop();
    if (!undo) return;
    if (this.selected) this.select(null);
    if (undo.name === "add-entity") {
      this.world.entities.add(undo.data, true);
      return;
    }
    if (undo.name === "move-entity") {
      const entity = this.world.entities.get(undo.entityId);
      if (!entity) return;
      entity.data.position = undo.position;
      entity.data.quaternion = undo.quaternion;
      this.world.network.send("entityModified", {
        id: undo.entityId,
        position: entity.data.position,
        quaternion: entity.data.quaternion,
        scale: entity.data.scale
      });
      entity.build();
      return;
    }
    if (undo.name === "remove-entity") {
      const entity = this.world.entities.get(undo.entityId);
      if (!entity) return;
      entity.destroy(true);
      return;
    }
  }
  toggle(enabled) {
    if (!this.canBuild()) return;
    enabled = isBoolean19(enabled) ? enabled : !this.enabled;
    if (this.enabled === enabled) return;
    this.enabled = enabled;
    if (!this.enabled) this.select(null);
    this.updateActions();
    this.world.emit("build-mode", enabled);
  }
  setMode(mode) {
    if (this.selected) {
      if (this.mode === "grab") {
        this.control.keyC.capture = false;
        this.control.scrollDelta.capture = false;
      }
      if (this.mode === "translate" || this.mode === "rotate" || this.mode === "scale") {
        this.detachGizmo();
      }
    }
    this.mode = mode;
    if (this.mode === "grab") {
      if (this.selected) {
        const app = this.selected;
        this.control.keyC.capture = true;
        this.control.scrollDelta.capture = true;
        this.target.position.copy(app.root.position);
        this.target.quaternion.copy(app.root.quaternion);
        this.target.scale.copy(app.root.scale);
        this.target.limit = PROJECT_MAX;
      }
    }
    if (this.mode === "translate" || this.mode === "rotate" || this.mode === "scale") {
      if (this.selected) {
        this.attachGizmo(this.selected, this.mode);
      }
    }
    this.updateActions();
  }
  select(app) {
    if (this.selected === app) return;
    if (this.selected && this.selected !== app) {
      if (!this.selected.dead && this.selected.data.mover === this.world.network.id) {
        const app2 = this.selected;
        app2.data.mover = null;
        app2.data.position = app2.root.position.toArray();
        app2.data.quaternion = app2.root.quaternion.toArray();
        app2.data.scale = app2.root.scale.toArray();
        app2.data.state = {};
        this.world.network.send("entityModified", {
          id: app2.data.id,
          mover: null,
          position: app2.data.position,
          quaternion: app2.data.quaternion,
          scale: app2.data.scale,
          state: app2.data.state
        });
        app2.build();
      }
      this.selected = null;
      if (this.mode === "grab") {
        this.control.keyC.capture = false;
        this.control.scrollDelta.capture = false;
      }
      if (this.mode === "translate" || this.mode === "rotate" || this.mode === "scale") {
        this.detachGizmo();
      }
    }
    if (app) {
      this.addUndo({
        name: "move-entity",
        entityId: app.data.id,
        position: app.data.position.slice(),
        quaternion: app.data.quaternion.slice(),
        scale: app.data.scale.slice()
      });
      if (app.data.mover !== this.world.network.id) {
        app.data.mover = this.world.network.id;
        app.build();
        this.world.network.send("entityModified", { id: app.data.id, mover: app.data.mover });
      }
      this.selected = app;
      if (this.mode === "grab") {
        this.control.keyC.capture = true;
        this.control.scrollDelta.capture = true;
        this.target.position.copy(app.root.position);
        this.target.quaternion.copy(app.root.quaternion);
        this.target.scale.copy(app.root.scale);
        this.target.limit = PROJECT_MAX;
      }
      if (this.mode === "translate" || this.mode === "rotate" || this.mode === "scale") {
        this.attachGizmo(app, this.mode);
      }
    }
    this.updateActions();
  }
  attachGizmo(app, mode) {
    if (this.gizmo) this.detachGizmo();
    this.gizmo = new TransformControls(this.world.camera, this.viewport);
    this.gizmo.setSize(0.7);
    this.gizmo.space = this.localSpace ? "local" : "world";
    this.gizmo._gizmo.helper.translate.scale.setScalar(0);
    this.gizmo._gizmo.helper.rotate.scale.setScalar(0);
    this.gizmo._gizmo.helper.scale.scale.setScalar(0);
    this.gizmo.addEventListener("mouseDown", () => {
      this.gizmoActive = true;
    });
    this.gizmo.addEventListener("mouseUp", () => {
      this.gizmoActive = false;
    });
    this.gizmoTarget = new three_exports.Object3D();
    this.gizmoHelper = this.gizmo.getHelper();
    this.gizmoTarget.position.copy(app.root.position);
    this.gizmoTarget.quaternion.copy(app.root.quaternion);
    this.gizmoTarget.scale.copy(app.root.scale);
    this.world.stage.scene.add(this.gizmoTarget);
    this.world.stage.scene.add(this.gizmoHelper);
    this.gizmo.rotationSnap = SNAP_DEGREES * DEG2RAD;
    this.gizmo.attach(this.gizmoTarget);
    this.gizmo.mode = mode;
  }
  detachGizmo() {
    if (!this.gizmo) return;
    this.world.stage.scene.remove(this.gizmoTarget);
    this.world.stage.scene.remove(this.gizmoHelper);
    this.gizmo.detach();
    this.gizmo.disconnect();
    this.gizmo.dispose();
    this.gizmo = null;
  }
  getEntityAtReticle() {
    const hits = this.world.stage.raycastReticle();
    let entity;
    for (const hit of hits) {
      entity = hit.getEntity?.();
      if (entity) break;
    }
    return entity;
  }
  getEntityAtPointer() {
    const hits = this.world.stage.raycastPointer(this.control.pointer.position);
    let entity;
    for (const hit of hits) {
      entity = hit.getEntity?.();
      if (entity) break;
    }
    return entity;
  }
  getHitAtReticle(ignoreEntity, ignorePlayers) {
    const hits = this.world.stage.raycastReticle();
    let hit;
    for (const _hit of hits) {
      const entity = _hit.getEntity?.();
      if (entity === ignoreEntity || entity?.isPlayer && ignorePlayers) continue;
      hit = _hit;
      break;
    }
    return hit;
  }
  onDragOver = (e7) => {
    e7.preventDefault();
  };
  onDragEnter = (e7) => {
    this.dropTarget = e7.target;
    this.dropping = true;
    this.file = null;
  };
  onDragLeave = (e7) => {
    if (e7.target === this.dropTarget) {
      this.dropping = false;
    }
  };
  onDrop = async (e7) => {
    e7.preventDefault();
    this.dropping = false;
    if (!this.canBuild()) {
      this.world.chat.add({
        id: uuid(),
        from: null,
        fromId: null,
        body: `You don't have permission to do that.`,
        createdAt: moment4().toISOString()
      });
      return;
    }
    let file;
    if (e7.dataTransfer.items && e7.dataTransfer.items.length > 0) {
      const item = e7.dataTransfer.items[0];
      if (item.kind === "file") {
        file = item.getAsFile();
      }
      if (item.type === "text/uri-list" || item.type === "text/plain" || item.type === "text/html") {
        const text = await getAsString(item);
        const url = text.trim().split("\n")[0];
        if (url.startsWith("http")) {
          const resp = await fetch(url);
          const blob = await resp.blob();
          file = new File([blob], new URL(url).pathname.split("/").pop(), { type: resp.headers.get("content-type") });
        }
      }
    } else if (e7.dataTransfer.files && e7.dataTransfer.files.length > 0) {
      file = e7.dataTransfer.files[0];
    }
    if (!file) return;
    await new Promise((resolve3) => setTimeout(resolve3, 100));
    this.toggle(true);
    const maxSize = this.world.network.maxUploadSize * 1024 * 1024;
    if (file.size > maxSize) {
      this.world.chat.add({
        id: uuid(),
        from: null,
        fromId: null,
        body: `File size too large (>${this.world.network.maxUploadSize}mb)`,
        createdAt: moment4().toISOString()
      });
      console.error(`File too large. Maximum size is ${maxSize / (1024 * 1024)}MB`);
      return;
    }
    const transform = this.getSpawnTransform();
    const ext = file.name.split(".").pop().toLowerCase();
    if (ext === "hyp") {
      this.addApp(file, transform);
    }
    if (ext === "glb") {
      this.addModel(file, transform);
    }
    if (ext === "vrm") {
      this.addAvatar(file, transform);
    }
  };
  async addApp(file, transform) {
    const info = await importApp(file);
    for (const asset of info.assets) {
      this.world.loader.insert(asset.type, asset.url, asset.file);
    }
    const blueprint = {
      id: uuid(),
      version: 0,
      name: info.blueprint.name,
      image: info.blueprint.image,
      author: info.blueprint.author,
      url: info.blueprint.url,
      desc: info.blueprint.desc,
      model: info.blueprint.model,
      script: info.blueprint.script,
      props: info.blueprint.props,
      preload: info.blueprint.preload,
      public: info.blueprint.public,
      locked: info.blueprint.locked,
      frozen: info.blueprint.frozen,
      unique: info.blueprint.unique,
      disabled: info.blueprint.disabled
    };
    this.world.blueprints.add(blueprint, true);
    const data = {
      id: uuid(),
      type: "app",
      blueprint: blueprint.id,
      position: transform.position,
      quaternion: transform.quaternion,
      scale: [1, 1, 1],
      mover: null,
      uploader: this.world.network.id,
      pinned: false,
      state: {}
    };
    const app = this.world.entities.add(data, true);
    const promises2 = info.assets.map((asset) => {
      return this.world.network.upload(asset.file);
    });
    try {
      await Promise.all(promises2);
      app.onUploaded();
    } catch (err) {
      console.error("failed to upload .hyp assets");
      console.error(err);
      app.destroy();
    }
  }
  async addModel(file, transform) {
    const hash = await hashFile(file);
    const filename = `${hash}.glb`;
    const url = `asset://${filename}`;
    this.world.loader.insert("model", url, file);
    const blueprint = {
      id: uuid(),
      version: 0,
      name: file.name.split(".")[0],
      image: null,
      author: null,
      url: null,
      desc: null,
      model: url,
      script: null,
      props: {},
      preload: false,
      public: false,
      locked: false,
      unique: false,
      disabled: false
    };
    this.world.blueprints.add(blueprint, true);
    const data = {
      id: uuid(),
      type: "app",
      blueprint: blueprint.id,
      position: transform.position,
      quaternion: transform.quaternion,
      scale: [1, 1, 1],
      mover: null,
      uploader: this.world.network.id,
      pinned: false,
      state: {}
    };
    const app = this.world.entities.add(data, true);
    await this.world.network.upload(file);
    app.onUploaded();
  }
  async addAvatar(file, transform) {
    const hash = await hashFile(file);
    const filename = `${hash}.vrm`;
    const url = `asset://${filename}`;
    this.world.loader.insert("avatar", url, file);
    this.world.emit("avatar", {
      file,
      url,
      hash,
      onPlace: async () => {
        this.world.emit("avatar", null);
        const blueprint = {
          id: uuid(),
          version: 0,
          name: file.name,
          image: null,
          author: null,
          url: null,
          desc: null,
          model: url,
          script: null,
          props: {},
          preload: false,
          public: false,
          locked: false,
          unique: false,
          disabled: false
        };
        this.world.blueprints.add(blueprint, true);
        const data = {
          id: uuid(),
          type: "app",
          blueprint: blueprint.id,
          position: transform.position,
          quaternion: transform.quaternion,
          scale: [1, 1, 1],
          mover: null,
          uploader: this.world.network.id,
          pinned: false,
          state: {}
        };
        const app = this.world.entities.add(data, true);
        await this.world.network.upload(file);
        app.onUploaded();
      },
      onEquip: async () => {
        this.world.emit("avatar", null);
        const player = this.world.entities.player;
        const prevUrl = player.data.avatar;
        player.modify({ avatar: url, sessionAvatar: null });
        try {
          await this.world.network.upload(file);
        } catch (err) {
          console.error(err);
          player.modify({ avatar: prevUrl });
          return;
        }
        if (player.data.avatar !== url) {
          return;
        }
        this.world.network.send("entityModified", {
          id: player.data.id,
          avatar: url
        });
      }
    });
  }
  getSpawnTransform(atReticle) {
    const hit = atReticle ? this.world.stage.raycastReticle()[0] : this.world.stage.raycastPointer(this.control.pointer.position)[0];
    const position = hit ? hit.point.toArray() : [0, 0, 0];
    let quaternion;
    if (hit) {
      e13.copy(this.world.rig.rotation).reorder("YXZ");
      e13.x = 0;
      e13.z = 0;
      const degrees = e13.y * RAD2DEG;
      const snappedDegrees = Math.round(degrees / SNAP_DEGREES) * SNAP_DEGREES;
      e13.y = snappedDegrees * DEG2RAD;
      q17.setFromEuler(e13);
      quaternion = q17.toArray();
    } else {
      quaternion = [0, 0, 0, 1];
    }
    return { position, quaternion };
  }
};
function getAsString(item) {
  return new Promise((resolve3) => {
    item.getAsString(resolve3);
  });
}

// src/core/systems/ClientActions.js
import * as THREE7 from "three";
var BATCH_SIZE = 500;
var ClientActions = class extends System {
  constructor(world2) {
    super(world2);
    this.nodes = [];
    this.cursor = 0;
    this.current = {
      node: null,
      distance: Infinity
    };
    this.action = null;
  }
  start() {
    this.action = createAction(this.world);
    this.btnDown = false;
    this.control = this.world.controls.bind({ priority: ControlPriorities.ACTION });
  }
  register(node) {
    this.nodes.push(node);
  }
  unregister(node) {
    const idx = this.nodes.indexOf(node);
    if (idx === -1) return;
    this.nodes.splice(idx, 1);
    if (this.current.node === node) {
      this.current.node = null;
      this.current.distance = Infinity;
      this.action.stop();
    }
  }
  update(delta) {
    const cameraPos = this.world.rig.position;
    this.btnDown = this.control.keyE.down || this.control.touchB.down;
    if (this.current.node) {
      const distance = this.current.node.worldPos.distanceTo(cameraPos);
      if (distance > this.current.node._distance) {
        this.current.node = null;
        this.current.distance = Infinity;
        this.emit("change", false);
        this.action.stop();
      } else {
        this.current.distance = distance;
      }
    }
    let didChange;
    const size = Math.min(this.nodes.length, BATCH_SIZE);
    for (let i5 = 0; i5 < size; i5++) {
      const idx = (this.cursor + i5) % this.nodes.length;
      const node = this.nodes[idx];
      if (node.finished) continue;
      if (this.current.node === node) continue;
      const distance = node.worldPos.distanceTo(cameraPos);
      if (distance <= node._distance && distance < this.current.distance) {
        this.current.node = node;
        this.current.distance = distance;
        didChange = true;
      }
    }
    if (size) {
      this.cursor = (this.cursor + size) % this.nodes.length;
    }
    if (didChange) {
      this.action.start(this.current.node);
      this.emit("change", true);
    }
    this.action.update(delta);
  }
  destroy() {
    this.control.release();
    this.control = null;
  }
};
function createAction(world2) {
  const widthPx = 300;
  const heightPx = 44;
  const pxToMeters = 0.01;
  const board = createBoard(widthPx, heightPx, pxToMeters, world2);
  const draw = (label, ratio) => {
    const text = board.measureText(47, heightPx / 2, label, "#ffffff", 18, 400);
    const pillWidth = 6 + 4 + 24 + 4 + 6 + 9 + text.width + 13;
    const left = (widthPx - pillWidth) / 2;
    board.clear();
    board.drawBox(left, 0, pillWidth, heightPx, heightPx / 2, "#000000");
    board.drawPie(left + 6, 6, 16, 100, "#484848");
    board.drawPie(left + 6, 6, 16, ratio * 100, "#ffffff");
    board.drawCircle(left + 10, 10, 12, "#000000");
    if (!isTouch) board.drawText(left + 16, 14, "E", "#ffffff", 18, 400);
    board.drawText(left + 47, 14, label, "#ffffff", 18, 400);
    board.commit();
  };
  const mesh = board.getMesh();
  let node = null;
  let cancelled = false;
  return {
    start(_node) {
      if (node) console.error("erm node already set");
      node = _node;
      world2.actions.btnDown = false;
      node.progress = 0;
      draw(node._label, node.progress / node._duration);
      world2.stage.scene.add(mesh);
    },
    update(delta) {
      if (!node) return;
      mesh.position.setFromMatrixPosition(node.matrixWorld);
      mesh.quaternion.setFromRotationMatrix(world2.camera.matrixWorld);
      world2.graphics.scaleUI(mesh, heightPx, pxToMeters);
      if (world2.actions.btnDown) {
        if (node.progress === 0) {
          cancelled = false;
          try {
            node._onStart();
          } catch (err) {
            console.error("action.onStart:", err);
          }
        }
        node.progress += delta;
        if (node.progress > node._duration) node.progress = node._duration;
        draw(node._label, node.progress / node._duration);
        if (node.progress === node._duration) {
          node.progress = 0;
          try {
            node._onTrigger({ playerId: world2.entities.player.data.id });
          } catch (err) {
            console.error("action.onTrigger:", err);
          }
        }
      } else if (node.progress > 0) {
        if (!cancelled) {
          try {
            node._onCancel();
          } catch (err) {
            console.error("action.onCancel:", err);
          }
          cancelled = true;
        }
        node.progress -= delta;
        if (node.progress < 0) node.progress = 0;
        draw(node._label, node.progress / node._duration);
      }
    },
    stop() {
      node = null;
      if (mesh.parent) {
        world2.stage.scene.remove(mesh);
      }
    }
  };
}
var sizes = [128, 256, 512, 2048, 4096];
function createBoard(width, height, pxToMeters, world2) {
  const max = Math.max(width, height);
  const size = sizes.find((size2) => size2 >= max);
  const pr = 1;
  const canvas = document.createElement("canvas");
  canvas.width = size * pr;
  canvas.height = size * pr;
  const ctx = canvas.getContext("2d");
  let texture;
  let mesh;
  return {
    canvas,
    drawBox(x5, y7, width2, height2, radius, color) {
      x5 *= pr;
      y7 *= pr;
      width2 *= pr;
      height2 *= pr;
      radius *= pr;
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.moveTo(x5 + radius, y7);
      ctx.arcTo(x5 + width2, y7, x5 + width2, y7 + height2, radius);
      ctx.arcTo(x5 + width2, y7 + height2, x5, y7 + height2, radius);
      ctx.arcTo(x5, y7 + height2, x5, y7, radius);
      ctx.arcTo(x5, y7, x5 + width2, y7, radius);
      ctx.closePath();
      ctx.fill();
    },
    drawCircle(x5, y7, radius, color) {
      x5 *= pr;
      y7 *= pr;
      radius *= pr;
      const centerX = x5 + radius;
      const centerY = y7 + radius;
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
      ctx.fillStyle = color;
      ctx.fill();
    },
    drawPie(x5, y7, radius, percent, color, offset = 0) {
      x5 *= pr;
      y7 *= pr;
      radius *= pr;
      const offsetRadians = offset * Math.PI / 180;
      const startAngle = -0.5 * Math.PI + offsetRadians;
      const endAngle = startAngle + percent / 100 * 2 * Math.PI;
      ctx.beginPath();
      ctx.moveTo(x5 + radius, y7 + radius);
      ctx.arc(x5 + radius, y7 + radius, radius, startAngle, endAngle);
      ctx.lineTo(x5 + radius, y7 + radius);
      ctx.closePath();
      ctx.fillStyle = color;
      ctx.fill();
    },
    measureText(x5, y7, text, color, fontSize = 16, fontWeight = 400, font = "Rubik") {
      fontSize *= pr;
      ctx.font = `${fontWeight} ${fontSize}px ${font}`;
      const metrics = ctx.measureText(text);
      return {
        width: metrics.width / pr
      };
    },
    drawText(x5, y7, text, color, fontSize = 16, fontWeight = 400, font = "Rubik") {
      x5 *= pr;
      y7 *= pr;
      fontSize *= pr;
      ctx.fillStyle = color;
      ctx.font = `${fontWeight} ${fontSize}px ${font}`;
      ctx.textAlign = "left";
      ctx.textBaseline = "top";
      ctx.fillText(text, x5, y7);
    },
    getMesh() {
      if (mesh) return mesh;
      const offsetX = 0;
      const offsetY = 0;
      texture = new THREE7.CanvasTexture(canvas);
      texture.colorSpace = THREE7.SRGBColorSpace;
      texture.anisotropy = world2.graphics.maxAnisotropy;
      texture.minFilter = THREE7.LinearFilter;
      texture.magFilter = THREE7.LinearFilter;
      const geometry = new THREE7.BufferGeometry();
      const halfWidth = width * pxToMeters / 2;
      const halfHeight = height * pxToMeters / 2;
      const vertices = new Float32Array([
        halfWidth,
        -halfHeight,
        0,
        // vertex 3 (bottom right)
        halfWidth,
        halfHeight,
        0,
        // vertex 2 (top right)
        -halfWidth,
        halfHeight,
        0,
        // vertex 1 (top left)
        -halfWidth,
        -halfHeight,
        0
        // vertex 0 (bottom left)
      ]);
      geometry.setAttribute("position", new THREE7.BufferAttribute(vertices, 3));
      const uvX1 = offsetX / size;
      const uvY1 = 1 - offsetY / size;
      const uvX2 = (offsetX + width) / size;
      const uvY2 = 1 - (offsetY + height) / size;
      const uvs = new Float32Array([
        uvX2,
        uvY2,
        // UV for vertex 3
        uvX2,
        uvY1,
        // UV for vertex 2
        uvX1,
        uvY1,
        // UV for vertex 1
        uvX1,
        uvY2
        // UV for vertex 0
      ]);
      geometry.setAttribute("uv", new THREE7.BufferAttribute(uvs, 2));
      const indices = new Uint16Array([
        0,
        1,
        2,
        // First triangle
        2,
        3,
        0
        // Second triangle
      ]);
      geometry.setIndex(new THREE7.BufferAttribute(indices, 1));
      const material2 = new THREE7.MeshBasicMaterial({ map: texture });
      material2.toneMapped = false;
      mesh = new THREE7.Mesh(geometry, material2);
      material2.depthTest = false;
      material2.depthWrite = false;
      material2.transparent = true;
      mesh.renderOrder = 999;
      return mesh;
    },
    commit() {
      if (!texture) return;
      texture.needsUpdate = true;
    },
    clear() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
  };
}

// src/core/systems/ClientTarget.js
import * as THREE8 from "three";
var ClientTarget = class extends System {
  constructor(world2) {
    super(world2);
  }
  init({ ui }) {
    this.ui = ui;
  }
  start() {
    this.guide = document.createElement("div");
    this.guide.style.position = "absolute";
    this.guide.style.width = "30px";
    this.guide.style.height = "30px";
    this.guide.style.display = "flex";
    this.guide.style.alignItems = "center";
    this.guide.style.justifyContent = "center";
    this.guide.style.transform = "translate(-50%, -50%)";
    this.guide.style.filter = "drop-shadow(0px 0px 4px rgba(0, 0, 0, 0.25))";
    this.guide.innerHTML = targetSVG;
  }
  show(vec3) {
    this.target = vec3;
    this.ui.appendChild(this.guide);
    this.bounds = this.ui.getBoundingClientRect();
  }
  hide() {
    if (this.target) {
      this.target = null;
      this.ui.removeChild(this.guide);
    }
  }
  lateUpdate() {
    if (!this.target) return;
    const vector = new THREE8.Vector3().copy(this.target);
    vector.project(this.world.camera);
    const x5 = (vector.x + 1) * this.bounds.width / 2;
    const y7 = (-vector.y + 1) * this.bounds.height / 2;
    if (vector.z > 1) {
      this.guide.style.display = "none";
      return;
    }
    if (vector.x >= -1 && vector.x <= 1 && vector.y >= -1 && vector.y <= 1) {
      this.guide.style.left = `${x5}px`;
      this.guide.style.top = `${y7}px`;
      this.guide.style.display = "block";
    } else {
      const centerX = this.bounds.width / 2;
      const centerY = this.bounds.height / 2;
      const pt = intersectLineWithRect(
        centerX,
        centerY,
        x5,
        y7,
        this.bounds.width,
        this.bounds.height,
        /* optional padding */
        10
      );
      if (!pt) {
        this.guide.style.display = "none";
        return;
      }
      this.guide.style.left = `${pt.x}px`;
      this.guide.style.top = `${pt.y}px`;
      this.guide.style.display = "block";
    }
  }
};
var targetSVG = `
<svg
  xmlns='http://www.w3.org/2000/svg'
  width='24'
  height='24'
  viewBox='0 0 24 24'
  fill='none'
  stroke='currentColor'
  stroke-width='2'
  stroke-linecap='round'
  stroke-linejoin='round'
  class='lucide lucide-crosshair'
>
  <circle cx='12' cy='12' r='10' />
  <line x1='22' x2='18' y1='12' y2='12' />
  <line x1='6' x2='2' y1='12' y2='12' />
  <line x1='12' x2='12' y1='6' y2='2' />
  <line x1='12' x2='12' y1='22' y2='18' />
</svg>
`;
function intersectLineWithRect(cx, cy, x5, y7, width, height, padding = 0) {
  const dx = x5 - cx;
  const dy = y7 - cy;
  if (dx === 0 && dy === 0) return { x: cx, y: cy };
  let tMin = Number.POSITIVE_INFINITY;
  if (dx !== 0) {
    const t6 = (0 - cx) / dx;
    if (t6 > 0) {
      const iy2 = cy + t6 * dy;
      if (iy2 >= 0 && iy2 <= height) {
        tMin = Math.min(tMin, t6);
      }
    }
  }
  if (dx !== 0) {
    const t6 = (width - cx) / dx;
    if (t6 > 0) {
      const iy2 = cy + t6 * dy;
      if (iy2 >= 0 && iy2 <= height) {
        tMin = Math.min(tMin, t6);
      }
    }
  }
  if (dy !== 0) {
    const t6 = (0 - cy) / dy;
    if (t6 > 0) {
      const ix2 = cx + t6 * dx;
      if (ix2 >= 0 && ix2 <= width) {
        tMin = Math.min(tMin, t6);
      }
    }
  }
  if (dy !== 0) {
    const t6 = (height - cy) / dy;
    if (t6 > 0) {
      const ix2 = cx + t6 * dx;
      if (ix2 >= 0 && ix2 <= width) {
        tMin = Math.min(tMin, t6);
      }
    }
  }
  if (tMin === Number.POSITIVE_INFINITY) {
    return null;
  }
  const ix = cx + tMin * dx;
  const iy = cy + tMin * dy;
  const clampedX = Math.min(Math.max(ix, padding), width - padding);
  const clampedY = Math.min(Math.max(iy, padding), height - padding);
  return { x: clampedX, y: clampedY };
}

// src/core/systems/ClientUI.js
var appPanes = ["app", "script", "nodes", "meta"];
var ClientUI = class extends System {
  constructor(world2) {
    super(world2);
    this.state = {
      visible: true,
      active: false,
      app: null,
      pane: null
    };
    this.lastAppPane = "app";
    this.control = null;
  }
  start() {
    this.control = this.world.controls.bind({ priority: ControlPriorities.CORE_UI });
  }
  update() {
    if (this.control.escape.pressed) {
      if (this.state.pane) {
        this.state.pane = null;
        this.broadcast();
      } else if (this.state.app) {
        this.state.app = null;
        this.broadcast();
      }
    }
    if (this.control.keyZ.pressed && !this.control.metaLeft.down && !this.control.controlLeft.down && !this.control.shiftLeft.down) {
      this.state.visible = !this.state.visible;
      this.broadcast();
    }
    if (this.control.pointer.locked && this.state.active) {
      this.state.active = false;
      this.broadcast();
    }
    if (!this.control.pointer.locked && !this.state.active) {
      this.state.active = true;
      this.broadcast();
    }
  }
  togglePane(pane) {
    if (pane === null || this.state.pane === pane) {
      this.state.pane = null;
    } else {
      this.state.pane = pane;
      if (appPanes.includes(pane)) {
        this.lastAppPane = pane;
      }
    }
    this.broadcast();
  }
  setApp(app) {
    this.state.app = app;
    this.state.pane = app ? this.lastAppPane : null;
    this.broadcast();
  }
  broadcast() {
    this.world.emit("ui", { ...this.state });
  }
};

// src/core/systems/LODs.js
var BATCH_SIZE2 = 1e3;
var LODs = class extends System {
  constructor(world2) {
    super(world2);
    this.nodes = [];
    this.cursor = 0;
  }
  register(node) {
    this.nodes.push(node);
  }
  unregister(node) {
    const idx = this.nodes.indexOf(node);
    if (idx === -1) return;
    this.nodes.splice(idx, 1);
  }
  update(delta) {
    const size = Math.min(this.nodes.length, BATCH_SIZE2);
    for (let i5 = 0; i5 < size; i5++) {
      const idx = (this.cursor + i5) % this.nodes.length;
      const node = this.nodes[idx];
      if (!node) continue;
      node.check();
    }
    if (size) {
      this.cursor = (this.cursor + size) % this.nodes.length;
    }
  }
};

// src/core/systems/Nametags.js
var RES = 2;
var NAMETAG_WIDTH = 200 * RES;
var NAMETAG_HEIGHT = 35 * RES;
var NAMETAG_BORDER_RADIUS = 10 * RES;
var NAME_FONT_SIZE = 16 * RES;
var NAME_OUTLINE_SIZE = 4 * RES;
var HEALTH_MAX2 = 100;
var HEALTH_HEIGHT = 12 * RES;
var HEALTH_WIDTH = 100 * RES;
var HEALTH_BORDER = 1.5 * RES;
var HEALTH_BORDER_RADIUS = 20 * RES;
var PER_ROW = 5;
var PER_COLUMN = 20;
var MAX_INSTANCES = PER_ROW * PER_COLUMN;
var defaultQuaternion = new three_exports.Quaternion(0, 0, 0, 1);
var defaultScale = new Vector3Enhanced(1, 1, 1);
var v112 = new Vector3Enhanced();
var Nametags = class extends System {
  constructor(world2) {
    super(world2);
    this.nametags = [];
    this.canvas = document.createElement("canvas");
    this.canvas.width = NAMETAG_WIDTH * PER_ROW;
    this.canvas.height = NAMETAG_HEIGHT * PER_COLUMN;
    this.ctx = this.canvas.getContext("2d");
    this.texture = new three_exports.CanvasTexture(this.canvas);
    this.texture.colorSpace = three_exports.SRGBColorSpace;
    this.texture.flipY = false;
    this.texture.needsUpdate = true;
    this.uniforms = {
      uAtlas: { value: this.texture },
      uXR: { value: 0 },
      uOrientation: { value: this.world.rig.quaternion }
    };
    this.material = new B({
      baseMaterial: three_exports.MeshBasicMaterial,
      // all nametags are drawn on top of everything
      // this isn't perfect but we should be improve.
      // also note mesh.renderOrder=9999
      transparent: true,
      depthWrite: false,
      depthTest: false,
      uniforms: this.uniforms,
      vertexShader: `
        attribute vec2 coords;
        uniform float uXR;
        uniform vec4 uOrientation;
        varying vec2 vUv;

        vec3 applyQuaternion(vec3 pos, vec4 quat) {
          vec3 qv = vec3(quat.x, quat.y, quat.z);
          vec3 t = 2.0 * cross(qv, pos);
          return pos + quat.w * t + cross(qv, t);
        }

        vec4 lookAtQuaternion(vec3 instancePos) {
          vec3 up = vec3(0.0, 1.0, 0.0);
          vec3 forward = normalize(cameraPosition - instancePos);
          
          // Handle degenerate cases
          if(length(forward) < 0.001) {
            return vec4(0.0, 0.0, 0.0, 1.0);
          }
          
          vec3 right = normalize(cross(up, forward));
          up = cross(forward, right);
          
          float m00 = right.x;
          float m01 = right.y;
          float m02 = right.z;
          float m10 = up.x;
          float m11 = up.y;
          float m12 = up.z;
          float m20 = forward.x;
          float m21 = forward.y;
          float m22 = forward.z;
          
          float trace = m00 + m11 + m22;
          vec4 quat;
          
          if(trace > 0.0) {
            float s = 0.5 / sqrt(trace + 1.0);
            quat = vec4(
              (m12 - m21) * s,
              (m20 - m02) * s,
              (m01 - m10) * s,
              0.25 / s
            );
          } else if(m00 > m11 && m00 > m22) {
            float s = 2.0 * sqrt(1.0 + m00 - m11 - m22);
            quat = vec4(
              0.25 * s,
              (m01 + m10) / s,
              (m20 + m02) / s,
              (m12 - m21) / s
            );
          } else if(m11 > m22) {
            float s = 2.0 * sqrt(1.0 + m11 - m00 - m22);
            quat = vec4(
              (m01 + m10) / s,
              0.25 * s,
              (m12 + m21) / s,
              (m20 - m02) / s
            );
          } else {
            float s = 2.0 * sqrt(1.0 + m22 - m00 - m11);
            quat = vec4(
              (m20 + m02) / s,
              (m12 + m21) / s,
              0.25 * s,
              (m01 - m10) / s
            );
          }
          
          return normalize(quat);
        }

        void main() {
          vec3 newPosition = position;
          if (uXR > 0.5) {
            // XR looks at camera
            vec3 instancePos = vec3(
              instanceMatrix[3][0],
              instanceMatrix[3][1],
              instanceMatrix[3][2]
            );
            vec4 lookAtQuat = lookAtQuaternion(instancePos);
            newPosition = applyQuaternion(newPosition, lookAtQuat);
          } else {
            // non-XR matches camera rotation
            newPosition = applyQuaternion(newPosition, uOrientation);
          }
          csm_Position = newPosition;
          
          // use uvs just for this slot
          vec2 atlasUV = uv; // original UVs are 0-1 for the plane
          atlasUV.y = 1.0 - atlasUV.y;
          atlasUV /= vec2(${PER_ROW}, ${PER_COLUMN});
          atlasUV += coords;
          vUv = atlasUV;          
        }
      `,
      fragmentShader: `
        uniform sampler2D uAtlas;
        varying vec2 vUv;
        
        void main() {
          vec4 texColor = texture2D(uAtlas, vUv);
          csm_FragColor = texColor;
        }
      `
    });
    this.geometry = new three_exports.PlaneGeometry(1, NAMETAG_HEIGHT / NAMETAG_WIDTH);
    this.geometry.setAttribute("coords", new three_exports.InstancedBufferAttribute(new Float32Array(MAX_INSTANCES * 2), 2));
    this.mesh = new three_exports.InstancedMesh(this.geometry, this.material, MAX_INSTANCES);
    this.mesh.renderOrder = 9999;
    this.mesh.matrixAutoUpdate = false;
    this.mesh.matrixWorldAutoUpdate = false;
    this.mesh.frustumCulled = false;
    this.mesh.count = 0;
  }
  start() {
    this.world.stage.scene.add(this.mesh);
    this.world.on("xrSession", this.onXRSession);
  }
  add({ name: name2, health }) {
    const idx = this.nametags.length;
    if (idx >= MAX_INSTANCES) return console.error("nametags: reached max");
    this.mesh.count++;
    this.mesh.instanceMatrix.needsUpdate = true;
    const row = Math.floor(idx / PER_ROW);
    const col = idx % PER_ROW;
    const coords = this.mesh.geometry.attributes.coords;
    coords.setXY(idx, col / PER_ROW, row / PER_COLUMN);
    coords.needsUpdate = true;
    const matrix = new three_exports.Matrix4();
    matrix.compose(new Vector3Enhanced(), defaultQuaternion, defaultScale);
    const nametag = {
      idx,
      name: name2,
      health,
      matrix,
      move: (newMatrix) => {
        matrix.elements[12] = newMatrix.elements[12];
        matrix.elements[13] = newMatrix.elements[13];
        matrix.elements[14] = newMatrix.elements[14];
        this.mesh.setMatrixAt(nametag.idx, matrix);
        this.mesh.instanceMatrix.needsUpdate = true;
      },
      setName: (name3) => {
        if (nametag.name === name3) return;
        nametag.name = name3;
        this.draw(nametag);
      },
      setHealth: (health2) => {
        if (nametag.health === health2) return;
        nametag.health = health2;
        this.draw(nametag);
        console.log("SET HEALTH", health2);
      },
      destroy: () => {
        this.remove(nametag);
      }
    };
    this.nametags[idx] = nametag;
    this.draw(nametag);
    return nametag;
  }
  remove(nametag) {
    if (!this.nametags.includes(nametag)) {
      return console.warn("nametags: attempted to remove non-existent nametag");
    }
    const last = this.nametags[this.nametags.length - 1];
    const isLast = nametag === last;
    if (isLast) {
      this.nametags.pop();
      this.undraw(nametag);
    } else {
      this.undraw(last);
      last.idx = nametag.idx;
      this.draw(last);
      const coords = this.mesh.geometry.attributes.coords;
      const row = Math.floor(nametag.idx / PER_ROW);
      const col = nametag.idx % PER_ROW;
      coords.setXY(nametag.idx, col / PER_ROW, row / PER_COLUMN);
      coords.needsUpdate = true;
      this.mesh.setMatrixAt(last.idx, last.matrix);
      this.nametags[last.idx] = last;
      this.nametags.pop();
    }
    this.mesh.count--;
    this.mesh.instanceMatrix.needsUpdate = true;
  }
  draw(nametag) {
    const idx = nametag.idx;
    const row = Math.floor(idx / PER_ROW);
    const col = idx % PER_ROW;
    const x5 = col * NAMETAG_WIDTH;
    const y7 = row * NAMETAG_HEIGHT;
    this.ctx.clearRect(x5, y7, NAMETAG_WIDTH, NAMETAG_HEIGHT);
    this.ctx.font = `800 ${NAME_FONT_SIZE}px Rubik`;
    this.ctx.fillStyle = "white";
    this.ctx.textAlign = "center";
    this.ctx.textBaseline = "top";
    this.ctx.lineWidth = NAME_OUTLINE_SIZE;
    this.ctx.strokeStyle = "rgba(0,0,0,0.5)";
    const text = this.fitText(nametag.name, NAMETAG_WIDTH);
    this.ctx.save();
    this.ctx.globalCompositeOperation = "xor";
    this.ctx.globalAlpha = 1;
    this.ctx.strokeText(text, x5 + NAMETAG_WIDTH / 2, y7 + 2);
    this.ctx.restore();
    this.ctx.fillText(text, x5 + NAMETAG_WIDTH / 2, y7 + 2);
    if (nametag.health < HEALTH_MAX2) {
      {
        const fillStyle = "rgba(0, 0, 0, 0.6)";
        const width = HEALTH_WIDTH;
        const height = HEALTH_HEIGHT;
        const left = x5 + (NAMETAG_WIDTH - HEALTH_WIDTH) / 2;
        const top = y7 + NAME_FONT_SIZE + 5;
        const borderRadius = HEALTH_BORDER_RADIUS;
        fillRoundRect(this.ctx, left, top, width, height, borderRadius, fillStyle);
      }
      {
        const fillStyle = "#229710";
        const maxWidth = HEALTH_WIDTH - HEALTH_BORDER * 2;
        const perc = nametag.health / HEALTH_MAX2;
        const width = maxWidth * perc;
        const height = HEALTH_HEIGHT - HEALTH_BORDER * 2;
        const left = x5 + (NAMETAG_WIDTH - HEALTH_WIDTH) / 2 + HEALTH_BORDER;
        const top = y7 + NAME_FONT_SIZE + 5 + HEALTH_BORDER;
        const borderRadius = HEALTH_BORDER_RADIUS;
        fillRoundRect(this.ctx, left, top, width, height, borderRadius, fillStyle);
      }
    }
    this.texture.needsUpdate = true;
  }
  fitText(text, maxWidth) {
    const width = this.ctx.measureText(text).width;
    if (width <= maxWidth) {
      return text;
    }
    const ellipsis = "...";
    let truncated = text;
    const ellipsisWidth = this.ctx.measureText(ellipsis).width;
    while (truncated.length > 0) {
      truncated = truncated.slice(0, -1);
      const truncatedWidth = this.ctx.measureText(truncated).width;
      if (truncatedWidth + ellipsisWidth <= maxWidth) {
        return truncated + ellipsis;
      }
    }
    return ellipsis;
  }
  undraw(nametag) {
    const idx = nametag.idx;
    const row = Math.floor(idx / PER_ROW);
    const col = idx % PER_ROW;
    const x5 = col * NAMETAG_WIDTH;
    const y7 = row * NAMETAG_HEIGHT;
    this.ctx.clearRect(x5, y7, NAMETAG_WIDTH, NAMETAG_HEIGHT);
    this.texture.needsUpdate = true;
  }
  onXRSession = (session) => {
    this.uniforms.uXR.value = session ? 1 : 0;
  };
};

// src/core/systems/Particles.js
var v113 = new Vector3Enhanced();
var v27 = new Vector3Enhanced();
var e14 = new three_exports.Euler(0, 0, 0, "YXZ");
var arr12 = [];
var arr2 = [];
var billboardModeInts = {
  full: 0,
  y: 1,
  direction: 2
};
var Particles2 = class extends System {
  constructor(world2) {
    super(world2);
    this.worker = null;
    this.uOrientationFull = { value: this.world.rig.quaternion };
    this.uOrientationY = { value: new three_exports.Quaternion() };
    this.emitters = /* @__PURE__ */ new Map();
  }
  init() {
    this.worker = new Worker(window.PARTICLES_PATH);
    this.worker.onmessage = this.onMessage;
    this.worker.onerror = this.onError;
  }
  start() {
    this.world.on("xrSession", this.onXRSession);
  }
  register(node) {
    return createEmitter(this.world, this, node);
  }
  update(delta) {
    e14.setFromQuaternion(this.uOrientationFull.value);
    e14.x = 0;
    e14.z = 0;
    this.uOrientationY.value.setFromEuler(e14);
    this.emitters.forEach((emitter) => {
      emitter.update(delta);
    });
  }
  onMessage = (msg) => {
    msg = msg.data;
    this.emitters.get(msg.emitterId)?.onMessage(msg);
  };
  onError = (err) => {
    console.error("[ParticleSystem]", err);
  };
  onXRSession = (session) => {
    this.uOrientationFull.value = session ? this.world.xr.camera.quaternion : this.world.rig.quaternion;
  };
};
function createEmitter(world2, system, node) {
  const id = uuid();
  const config3 = node.getConfig();
  const geometry = new three_exports.PlaneGeometry(1, 1);
  const aPosition = new three_exports.InstancedBufferAttribute(new Float32Array(node._max * 3), 3);
  aPosition.setUsage(three_exports.DynamicDrawUsage);
  geometry.setAttribute("aPosition", aPosition);
  const aRotation = new three_exports.InstancedBufferAttribute(new Float32Array(node._max * 1), 1);
  aRotation.setUsage(three_exports.DynamicDrawUsage);
  geometry.setAttribute("aRotation", aRotation);
  const aDirection = new three_exports.InstancedBufferAttribute(new Float32Array(node._max * 3), 3);
  aDirection.setUsage(three_exports.DynamicDrawUsage);
  geometry.setAttribute("aDirection", aDirection);
  const aSize = new three_exports.InstancedBufferAttribute(new Float32Array(node._max * 1), 1);
  aSize.setUsage(three_exports.DynamicDrawUsage);
  geometry.setAttribute("aSize", aSize);
  const aColor = new three_exports.InstancedBufferAttribute(new Float32Array(node._max * 3), 3);
  aColor.setUsage(three_exports.DynamicDrawUsage);
  geometry.setAttribute("aColor", aColor);
  const aAlpha = new three_exports.InstancedBufferAttribute(new Float32Array(node._max * 1), 1);
  aAlpha.setUsage(three_exports.DynamicDrawUsage);
  geometry.setAttribute("aAlpha", aAlpha);
  const aEmissive = new three_exports.InstancedBufferAttribute(new Float32Array(node._max * 1), 1);
  aEmissive.setUsage(three_exports.DynamicDrawUsage);
  geometry.setAttribute("aEmissive", aEmissive);
  const aUV = new three_exports.InstancedBufferAttribute(new Float32Array(node._max * 4), 4);
  aUV.setUsage(three_exports.DynamicDrawUsage);
  geometry.setAttribute("aUV", aUV);
  const next = {
    aPosition: new Float32Array(node._max * 3),
    aRotation: new Float32Array(node._max * 1),
    aDirection: new Float32Array(node._max * 3),
    aSize: new Float32Array(node._max * 1),
    aColor: new Float32Array(node._max * 3),
    aAlpha: new Float32Array(node._max * 1),
    aEmissive: new Float32Array(node._max * 1),
    aUV: new Float32Array(node._max * 4)
  };
  const texture = new three_exports.Texture();
  texture.colorSpace = three_exports.SRGBColorSpace;
  const uniforms = {
    uTexture: { value: texture },
    uBillboard: { value: billboardModeInts[node._billboard] },
    uOrientation: node._billboard === "full" ? system.uOrientationFull : system.uOrientationY
  };
  world2.loader.load("texture", node._image).then((texture2) => {
    texture2.colorSpace = three_exports.SRGBColorSpace;
    uniforms.uTexture.value = texture2;
  });
  const material2 = new B({
    baseMaterial: node._lit ? three_exports.MeshStandardMaterial : three_exports.MeshBasicMaterial,
    ...node._lit ? { roughness: 1, metalness: 0 } : {},
    blending: node._blending === "additive" ? three_exports.AdditiveBlending : three_exports.NormalBlending,
    transparent: true,
    premultipliedAlpha: true,
    color: "white",
    side: three_exports.DoubleSide,
    // side: THREE.FrontSide,
    depthWrite: false,
    depthTest: true,
    uniforms,
    vertexShader: `
      attribute vec3 aPosition;
      attribute float aRotation;
      attribute vec3 aDirection;
      attribute float aSize;
      attribute vec3 aColor;
      attribute float aAlpha;
      attribute float aEmissive;
      attribute vec4 aUV;  // u0, v0, u1, v1

      uniform float uBillboard;
      uniform vec4 uOrientation;

      varying vec2 vUv;
      varying vec4 vColor;
      varying float vEmissive;

      const float DEG2RAD = ${DEG2RAD};

      mat3 rotationFromDirection(vec3 dir) {
        vec3 n = normalize(dir);              // target normal (+Z after the rotation)
        vec3 up = vec3(0.0, 1.0, 0.0);
        // pick a new 'up' if we are too parallel
        if (abs(dot(n, up)) > 0.99) {
          up = vec3(1.0, 0.0, 0.0);
        } 
        vec3 right = normalize(cross(up, n)); // 1st column
        up = cross(n, right); // 2nd column (already normalised)
        return mat3(
          right,  // column 0
          up,     // column 1
          n       // column 2  \u2190  billboard normal
        );                   
      }

      vec3 applyQuaternion(vec3 pos, vec4 quat) {
        vec3 qv = vec3(quat.x, quat.y, quat.z);
        vec3 t = 2.0 * cross(qv, pos);
        return pos + quat.w * t + cross(qv, t);
      }

      void main() {
        // vUv = uv;
        // Pass UV coordinates to fragment shader
        // Map plane UV (0-1) to the frame UV rectangle
        vUv = vec2(
          mix(aUV.x, aUV.z, uv.x),
          mix(aUV.y, aUV.w, uv.y)
        );

        // Start with original position
        vec3 newPosition = position;

        // Apply size
        newPosition.xy *= aSize;

        // Apply rotation
        float rot = aRotation * DEG2RAD;
        float cosRot = cos(rot);
        float sinRot = sin(rot);
        newPosition.xy = vec2(
          newPosition.x * cosRot + newPosition.y * sinRot,
          -newPosition.x * sinRot + newPosition.y * cosRot
        );

        // Apply billboard
        if (uBillboard < 0.1) {
          // full
          newPosition = applyQuaternion(newPosition, uOrientation);
        } else if (uBillboard < 1.1) {
          // y
          newPosition = applyQuaternion(newPosition, uOrientation);
        } else {
          // direction 
          newPosition = rotationFromDirection(aDirection) * newPosition;
        }
        
        // Apply particle position
        newPosition += aPosition;
        
        // Set final position
        csm_Position = newPosition;

        // Set color varying for the fragment shader
        vColor = vec4(aColor.rgb, aAlpha);
        vEmissive = aEmissive;
      }
    `,
    fragmentShader: `
      uniform sampler2D uTexture;

      varying vec2 vUv;
      varying vec4 vColor;
      varying float vEmissive;

      void main() {
        vec4 texColor = texture(uTexture, vUv);
        vec4 baseColor = texColor * vColor;
        baseColor.rgb *= vEmissive;
        csm_DiffuseColor = baseColor;
      }
    `
  });
  const mesh = new three_exports.InstancedMesh(geometry, material2, node._max);
  mesh._node = node;
  mesh.count = 0;
  mesh.instanceMatrix.needsUpdate = true;
  mesh.frustumCulled = false;
  mesh.matrixAutoUpdate = false;
  mesh.matrixWorldAutoUpdate = false;
  world2.stage.scene.add(mesh);
  let matrixWorld = node.matrixWorld;
  let pending = false;
  let skippedDelta = 0;
  function send(msg, transfers) {
    msg.emitterId = id;
    system.worker.postMessage(msg, transfers);
  }
  function setEmitting(value) {
    send({ op: "emitting", value });
  }
  function onMessage(msg) {
    if (msg.op === "update") {
      const n6 = msg.n;
      next.aPosition = aPosition.array;
      next.aRotation = aRotation.array;
      next.aDirection = aDirection.array;
      next.aSize = aSize.array;
      next.aColor = aColor.array;
      next.aAlpha = aAlpha.array;
      next.aEmissive = aEmissive.array;
      next.aUV = aUV.array;
      aPosition.array = msg.aPosition;
      aPosition.addUpdateRange(0, n6 * 3);
      aPosition.needsUpdate = true;
      aRotation.array = msg.aRotation;
      aRotation.addUpdateRange(0, n6 * 1);
      aRotation.needsUpdate = true;
      aDirection.array = msg.aDirection;
      aDirection.addUpdateRange(0, n6 * 3);
      aDirection.needsUpdate = true;
      aSize.array = msg.aSize;
      aSize.addUpdateRange(0, n6 * 1);
      aSize.needsUpdate = true;
      aColor.array = msg.aColor;
      aColor.addUpdateRange(0, n6 * 3);
      aColor.needsUpdate = true;
      aAlpha.array = msg.aAlpha;
      aAlpha.addUpdateRange(0, n6 * 1);
      aAlpha.needsUpdate = true;
      aEmissive.array = msg.aEmissive;
      aEmissive.addUpdateRange(0, n6 * 1);
      aEmissive.needsUpdate = true;
      aUV.array = msg.aUV;
      aUV.addUpdateRange(0, n6 * 4);
      aUV.needsUpdate = true;
      mesh.count = n6;
      pending = false;
    }
    if (msg.op === "end") {
      node._onEnd?.();
    }
  }
  function update(delta) {
    const camPosition = v113.setFromMatrixPosition(world2.camera.matrixWorld);
    const worldPosition = v27.setFromMatrixPosition(matrixWorld);
    const distance = camPosition.distanceTo(worldPosition);
    mesh.renderOrder = -distance;
    if (pending) {
      skippedDelta += delta;
    } else {
      delta += skippedDelta;
      skippedDelta = 0;
      const aPosition2 = next.aPosition;
      const aRotation2 = next.aRotation;
      const aDirection2 = next.aDirection;
      const aSize2 = next.aSize;
      const aColor2 = next.aColor;
      const aAlpha2 = next.aAlpha;
      const aEmissive2 = next.aEmissive;
      const aUV2 = next.aUV;
      pending = true;
      send(
        {
          op: "update",
          delta,
          camPosition: camPosition.toArray(arr12),
          matrixWorld: matrixWorld.toArray(arr2),
          aPosition: aPosition2,
          aRotation: aRotation2,
          aDirection: aDirection2,
          aSize: aSize2,
          aColor: aColor2,
          aAlpha: aAlpha2,
          aEmissive: aEmissive2,
          aUV: aUV2
        },
        [
          // prettier-ignore
          aPosition2.buffer,
          aRotation2.buffer,
          aDirection2.buffer,
          aSize2.buffer,
          aColor2.buffer,
          aAlpha2.buffer,
          aEmissive2.buffer,
          aUV2.buffer
        ]
      );
    }
  }
  function destroy() {
    system.emitters.delete(id);
    system.worker.postMessage({ op: "destroy", emitterId: id });
    world2.stage.scene.remove(mesh);
    mesh.material.dispose();
    mesh.geometry.dispose();
  }
  const handle = {
    id,
    node,
    send,
    setEmitting,
    onMessage,
    update,
    destroy
  };
  system.emitters.set(id, handle);
  system.worker.postMessage({ op: "create", id, ...config3 });
  return handle;
}

// src/core/extras/SnapOctree.js
var _v16 = new Vector3Enhanced();
var _sphere2 = new three_exports.Sphere();
var SnapOctree = class {
  constructor({ center, size }) {
    this.root = new SnapOctreeNode(null, center, size);
  }
  insert(point) {
    let added = this.root.insert(point);
    if (!added) {
      while (!this.root.canContain(point.position)) {
        this.expand();
      }
      added = this.root.insert(point);
    }
    return added;
  }
  remove(point) {
    point._node.remove(point);
  }
  move(point) {
    if (!point._node) {
      return false;
    }
    if (point._node.canContain(point.position)) {
      return;
    }
    const prevNode = point._node;
    this.remove(point);
    const added = this.insert(point);
    if (!added) {
      console.error("octree point moved but was not re-added. did it move outside octree bounds?");
      return false;
    }
    prevNode.checkCollapse();
    return true;
  }
  expand() {
    let prevRoot;
    let size;
    let center;
    prevRoot = this.root;
    size = prevRoot.size * 2;
    center = new Vector3Enhanced(
      prevRoot.center.x + prevRoot.size,
      prevRoot.center.y + prevRoot.size,
      prevRoot.center.z + prevRoot.size
    );
    const first = new SnapOctreeNode(null, center, size);
    first.subdivide();
    first.children[0].destroy();
    first.children[0] = prevRoot;
    prevRoot.parent = first;
    this.root = first;
    this.root.count = prevRoot.count;
    prevRoot = this.root;
    size = prevRoot.size * 2;
    center = new Vector3Enhanced(
      prevRoot.center.x - prevRoot.size,
      prevRoot.center.y - prevRoot.size,
      prevRoot.center.z - prevRoot.size
    );
    const second = new SnapOctreeNode(null, center, size);
    second.subdivide();
    second.children[7].destroy();
    second.children[7] = prevRoot;
    prevRoot.parent = second;
    this.root = second;
    this.root.count = prevRoot.count;
  }
  query(position, radius, results = []) {
    _sphere2.center.copy(position);
    _sphere2.radius = radius;
    this.root.query(_sphere2, results);
    results.sort(sortAscending2);
    return results;
  }
  getDepth() {
    return this.root.getDepth();
  }
  getCount() {
    return this.root.getCount();
  }
};
var SnapOctreeNode = class _SnapOctreeNode {
  constructor(parent, center, size) {
    this.parent = parent;
    this.center = center;
    this.size = size;
    this.inner = new three_exports.Box3(
      new Vector3Enhanced(center.x - size, center.y - size, center.z - size),
      new Vector3Enhanced(center.x + size, center.y + size, center.z + size)
    );
    this.points = [];
    this.count = 0;
    this.children = [];
  }
  insert(point) {
    if (!this.canContain(point.position)) {
      return false;
    }
    if (this.size < 1 || !this.children.length) {
      this.points.push(point);
      point._node = this;
      this.inc(1);
      return true;
    }
    if (!this.children.length) {
      this.subdivide();
    }
    for (const child of this.children) {
      if (child.insert(point)) {
        return true;
      }
    }
    console.error("snap octree insert fail");
  }
  remove(point) {
    const idx = this.points.indexOf(point);
    this.points.splice(idx, 1);
    point._node = null;
    this.dec(1);
  }
  inc(amount) {
    let node = this;
    while (node) {
      node.count += amount;
      node = node.parent;
    }
  }
  dec(amount) {
    let node = this;
    while (node) {
      node.count -= amount;
      node = node.parent;
    }
  }
  canContain(position) {
    return this.inner.containsPoint(position);
  }
  checkCollapse() {
    let match;
    let node = this;
    while (node) {
      if (node.count) break;
      if (node.children.length) match = node;
      node = node.parent;
    }
    match?.collapse();
  }
  collapse() {
    for (const child of this.children) {
      child.collapse();
      child.destroy();
    }
    this.children = [];
  }
  subdivide() {
    if (this.children.length) return;
    const halfSize = this.size / 2;
    for (let x5 = 0; x5 < 2; x5++) {
      for (let y7 = 0; y7 < 2; y7++) {
        for (let z4 = 0; z4 < 2; z4++) {
          const center = new Vector3Enhanced(
            this.center.x + halfSize * (2 * x5 - 1),
            this.center.y + halfSize * (2 * y7 - 1),
            this.center.z + halfSize * (2 * z4 - 1)
          );
          const child = new _SnapOctreeNode(this, center, halfSize);
          this.children.push(child);
        }
      }
    }
  }
  query(sphere, results) {
    if (!sphere.intersectsBox(this.inner)) {
      return;
    }
    for (const point of this.points) {
      if (!point.active) continue;
      const distance = sphere.center.distanceTo(point.position);
      if (distance <= sphere.radius) {
        results.push({
          position: point.position,
          distance
        });
      }
    }
    for (const child of this.children) {
      child.query(sphere, results);
    }
  }
  getDepth() {
    if (this.children.length === 0) {
      return 1;
    }
    return 1 + Math.max(...this.children.map((child) => child.getDepth()));
  }
  getCount() {
    let count = 1;
    for (const child of this.children) {
      count += child.getCount();
    }
    return count;
  }
  destroy() {
    this.points = [];
    this.children = [];
  }
};
function sortAscending2(a5, b6) {
  return a5.distance - b6.distance;
}

// src/core/systems/Snaps.js
var Snaps = class extends System {
  constructor(world2) {
    super(world2);
    this.octree = new SnapOctree({
      center: new THREE.Vector3(0, 0, 0),
      size: 10
    });
  }
  create(position, active) {
    const point = {
      position,
      active
    };
    this.octree.insert(point);
    const handle = {
      move: () => {
        this.octree.move(point);
      },
      destroy: () => {
        this.octree.remove(point);
      }
    };
    return handle;
  }
};

// src/core/systems/Wind.js
import * as THREE9 from "three";
var Wind = class extends System {
  constructor(world2) {
    super(world2);
    this.uniforms = {
      time: { value: 0 },
      strength: { value: 1 },
      // 3 nice for pine
      direction: { value: new THREE9.Vector3(1, 0, 0) },
      speed: { value: 0.5 },
      // 0.1 nice for pine
      noiseScale: { value: 1 },
      // 0.5 nice for pine
      ampScale: { value: 0.2 },
      freqMultiplier: { value: 1 }
    };
  }
  update(delta) {
    this.uniforms.time.value += delta;
  }
};

// src/core/systems/XR.js
import { XRControllerModelFactory } from "three/addons";
var UP2 = new Vector3Enhanced(0, 1, 0);
var v114 = new Vector3Enhanced();
var e15 = new three_exports.Euler(0, 0, 0, "YXZ");
var XR = class extends System {
  constructor(world2) {
    super(world2);
    this.session = null;
    this.camera = null;
    this.controller1Model = null;
    this.controller2Model = null;
    this.supportsVR = false;
    this.supportsAR = false;
    this.controllerModelFactory = new XRControllerModelFactory();
  }
  async init() {
    this.supportsVR = await navigator.xr?.isSessionSupported("immersive-vr");
    this.supportsAR = await navigator.xr?.isSessionSupported("immersive-ar");
  }
  async enter() {
    const session = await navigator.xr?.requestSession("immersive-vr", {
      requiredFeatures: ["local-floor"]
    });
    this.world.entities.player.avatar.unmount();
    this.world.graphics.renderer.xr.setSession(session);
    session.addEventListener("end", this.onSessionEnd);
    this.session = session;
    this.camera = this.world.graphics.renderer.xr.getCamera();
    this.world.emit("xrSession", session);
    this.controller1Model = this.world.graphics.renderer.xr.getControllerGrip(0);
    this.controller1Model.add(this.controllerModelFactory.createControllerModel(this.controller1Model));
    this.world.rig.add(this.controller1Model);
    this.controller2Model = this.world.graphics.renderer.xr.getControllerGrip(1);
    this.controller2Model.add(this.controllerModelFactory.createControllerModel(this.controller2Model));
    this.world.rig.add(this.controller2Model);
  }
  onSessionEnd = () => {
    this.world.entities.player.avatar.mount();
    this.world.camera.position.set(0, 0, 0);
    this.world.camera.rotation.set(0, 0, 0);
    this.world.rig.remove(this.controller1Model);
    this.world.rig.remove(this.controller2Model);
    this.session = null;
    this.camera = null;
    this.controller1Model = null;
    this.controller2Model = null;
    this.world.emit("xrSession", null);
  };
};

// src/core/createClientWorld.js
function createClientWorld() {
  const world2 = new World();
  function registerSystem(key, SystemClass, proxyHandler = null) {
    const system = new SystemClass(world2);
    world2[key] = proxyHandler ? new Proxy(system, proxyHandler) : system;
    world2.systems.push(system);
    return system;
  }
  registerSystem("settings", Settings);
  registerSystem("apps", Apps);
  registerSystem("anchors", Anchors);
  registerSystem("events", Events);
  registerSystem("scripts", Scripts);
  registerSystem("chat", Chat);
  registerSystem("blueprints", Blueprints);
  registerSystem("entities", Entities);
  registerSystem("physics", Physics);
  registerSystem("stage", Stage);
  registerSystem("network", ClientNetwork);
  if (typeof window !== "undefined") {
    registerSystem("client", Client);
    registerSystem("livekit", ClientLiveKit);
    registerSystem("pointer", ClientPointer);
    registerSystem("prefs", ClientPrefs);
    registerSystem("controls", ClientControls);
    registerSystem("loader", ClientLoader);
    registerSystem("graphics", ClientGraphics);
    registerSystem("environment", ClientEnvironment);
    registerSystem("audio", ClientAudio);
    registerSystem("stats", ClientStats);
    registerSystem("builder", ClientBuilder);
    registerSystem("actions", ClientActions);
    registerSystem("target", ClientTarget);
    registerSystem("ui", ClientUI);
    registerSystem("lods", LODs);
    registerSystem("nametags", Nametags);
    registerSystem("particles", Particles2);
    registerSystem("snaps", Snaps);
    registerSystem("wind", Wind);
    registerSystem("xr", XR);
  } else {
    registerSystem("prefs", ClientPrefs);
  }
  return world2;
}

// src/client/loadPhysX.js
var promise;
function loadPhysX() {
  if (!promise) {
    promise = new Promise(async (resolve3) => {
      globalThis.PHYSX = await globalThis.PhysX();
      const version4 = PHYSX.PHYSICS_VERSION;
      const allocator = new PHYSX.PxDefaultAllocator();
      const errorCb = new PHYSX.PxDefaultErrorCallback();
      const foundation = PHYSX.CreateFoundation(version4, allocator, errorCb);
      resolve3({ version: version4, allocator, errorCb, foundation });
    });
  }
  return promise;
}

// src/core/loadNodePhysX.js
var __dirname2 = exports9.dirname(fileURLToPath2(import.meta.url));
var physxJsPath = exports9.resolve(__dirname2, "./physx-js-webidl.js");
var promise2;
var physxWasmPath;
function loadNodePhysX() {
  if (!promise2) {
    promise2 = new Promise(async (resolve3, reject) => {
      try {
        const physxJsFileUrl = pathToFileURL2(physxJsPath).href;
        const physxModule = await import(physxJsFileUrl);
        const PhysXFactory = globalThis.PhysX || physxModule.default || physxModule.PhysX;
        if (typeof PhysXFactory !== "function") {
          throw new Error(
            "PhysX factory function not found after importing bindings. Check physx-js-webidl.js build settings (EXPORT_NAME, MODULARIZE)."
          );
        }
        physxWasmPath = exports9.resolve(exports9.dirname(physxJsPath), "physx-js-webidl.wasm");
        let physxInstance;
        try {
          physxInstance = await PhysXFactory({
            locateFile: (file) => {
              if (file.endsWith(".wasm")) {
                return physxWasmPath;
              }
              return file;
            }
          });
        } catch (configError) {
          console.warn("PhysXFactory with config failed, trying without:", configError);
          physxInstance = await PhysXFactory();
        }
        if (!physxInstance || typeof physxInstance.PHYSICS_VERSION === "undefined") {
          throw new Error("Failed to initialize PhysX instance.");
        }
        globalThis.PHYSX = physxInstance;
        const version4 = PHYSX.PHYSICS_VERSION;
        const allocator = new PHYSX.PxDefaultAllocator();
        const errorCb = new PHYSX.PxDefaultErrorCallback();
        const foundation = PHYSX.CreateFoundation(version4, allocator, errorCb);
        console.log(`Node PhysX ${version4} loaded successfully.`);
        resolve3({ version: version4, allocator, errorCb, foundation });
      } catch (error) {
        console.error("Error loading Node PhysX:", error);
        reject(error);
      }
    });
  }
  return promise2;
}
export {
  System,
  createClientWorld,
  loadNodePhysX,
  loadPhysX,
  storage,
  uuid
};
/*! Bundled license information:

@jspm/core/nodelibs/browser/chunk-DtuTasat.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

@jspm/core/nodelibs/browser/chunk-CjPlbOtt.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   *)

@jspm/core/nodelibs/browser/chunk-B738Er4n.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=core.js.map
